#!/bin/sh

KILLDELAY=3
umask 022
export PATH="/bin:/usr/bin:/sbin:/usr/sbin:/usr/local/bin:/usr/local/sbin"

COLUMNS=80
COL=$(($COLUMNS - 10))
SET_COL="\033[${COL}C"
CURS_UP="\033[A"

echo_ok()
{
    echo -e "$CURS_UP$SET_COL[ OK ]"
}

echo_failure()
{
    echo -e "$CURS_UP$SET_COL[ FAIL ]"
}

echo_warning()
{
    echo -e "$CURS_UP$SET_COL[ WARN ]"
}

print_status()
{
    if [ $# = 0 ]; then
	echo "Usage: $0 {success|warning|failure}"
	return 1
    fi
    case "$1" in
	success)
	    echo_ok
	    ;;
	warning)
	    case "$2" in
		running)
		    echo_warning "Already running"
		    ;;
		not_running)
		    echo_warning "Not running"
		    ;;
	    esac
	    ;;
	failure)
	    echo_failure
	    ;;
    esac
}

evaluate_retval()
{
    error_value=$?
    if [ $error_value = 0 ]; then
	print_status success
	sleep 0
    else
	print_status failure
	sleep 3
    fi
    return 0
}

getpids()
{
    base=${1##*/}
    local lpids=""
    local pid
    pidlist=""
    lpids=$(pidof $base)
    for pid in $lpids
    do
	if [ $pid -ne $$ ] && [ $pid -ne $PPID ]; then
	    pidlist="$pidlist $pid"
	fi
    done
}

loadproc()
{
    if [ $# = 0 ]; then
	echo "Usage: loadproc {program}"
	exit 1
    fi
    getpids $1
    if [ -z "$pidlist" ]; then
	"$@"
	evaluate_retval
    else
	print_status warning running
    fi
}

killproc()
{
    if [ $# = 0 ]; then
	echo "Usage: killproc {program} [signal]"
	exit 1
    fi
    if [ -z "$2" ]; then
	signal=TERM
	fallback=KILL
    else
	signal=${2##-}
	signal=${signal##SIG}
	fallback=""
    fi
    getpids $1
    if [ -n "$pidlist" ]; then
	local i=0
	for pid in $pidlist
	do
	    kill -$signal $pid 2>/dev/null
	    while [ $i -lt $KILLDELAY ]
	    do
		kill -0 $pid 2>/dev/null || break
		sleep 1
		i=$(($i+1))
	    done
	    if [ -n "$fallback" ]; then
		kill -$fallback $pid 2>/dev/null
	    fi
	done
	getpids $1
	base=${1##*/}
	if [ -n "$pidlist" ]; then
	    failure=1
	else
	    failure=0
	    rm -f /var/run/$base.pid
	fi
	(exit $failure)
	evaluate_retval
    else
	print_status warning not_running
    fi
}

reloadproc()
{
    if [ $# = 0 ]; then
	echo "Usage: reloadproc {program} [signal]"
	exit 1
    fi
    if [ -z "$2" ]; then
	signal=HUP
    else
	signal=${2##-}
	signal=${signal##SIG}
    fi
    getpids $1
    if [ -n "$pidlist" ]; then
	failure=0
	for pid in $pidlist
	do
	    kill -$signal $pid || failure=1
	done
	(exit $failure)
	evaluate_retval
    else
	print_status warning not_running
    fi
}

statusproc()
{
    if [ $# = 0 ]; then
	echo "Usage: statusproc {program}"
	exit 1
    fi
    base=${1##*/}
    getpids $base
    if [ -n "$pidlist" ]; then
	echo "$base is running with Process ID(s) $pidlist"
    else
	if [ -s /var/run/$base.pid ]; then
	    echo "$1 is not running but /var/run/$base.pid exists"
	    return 1
	else
	    echo "$1 is not running"
	fi
    fi
}

is_wireless_device()
{
    [ -x /sbin/iwconfig ] || return 1
    LC_ALL=C iwconfig $1 2>&1 | grep -q "no wireless extensions" || return 0
    return 1
}
