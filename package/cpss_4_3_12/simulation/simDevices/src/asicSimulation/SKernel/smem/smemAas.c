/******************************************************************************
*              (c), Copyright 2001, Marvell International Ltd.                 *
* THIS CODE CONTAINS CONFIDENTIAL INFORMATION OF MARVELL SEMICONDUCTOR, INC.   *
* NO RIGHTS ARE GRANTED HEREIN UNDER ANY PATENT, MASK WORK RIGHT OR COPYRIGHT  *
* OF MARVELL OR ANY THIRD PARTY. MARVELL RESERVES THE RIGHT AT ITS SOLE        *
* DISCRETION TO REQUEST THAT THIS CODE BE IMMEDIATELY RETURNED TO MARVELL.     *
* THIS CODE IS PROVIDED "AS IS". MARVELL MAKES NO WARRANTIES, EXPRESSED,       *
* IMPLIED OR OTHERWISE, REGARDING ITS ACCURACY, COMPLETENESS OR PERFORMANCE.   *
********************************************************************************
* smemAas.c
*
* DESCRIPTION:
*       AAS memory mapping implementation
*
* DEPENDENCIES:
*       None.
*
* FILE REVISION NUMBER:
*       $Revision: 1 $
*
*******************************************************************************/

#include <asicSimulation/SKernel/smem/smemAas.h>
#include <asicSimulation/SKernel/smem/smemAasAddrSpace.h>
#include <asicSimulation/SKernel/cheetahCommon/sregCheetah.h>
#include <asicSimulation/SKernel/smem/smemCheetah.h>
#include <asicSimulation/SLog/simLog.h>
#include <common/Utils/Math/sMath.h>
#include <asicSimulation/SKernel/suserframes/snetAasExactMatch.h>
#include <asicSimulation/SKernel/suserframes/snetAasGdma.h>

#define FDB_TABLE_ALIGN_IN_BYTES    32
#define FDB_REG_OFFSET              0x02000000

#define NUM_BITS_VPORTS  18                 /* 18 bit --> 256K vPorts */
#define NUM_VPORTS  (1<<NUM_BITS_VPORTS)    /* _256K */
#define NUM_TRUNKS_ECMP  (8*_1K)
#define NUM_EPORTS  (16*_1K)
#define NUM_EVIDS   (64*_1K)
#define NUM_4K_VLANS   (4*_1K)
#define NUM_PHY_PORTS  _1K
#define NUM_DEF_EPORTS  (_1K)
#define NUM_IP2ME   (256)
#define NUM_TRUNKS  (_1K)
#define NUM_STGS    (512)
#define NUM_PORT_ISOLATION  (4*_1K + 1*_1K)
#define NUM_VIDXS    (5*_1K)
#define NUM_SSTS     (4*_1K)
#define NUM_MY_PHYSICAL_PORT    304
#define NUM_ARPS    (1024*_1K)
#define NUM_TS      (128*_1K)
#define CNC_QUEUE_PORT_MAPPING_MEMORY_NUM   NUM_PHY_PORTS
#define TXQ_PDX_QUEUE_GROUP_MAP_NUM     (1024)
#define NUM_VRFS    (32*_1K)
#define NUM_ANALYZER_PORTS    63

#define NUM_HECMP_LTT  (32*_1K) SIM_TBD_BOOKMARK/*not in Cider yet*/
#define NUM_HECMP_ECMP (16*_1K) SIM_TBD_BOOKMARK/*not in Cider yet*/

#define CNC_UNIT_SIZE   (5 *   _1M)
#define CNC_UNIT_ALIGNMENT_SIZE   (8 *   _1M)
#define GDMA_UNIT_SIZE  (32 * _1K)

/* offset between tile 0 to tile 1 */
#define TILE_OFFSET          0x80000000

/* number of DP units per tile */
#define NUM_DP_UNITS  4

#define NUM_MAC_UNITS   12 /* 3 MAC units per DP unit (without the one for the CPU) */

/* used for GM devices */
GT_U32   simAasMgBaseAddr = AAS_ADDR_MG0;

#define TSU_0_BASE_ADDR AAS_ADDR_GOP0_CTSU
#define TSU_1_BASE_ADDR AAS_ADDR_GOP1_CTSU
#define TSU_2_BASE_ADDR AAS_ADDR_GOP2_CTSU
#define TSU_3_BASE_ADDR AAS_ADDR_GOP3_CTSU

#define SET_GOP_MAC_UNITS(_global,_gop,_local)    \
        devObjPtr->memUnitBaseAddrInfo.macMib[_global]  = AAS_ADDR_GOP##_gop##_16P_MAC800_##_local + MAC_MIB_OFFSET; \
        devObjPtr->memUnitBaseAddrInfo.macWrap[_global] = AAS_ADDR_GOP##_gop##_16P_MAC800_##_local

#define SET_GOP_PCS_UNITS(_gop)    \
        devObjPtr->memUnitBaseAddrInfo.macPcs[_gop]  = AAS_ADDR_GOP##_gop##_16P_PCS800


static const GT_U8 mifUnitIndexToDp[] =
    {/*DP0*/0,0,0,/*DP1*/1,1,1,/*DP1*/2,2,2,/*DP3*/3,3,3,/*CPU*/1,/*DP3-FlexE*/3,3,3,3};
static const GT_U8 mifUnitStartPortInDp[] = /* FlexE numbers should be fixed */
    {/*DP0*/0,8,16,/*DP1*/0,8,16,/*DP1*/0,8,16,/*DP3*/0,8,16,/*CPU*/21,/*DP3-FlexE*/32,48,64,80};
static const GT_U32 mifUnitsPerTile = 17;
static const GT_U32 numOfDpPerTile = 4;

/* offsets within the : Hawk/Core/EPI/<400_MAC>MTIP IP 400 MAC WRAPPER/ */
#define MAC_EXT_BASE_OFFSET       0x00000000
#define MAC_MIB_OFFSET            0x0000A000 /* moved to allow larger unit */
#define MAC_400G_OFFSET           0x00009000
#define PORT0_100G_OFFSET         0x00001000
#define EMAC_OFFSET               0x00000100

#define NUM_TSU_UNITS  4

#ifndef _64K
    #define _64K (64*1024)
#endif

#define MAC_UNIT_SIZE _64K
#define PCS_UNIT_SIZE _64K

#define MIF_0_BASE_ADDR         AAS_ADDR_GOP0_16P_MIF_0   /*PRV_CPSS_DXCH_UNIT_MIF_800G_0_E*/
#define MIF_1_BASE_ADDR         AAS_ADDR_GOP0_16P_MIF_1   /*PRV_CPSS_DXCH_UNIT_MIF_400G_0_E*/
#define MIF_2_BASE_ADDR         AAS_ADDR_GOP0_4P_MIF      /*PRV_CPSS_DXCH_UNIT_MIF_4P_0_E  */
#define MIF_3_BASE_ADDR         AAS_ADDR_GOP1_16P_MIF_0   /*PRV_CPSS_DXCH_UNIT_MIF_800G_1_E*/
#define MIF_4_BASE_ADDR         AAS_ADDR_GOP1_16P_MIF_1   /*PRV_CPSS_DXCH_UNIT_MIF_400G_1_E*/
#define MIF_5_BASE_ADDR         AAS_ADDR_GOP1_4P_MIF      /*PRV_CPSS_DXCH_UNIT_MIF_4P_1_E  */
#define MIF_6_BASE_ADDR         AAS_ADDR_GOP2_16P_MIF_0   /*PRV_CPSS_DXCH_UNIT_MIF_800G_2_E*/
#define MIF_7_BASE_ADDR         AAS_ADDR_GOP2_16P_MIF_1   /*PRV_CPSS_DXCH_UNIT_MIF_400G_2_E*/
#define MIF_8_BASE_ADDR         AAS_ADDR_GOP2_4P_MIF      /*PRV_CPSS_DXCH_UNIT_MIF_4P_2_E  */
#define MIF_9_BASE_ADDR         AAS_ADDR_GOP3_16P_MIF_0   /*PRV_CPSS_DXCH_UNIT_MIF_800G_3_E*/
#define MIF_10_BASE_ADDR        AAS_ADDR_GOP3_16P_MIF_1   /*PRV_CPSS_DXCH_UNIT_MIF_400G_3_E*/
#define MIF_11_BASE_ADDR        AAS_ADDR_GOP3_4P_MIF      /*PRV_CPSS_DXCH_UNIT_MIF_4P_3_E  */
#define MIF_12_BASE_ADDR        AAS_ADDR_GOP1_CPU_MIF     /*PRV_CPSS_DXCH_UNIT_MIF_CPU_0_E */
#define MIF_13_BASE_ADDR        AAS_ADDR_GOP2_80P_MIF_0   /*PRV_CPSS_DXCH_UNIT_MIF_RP_0_E  */
#define MIF_14_BASE_ADDR        AAS_ADDR_GOP2_80P_MIF_1   /*PRV_CPSS_DXCH_UNIT_MIF_RP_0_E  */
#define MIF_15_BASE_ADDR        AAS_ADDR_GOP2_80P_MIF_2   /*PRV_CPSS_DXCH_UNIT_MIF_RP_0_E  */
#define MIF_16_BASE_ADDR        AAS_ADDR_GOP2_80P_MIF_3   /*PRV_CPSS_DXCH_UNIT_MIF_RP_3_E  */

#define ANP_0_BASE_ADDR         AAS_ADDR_GOP0_16P_ANP8_0
#define ANP_1_BASE_ADDR         AAS_ADDR_GOP0_16P_ANP8_1
#define ANP_2_BASE_ADDR         AAS_ADDR_GOP1_16P_ANP8_0
#define ANP_3_BASE_ADDR         AAS_ADDR_GOP1_16P_ANP8_1
#define ANP_4_BASE_ADDR         AAS_ADDR_GOP2_16P_ANP8_0
#define ANP_5_BASE_ADDR         AAS_ADDR_GOP2_16P_ANP8_1
#define ANP_6_BASE_ADDR         AAS_ADDR_GOP3_16P_ANP8_0
#define ANP_7_BASE_ADDR         AAS_ADDR_GOP3_16P_ANP8_1
#define ANP_8_BASE_ADDR         AAS_ADDR_GOP0_4P_ANP1_0
#define ANP_9_BASE_ADDR         AAS_ADDR_GOP0_4P_ANP1_1
#define ANP_10_BASE_ADDR        AAS_ADDR_GOP0_4P_ANP1_2
#define ANP_11_BASE_ADDR        AAS_ADDR_GOP0_4P_ANP1_3
#define ANP_12_BASE_ADDR        AAS_ADDR_GOP1_4P_ANP1_0
#define ANP_13_BASE_ADDR        AAS_ADDR_GOP1_4P_ANP1_1
#define ANP_14_BASE_ADDR        AAS_ADDR_GOP1_4P_ANP1_2
#define ANP_15_BASE_ADDR        AAS_ADDR_GOP1_4P_ANP1_3
#define ANP_16_BASE_ADDR        AAS_ADDR_GOP2_4P_ANP1_0
#define ANP_17_BASE_ADDR        AAS_ADDR_GOP2_4P_ANP1_1
#define ANP_18_BASE_ADDR        AAS_ADDR_GOP2_4P_ANP1_2
#define ANP_19_BASE_ADDR        AAS_ADDR_GOP2_4P_ANP1_3
#define ANP_20_BASE_ADDR        AAS_ADDR_GOP3_4P_ANP1_0
#define ANP_21_BASE_ADDR        AAS_ADDR_GOP3_4P_ANP1_1
#define ANP_22_BASE_ADDR        AAS_ADDR_GOP3_4P_ANP1_2
#define ANP_23_BASE_ADDR        AAS_ADDR_GOP3_4P_ANP1_3
#define ANP_CPU_BASE_ADDR       AAS_ADDR_GOP1_CPU_ANP1

#define SDW0_BASE_ADDR          AAS_ADDR_GOP0_16P_SDW_112G_X4_0
#define SDW1_BASE_ADDR          AAS_ADDR_GOP0_16P_SDW_112G_X4_1
#define SDW2_BASE_ADDR          AAS_ADDR_GOP0_16P_SDW_56G_X4_0
#define SDW3_BASE_ADDR          AAS_ADDR_GOP0_16P_SDW_56G_X4_1
#define SDW4_BASE_ADDR          AAS_ADDR_GOP1_16P_SDW_112G_X4_0
#define SDW5_BASE_ADDR          AAS_ADDR_GOP1_16P_SDW_112G_X4_1
#define SDW6_BASE_ADDR          AAS_ADDR_GOP1_16P_SDW_56G_X4_0
#define SDW7_BASE_ADDR          AAS_ADDR_GOP1_16P_SDW_56G_X4_1
#define SDW8_BASE_ADDR          AAS_ADDR_GOP2_16P_SDW_112G_X4_0
#define SDW9_BASE_ADDR          AAS_ADDR_GOP2_16P_SDW_112G_X4_1
#define SDW10_BASE_ADDR         AAS_ADDR_GOP2_16P_SDW_56G_X4_0
#define SDW11_BASE_ADDR         AAS_ADDR_GOP2_16P_SDW_56G_X4_1
#define SDW12_BASE_ADDR         AAS_ADDR_GOP3_16P_SDW_112G_X4_0
#define SDW13_BASE_ADDR         AAS_ADDR_GOP3_16P_SDW_112G_X4_1
#define SDW14_BASE_ADDR         AAS_ADDR_GOP3_16P_SDW_56G_X4_0
#define SDW15_BASE_ADDR         AAS_ADDR_GOP3_16P_SDW_56G_X4_1
#define SDW16_BASE_ADDR         AAS_ADDR_GOP0_4P_SDW_56G_X4
#define SDW17_BASE_ADDR         AAS_ADDR_GOP1_4P_SDW_56G_X4
#define SDW18_BASE_ADDR         AAS_ADDR_GOP2_4P_SDW_56G_X4
#define SDW19_BASE_ADDR         AAS_ADDR_GOP3_4P_SDW_56G_X4
#define SDW20_BASE_ADDR         AAS_ADDR_GOP1_CPU_SDW_56G_X1

#define FLEXE_XC_0_BASE_ADDR       AAS_ADDR_GOP2_80P_XC_0
#define FLEXE_XC_TAI_0_BASE_ADDR   AAS_ADDR_GOP2_80P_XC_TAI_0
#define FLEXE_XC_1_BASE_ADDR       AAS_ADDR_GOP2_80P_XC_1
#define FLEXE_XC_TAI_1_BASE_ADDR   AAS_ADDR_GOP2_80P_XC_TAI_1
#define FLEXE_CODERS_BASE_ADDR     AAS_ADDR_GOP2_80P_CODERS
#define FLEXE_SHIM_0_BASE_ADDR     AAS_ADDR_GOP2_80P_SHIM_0
#define FLEXE_SHIM_TAI_0_BASE_ADDR AAS_ADDR_GOP2_80P_SHIM_TAI_0
#define FLEXE_SHIM_1_BASE_ADDR     AAS_ADDR_GOP2_80P_SHIM_1
#define FLEXE_SHIM_TAI_1_BASE_ADDR AAS_ADDR_GOP2_80P_SHIM_TAI_1

#define CPU_MAC_MTIP_MAC_BASE_ADDR      AAS_ADDR_GOP1_CPU_MAC100
#define CPU_MAC_MTIP_MAC_PCS_BASE_ADDR  AAS_ADDR_GOP1_CPU_PCS100


#define NUM_PORTS_PER_CTSU_UNIT   64

#define NUM_PORTS_PER_UNIT        8
#define NUM_PORTS_PER_DP_UNIT     20 /*+1 for CPU +1 for LP/SDMA */
#define NUM_PORTS_FOR_NUMBERRING_DP_UNIT        20/*+1 for CPU +1 for LP/SDMA */
#define MIF_CHANNELS_NUM_PER_UNIT NUM_PORTS_PER_DP_UNIT+2 /* without the extra 8 for the preemption channels */


#define RS_FEC_STATISTIC_CAPTURED_COUNTER_INDEX 20
#define RS_STATISTIC_CONTER_CAPTURE_OFFSET    0x00000004
#define RS_STATISTIC_CONTER_CODEWORDS_OFFSET  0x00000050

/* use runtime parameter of number of DP channels (ports)   */
/* this to allow the Aas to use the Phoenix units allocations */
/* as at this moment there is no Cider for the Aas      */
#define RUNTIME_NUM_PORTS_PER_DP_UNIT \
    ((devObjPtr->multiDataPath.info[0].cpuPortDmaNum >= devObjPtr->multiDataPath.info[0].dataPathNumOfPorts) ? \
      devObjPtr->multiDataPath.info[0].cpuPortDmaNum  :                                                        \
      devObjPtr->multiDataPath.info[0].dataPathNumOfPorts)


#define CPU_MAC_EXT_BASE_OFFSET       0x00000000
#define CPU_MAC_PORT_OFFSET           0x00003000
#define CPU_MAC_MIB_OFFSET            0x00001000

#define CPU_PCS_PORT_OFFSET           0x00000000
#define CPU_PCS_RS_FEC_OFFSET         0x00001000
#define CPU_PCS_LPCS_OFFSET           0x00002000


#define START_MIB_RX_PER_PORT 0x00000100
#define SIZE_MIB_RX_PER_PORT  (35*4) /*decimal*/
#define SIZE_MIB_RX  (SIZE_MIB_RX_PER_PORT*NUM_PORTS_PER_UNIT*2/*EMAC/PMAC*/)
#define START_MIB_TX_PER_PORT (START_MIB_RX_PER_PORT + SIZE_MIB_RX)
#define SIZE_MIB_TX_PER_PORT  (26*4) /*decimal*/
#define SIZE_MIB_TX  (SIZE_MIB_TX_PER_PORT*NUM_PORTS_PER_UNIT*2/*EMAC/PMAC*/)
#define MAC_MIB_UNIT_SIZE       0x2000
#define AAS_MAX_PROFILE_CNS   12


#define MAC_STEP_PORT_OFFSET      0x00001000

/********** start : PCS for 400G *********/
#define PCS_400G_OFFSET              0x00017000
#define PCS_200G_OFFSET              0x00018000
#define PCS_PORT0_100G_OFFSET        0x00001000
#define PCS_PORT1_50G_OFFSET         (PCS_PORT0_100G_OFFSET + PCS_STEP_PORT_OFFSET)
#define PCS_RS_FEC_OFFSET            0x00011000
#define PCS_LPCS_OFFSET              0x00013000
#define PCS_RS_FEC_STATISTICS_OFFSET 0x00015000
#define PCS_EXT_OFFSET               0x00000000


#define PCS_STEP_PORT_OFFSET      0x00001000
#define PCS400_STEP_PORT_OFFSET   0x00002000
#define LPCS_STEP_PORT_OFFSET     0x00000080
/********** end  : PCS for 400G *********/

#define ANP_OFFSET                    0x00000000
#define ANP_STEP_PORT_OFFSET          0x000002a4
#define AN_OFFSET                     0x00020000
#define AN_STEP_PORT_OFFSET           0x00001000



#define NUM_QUEUES_PER_DP_UNIT     456

static void smemAasSpecificDeviceUnitAlloc_TXQ_units
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr
);
static void smemAasSpecificDeviceUnitAlloc_SIP_units
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr
);

#define PER_TILE_INDICATION_CNS     DUMMY_PARAM_NAME_PTR_CNS(1)

/* unit per tile (same as 'per pipe' in AAS) */
#define PER_TILE_UNIT_INFO_MAC(unitName0,unitName1)  \
     {AAS_ADDR_##unitName0 /*Cider address of unit in tile 0 */ , STR(unitName1) , AAS_UNIT_SIZE_##unitName0 , PER_TILE_INDICATION_CNS}

/*
    all addresses of the device
*/
/* the units of aas */
static SMEM_GEN_UNIT_INFO_STC aas_units[] =
{
    /*dummy WM unit for IPC (that used to be in the MG unit) */
     PER_TILE_UNIT_INFO_MAC(WM_IPC  ,  UNIT_WM_IPC     )

    /* SRAM  is in the CnM section */
    ,PER_TILE_UNIT_INFO_MAC(CNM_SRAM0,UNIT_CNM_SRAM    ) /*in CnM */

    ,PER_TILE_UNIT_INFO_MAC(PHA,UNIT_PHA              )
    ,PER_TILE_UNIT_INFO_MAC(IA,UNIT_IA                )
    ,PER_TILE_UNIT_INFO_MAC(SHM0,UNIT_SHM             )
    ,PER_TILE_UNIT_INFO_MAC(EOAM,UNIT_EOAM            )/*0x20e00000*/
    ,PER_TILE_UNIT_INFO_MAC(PPU1,UNIT_PPU             )
    ,PER_TILE_UNIT_INFO_MAC(PPU2,UNIT_PPU_FOR_IPE     )

    ,PER_TILE_UNIT_INFO_MAC(DP0_SDQ    ,UNIT_TXQ_SDQ0     )
    ,PER_TILE_UNIT_INFO_MAC(DP0_PDS    ,UNIT_TXQ_PDS0     )
    ,PER_TILE_UNIT_INFO_MAC(DP0_QFC    ,UNIT_TXQ_QFC0     )
    ,PER_TILE_UNIT_INFO_MAC(DP0_RX     ,UNIT_RX_DMA       )
    ,PER_TILE_UNIT_INFO_MAC(DP0_TXF    ,UNIT_TX_FIFO      )
    ,PER_TILE_UNIT_INFO_MAC(DP0_TXD    ,UNIT_TX_DMA       )
    ,PER_TILE_UNIT_INFO_MAC(GOP0_LMU_0 ,UNIT_PCA_LMU_0    )
    ,PER_TILE_UNIT_INFO_MAC(GOP0_LMU_1 ,UNIT_PCA_LMU_01   )
    ,PER_TILE_UNIT_INFO_MAC(GOP0_LMU_2 ,UNIT_PCA_LMU_02   )
    ,PER_TILE_UNIT_INFO_MAC(GOP0_LMU_3 ,UNIT_PCA_LMU_03   )
    ,PER_TILE_UNIT_INFO_MAC(GOP0_LMU_4 ,UNIT_PCA_LMU_04   )
    ,PER_TILE_UNIT_INFO_MAC(GOP0_LMU_5 ,UNIT_PCA_LMU_05   )
    ,PER_TILE_UNIT_INFO_MAC(GOP0_LMU_6 ,UNIT_PCA_LMU_06   )
    ,PER_TILE_UNIT_INFO_MAC(GOP0_LMU_7 ,UNIT_PCA_LMU_07   )
    ,PER_TILE_UNIT_INFO_MAC(GOP0_CTSU  ,UNIT_PCA_CTSU_0   )

    ,PER_TILE_UNIT_INFO_MAC(DP1_SDQ    ,UNIT_TXQ_SDQ1     )
    ,PER_TILE_UNIT_INFO_MAC(DP1_PDS    ,UNIT_TXQ_PDS1     )
    ,PER_TILE_UNIT_INFO_MAC(DP1_QFC    ,UNIT_TXQ_QFC1     )
    ,PER_TILE_UNIT_INFO_MAC(DP1_RX     ,UNIT_RX_DMA_1     )
    ,PER_TILE_UNIT_INFO_MAC(DP1_TXF    ,UNIT_TX_FIFO_1    )
    ,PER_TILE_UNIT_INFO_MAC(DP1_TXD    ,UNIT_TX_DMA_1     )
    ,PER_TILE_UNIT_INFO_MAC(GOP1_LMU_0 ,UNIT_PCA_LMU_1    )
    ,PER_TILE_UNIT_INFO_MAC(GOP1_LMU_1 ,UNIT_PCA_LMU_11   )
    ,PER_TILE_UNIT_INFO_MAC(GOP1_LMU_2 ,UNIT_PCA_LMU_12   )
    ,PER_TILE_UNIT_INFO_MAC(GOP1_LMU_3 ,UNIT_PCA_LMU_13   )
    ,PER_TILE_UNIT_INFO_MAC(GOP1_LMU_4 ,UNIT_PCA_LMU_14   )
    ,PER_TILE_UNIT_INFO_MAC(GOP1_LMU_5 ,UNIT_PCA_LMU_15   )
    ,PER_TILE_UNIT_INFO_MAC(GOP1_LMU_6 ,UNIT_PCA_LMU_16   )
    ,PER_TILE_UNIT_INFO_MAC(GOP1_LMU_7 ,UNIT_PCA_LMU_17   )
    ,PER_TILE_UNIT_INFO_MAC(GOP1_CTSU  ,UNIT_PCA_CTSU_1   )

    ,PER_TILE_UNIT_INFO_MAC(DP2_SDQ    ,UNIT_TXQ_SDQ2     )
    ,PER_TILE_UNIT_INFO_MAC(DP2_PDS    ,UNIT_TXQ_PDS2     )
    ,PER_TILE_UNIT_INFO_MAC(DP2_QFC    ,UNIT_TXQ_QFC2     )
    ,PER_TILE_UNIT_INFO_MAC(DP2_RX     ,UNIT_RX_DMA_2     )
    ,PER_TILE_UNIT_INFO_MAC(DP2_TXF    ,UNIT_TX_FIFO_2    )
    ,PER_TILE_UNIT_INFO_MAC(DP2_TXD    ,UNIT_TX_DMA_2     )
    ,PER_TILE_UNIT_INFO_MAC(GOP2_LMU_0 ,UNIT_PCA_LMU_2    )
    ,PER_TILE_UNIT_INFO_MAC(GOP2_LMU_1 ,UNIT_PCA_LMU_21   )
    ,PER_TILE_UNIT_INFO_MAC(GOP2_LMU_2 ,UNIT_PCA_LMU_22   )
    ,PER_TILE_UNIT_INFO_MAC(GOP2_LMU_3 ,UNIT_PCA_LMU_23   )
    ,PER_TILE_UNIT_INFO_MAC(GOP2_LMU_4 ,UNIT_PCA_LMU_24   )
    ,PER_TILE_UNIT_INFO_MAC(GOP2_LMU_5 ,UNIT_PCA_LMU_25   )
    ,PER_TILE_UNIT_INFO_MAC(GOP2_LMU_6 ,UNIT_PCA_LMU_26   )
    ,PER_TILE_UNIT_INFO_MAC(GOP2_LMU_7 ,UNIT_PCA_LMU_27   )
    ,PER_TILE_UNIT_INFO_MAC(GOP2_CTSU  ,UNIT_PCA_CTSU_2   )

    ,PER_TILE_UNIT_INFO_MAC(DP3_SDQ    ,UNIT_TXQ_SDQ3     )
    ,PER_TILE_UNIT_INFO_MAC(DP3_PDS    ,UNIT_TXQ_PDS3     )
    ,PER_TILE_UNIT_INFO_MAC(DP3_QFC    ,UNIT_TXQ_QFC3     )
    ,PER_TILE_UNIT_INFO_MAC(DP3_RX     ,UNIT_RX_DMA_3     )
    ,PER_TILE_UNIT_INFO_MAC(DP3_TXF    ,UNIT_TX_FIFO_3    )
    ,PER_TILE_UNIT_INFO_MAC(DP3_TXD    ,UNIT_TX_DMA_3     )
    ,PER_TILE_UNIT_INFO_MAC(GOP3_LMU_0 ,UNIT_PCA_LMU_3    )
    ,PER_TILE_UNIT_INFO_MAC(GOP3_LMU_1 ,UNIT_PCA_LMU_31   )
    ,PER_TILE_UNIT_INFO_MAC(GOP3_LMU_2 ,UNIT_PCA_LMU_32   )
    ,PER_TILE_UNIT_INFO_MAC(GOP3_LMU_3 ,UNIT_PCA_LMU_33   )
    ,PER_TILE_UNIT_INFO_MAC(GOP3_LMU_4 ,UNIT_PCA_LMU_34   )
    ,PER_TILE_UNIT_INFO_MAC(GOP3_LMU_5 ,UNIT_PCA_LMU_35   )
    ,PER_TILE_UNIT_INFO_MAC(GOP3_LMU_6 ,UNIT_PCA_LMU_36   )
    ,PER_TILE_UNIT_INFO_MAC(GOP3_LMU_7 ,UNIT_PCA_LMU_37   )
    ,PER_TILE_UNIT_INFO_MAC(GOP3_CTSU  ,UNIT_PCA_CTSU_3   )
#define EM_SIZE  (300*_1K)
    ,PER_TILE_UNIT_INFO_MAC(EMX,UNIT_EMX             )
    ,PER_TILE_UNIT_INFO_MAC(TTI_LU,UNIT_TTI_LU       )
    ,PER_TILE_UNIT_INFO_MAC(EM0   ,UNIT_EM           )
    ,PER_TILE_UNIT_INFO_MAC(EM1   ,UNIT_EM1          )
    ,PER_TILE_UNIT_INFO_MAC(EM2   ,UNIT_EM2          )
    ,PER_TILE_UNIT_INFO_MAC(EM3   ,UNIT_EM3          )
    ,PER_TILE_UNIT_INFO_MAC(EM4   ,UNIT_EM4          )
    ,PER_TILE_UNIT_INFO_MAC(EM5   ,UNIT_EM5          )
    ,PER_TILE_UNIT_INFO_MAC(EM6   ,UNIT_EM6          )
    ,PER_TILE_UNIT_INFO_MAC(EM7   ,UNIT_EM7          )
    ,PER_TILE_UNIT_INFO_MAC(EM_ILM0,UNIT_REDUCED_EM  )

    /* packet buffer subunits */
    ,PER_TILE_UNIT_INFO_MAC(PB_COUNTER, UNIT_PB_COUNTER_BLK             )
    ,PER_TILE_UNIT_INFO_MAC(WA0       , UNIT_PB_SMB_WRITE_ARBITER_0     )
    ,PER_TILE_UNIT_INFO_MAC(WA1       , UNIT_PB_SMB_WRITE_ARBITER_1     )
    ,PER_TILE_UNIT_INFO_MAC(GCR0      , UNIT_PB_GPC_GRP_CELL_READ_0     )
    ,PER_TILE_UNIT_INFO_MAC(GCR1      , UNIT_PB_GPC_GRP_CELL_READ_1     )
    ,PER_TILE_UNIT_INFO_MAC(GCR2      , UNIT_PB_GPC_GRP_CELL_READ_2     )
    ,PER_TILE_UNIT_INFO_MAC(GCR3      , UNIT_PB_GPC_GRP_CELL_READ_3     )
    ,PER_TILE_UNIT_INFO_MAC(GCR4      , UNIT_PB_GPC_GRP_CELL_READ_4     )
    ,PER_TILE_UNIT_INFO_MAC(GPW0      , UNIT_PB_GPC_GRP_PACKET_WRITE_0  )
    ,PER_TILE_UNIT_INFO_MAC(GPW1      , UNIT_PB_GPC_GRP_PACKET_WRITE_1  )
    ,PER_TILE_UNIT_INFO_MAC(GPW2      , UNIT_PB_GPC_GRP_PACKET_WRITE_2  )
    ,PER_TILE_UNIT_INFO_MAC(GPW3      , UNIT_PB_GPC_GRP_PACKET_WRITE_3  )
    ,PER_TILE_UNIT_INFO_MAC(GPW4      , UNIT_PB_GPC_GRP_PACKET_WRITE_4  )
    ,PER_TILE_UNIT_INFO_MAC(GPR0      , UNIT_PB_GPC_GRP_PACKET_READ_0   )
    ,PER_TILE_UNIT_INFO_MAC(GPR1      , UNIT_PB_GPC_GRP_PACKET_READ_1   )
    ,PER_TILE_UNIT_INFO_MAC(GPR2      , UNIT_PB_GPC_GRP_PACKET_READ_2   )
    ,PER_TILE_UNIT_INFO_MAC(GPR3      , UNIT_PB_GPC_GRP_PACKET_READ_3   )
    ,PER_TILE_UNIT_INFO_MAC(GPR4      , UNIT_PB_GPC_GRP_PACKET_READ_4   )
    ,PER_TILE_UNIT_INFO_MAC(SMB0      , UNIT_PB_SHARED_MEMO_BUF_0_0     )
    ,PER_TILE_UNIT_INFO_MAC(SMB1      , UNIT_PB_SHARED_MEMO_BUF_0_1     )
    ,PER_TILE_UNIT_INFO_MAC(SMB2      , UNIT_PB_SHARED_MEMO_BUF_1_0     )
    ,PER_TILE_UNIT_INFO_MAC(NPM0      , UNIT_PB_NEXT_POINTER_MEMO_0     )
    ,PER_TILE_UNIT_INFO_MAC(NPM1      , UNIT_PB_NEXT_POINTER_MEMO_1     )

    ,PER_TILE_UNIT_INFO_MAC(PDX_PDITX,UNIT_TXQ_PDX       )
    ,PER_TILE_UNIT_INFO_MAC(PFCC,UNIT_TXQ_PFCC           )
    ,PER_TILE_UNIT_INFO_MAC(PSI ,UNIT_TXQ_PSI            )

    ,PER_TILE_UNIT_INFO_MAC(GOP0_PCA_PIZARB,UNIT_PCA_PZ_ARBITER_0   )
    ,PER_TILE_UNIT_INFO_MAC(GOP1_PCA_PIZARB,UNIT_PCA_PZ_ARBITER_1   )
    ,PER_TILE_UNIT_INFO_MAC(GOP2_PCA_PIZARB,UNIT_PCA_PZ_ARBITER_2   )
    ,PER_TILE_UNIT_INFO_MAC(GOP3_PCA_PIZARB,UNIT_PCA_PZ_ARBITER_3   )
    ,PER_TILE_UNIT_INFO_MAC(GOP0_SFF,UNIT_PCA_SFF_0              )
    ,PER_TILE_UNIT_INFO_MAC(GOP1_SFF,UNIT_PCA_SFF_1              )
    ,PER_TILE_UNIT_INFO_MAC(GOP2_SFF,UNIT_PCA_SFF_2              )
    ,PER_TILE_UNIT_INFO_MAC(GOP3_SFF,UNIT_PCA_SFF_3              )

    ,PER_TILE_UNIT_INFO_MAC(GOP0_MACSEC_WRP_163E, UNIT_PCA_MACSEC_EXT_E_163_0 )
    ,PER_TILE_UNIT_INFO_MAC(GOP0_MACSEC_WRP_163I, UNIT_PCA_MACSEC_EXT_I_163_0 )
    ,PER_TILE_UNIT_INFO_MAC(GOP0_MACSEC_WRP_164E, UNIT_PCA_MACSEC_EXT_E_164_0 )
    ,PER_TILE_UNIT_INFO_MAC(GOP0_MACSEC_WRP_164I, UNIT_PCA_MACSEC_EXT_I_164_0 )
    ,PER_TILE_UNIT_INFO_MAC(GOP1_MACSEC_WRP_163E, UNIT_PCA_MACSEC_EXT_E_163_1 )
    ,PER_TILE_UNIT_INFO_MAC(GOP1_MACSEC_WRP_163I, UNIT_PCA_MACSEC_EXT_I_163_1 )
    ,PER_TILE_UNIT_INFO_MAC(GOP1_MACSEC_WRP_164E, UNIT_PCA_MACSEC_EXT_E_164_1 )
    ,PER_TILE_UNIT_INFO_MAC(GOP1_MACSEC_WRP_164I, UNIT_PCA_MACSEC_EXT_I_164_1 )
    ,PER_TILE_UNIT_INFO_MAC(GOP2_MACSEC_WRP_163E, UNIT_PCA_MACSEC_EXT_E_163_2 )
    ,PER_TILE_UNIT_INFO_MAC(GOP2_MACSEC_WRP_163I, UNIT_PCA_MACSEC_EXT_I_163_2 )
    ,PER_TILE_UNIT_INFO_MAC(GOP2_MACSEC_WRP_164E, UNIT_PCA_MACSEC_EXT_E_164_2 )
    ,PER_TILE_UNIT_INFO_MAC(GOP2_MACSEC_WRP_164I, UNIT_PCA_MACSEC_EXT_I_164_2 )
    ,PER_TILE_UNIT_INFO_MAC(GOP3_MACSEC_WRP_163E, UNIT_PCA_MACSEC_EXT_E_163_3 )
    ,PER_TILE_UNIT_INFO_MAC(GOP3_MACSEC_WRP_163I, UNIT_PCA_MACSEC_EXT_I_163_3 )
    ,PER_TILE_UNIT_INFO_MAC(GOP3_MACSEC_WRP_164E, UNIT_PCA_MACSEC_EXT_E_164_3 )
    ,PER_TILE_UNIT_INFO_MAC(GOP3_MACSEC_WRP_164I, UNIT_PCA_MACSEC_EXT_I_164_3 )

    ,PER_TILE_UNIT_INFO_MAC(GOP0_MACSEC_163I,UNIT_PCA_MACSEC_EIP_163_I_0  )
    ,PER_TILE_UNIT_INFO_MAC(GOP0_MACSEC_163E,UNIT_PCA_MACSEC_EIP_163_E_0  )
    ,PER_TILE_UNIT_INFO_MAC(GOP0_MACSEC_164I,UNIT_PCA_MACSEC_EIP_164_I_0  )
    ,PER_TILE_UNIT_INFO_MAC(GOP0_MACSEC_164E,UNIT_PCA_MACSEC_EIP_164_E_0  )

    ,PER_TILE_UNIT_INFO_MAC(GOP0_ING_SHM, UNIT_PCA_BRG_EDGE_RX_0     ) /*0x0CB50000 - 0x0CBFFFFF*/
    ,PER_TILE_UNIT_INFO_MAC(GOP1_ING_SHM, UNIT_PCA_BRG_EDGE_RX_1     )
    ,PER_TILE_UNIT_INFO_MAC(GOP2_ING_SHM, UNIT_PCA_BRG_EDGE_RX_2     )
    ,PER_TILE_UNIT_INFO_MAC(GOP3_ING_SHM, UNIT_PCA_BRG_EDGE_RX_3     )
    ,PER_TILE_UNIT_INFO_MAC(GOP0_SHM_EGR, UNIT_PCA_BRG_EDGE_TX_0      )
    ,PER_TILE_UNIT_INFO_MAC(GOP1_SHM_EGR, UNIT_PCA_BRG_EDGE_TX_1      )
    ,PER_TILE_UNIT_INFO_MAC(GOP2_SHM_EGR, UNIT_PCA_BRG_EDGE_TX_2      )
    ,PER_TILE_UNIT_INFO_MAC(GOP3_SHM_EGR, UNIT_PCA_BRG_EDGE_TX_3      )
    ,PER_TILE_UNIT_INFO_MAC(GOP0_RX_PACK , UNIT_PCA_BRG_PACK_RX_0     )
    ,PER_TILE_UNIT_INFO_MAC(GOP1_RX_PACK , UNIT_PCA_BRG_PACK_RX_1     )
    ,PER_TILE_UNIT_INFO_MAC(GOP2_RX_PACK , UNIT_PCA_BRG_PACK_RX_2     )
    ,PER_TILE_UNIT_INFO_MAC(GOP3_RX_PACK , UNIT_PCA_BRG_PACK_RX_3     ) /*0x0CC700000 - 0x0CCFFFFF*/
    ,PER_TILE_UNIT_INFO_MAC(GOP0_TX_UPACK, UNIT_PCA_BRG_UNPACK_TX_0   )
    ,PER_TILE_UNIT_INFO_MAC(GOP1_TX_UPACK, UNIT_PCA_BRG_UNPACK_TX_1   )
    ,PER_TILE_UNIT_INFO_MAC(GOP2_TX_UPACK, UNIT_PCA_BRG_UNPACK_TX_2   )
    ,PER_TILE_UNIT_INFO_MAC(GOP3_TX_UPACK, UNIT_PCA_BRG_UNPACK_TX_3   )
    ,PER_TILE_UNIT_INFO_MAC(GOP0_RX_EDGE , UNIT_PCA_BRG_SHM_RX_0      )
    ,PER_TILE_UNIT_INFO_MAC(GOP1_RX_EDGE , UNIT_PCA_BRG_SHM_RX_1      )
    ,PER_TILE_UNIT_INFO_MAC(GOP2_RX_EDGE , UNIT_PCA_BRG_SHM_RX_2      )
    ,PER_TILE_UNIT_INFO_MAC(GOP3_RX_EDGE , UNIT_PCA_BRG_SHM_RX_3      )
    ,PER_TILE_UNIT_INFO_MAC(GOP0_TX_EDGE , UNIT_PCA_BRG_SHM_TX_0      ) /*0x0CD50000 - 0x0CD8FFFF*/
    ,PER_TILE_UNIT_INFO_MAC(GOP1_TX_EDGE , UNIT_PCA_BRG_SHM_TX_1      )
    ,PER_TILE_UNIT_INFO_MAC(GOP2_TX_EDGE , UNIT_PCA_BRG_SHM_TX_2      )
    ,PER_TILE_UNIT_INFO_MAC(GOP3_TX_EDGE , UNIT_PCA_BRG_SHM_TX_3      )

    /* DFX */
    ,PER_TILE_UNIT_INFO_MAC(SERVER, UNIT_DFX_SERVER      )

    ,PER_TILE_UNIT_INFO_MAC(TTI,UNIT_TTI               )

    /* TAI 0,1 */
    ,PER_TILE_UNIT_INFO_MAC(IPLR_TAI   /*dummy*/,UNIT_TAI               )
    ,PER_TILE_UNIT_INFO_MAC(PHA_TAI    /*dummy*/,UNIT_TAI_1             )
    ,PER_TILE_UNIT_INFO_MAC(TTI_TAI_0  /*dummy*/,UNIT_TAI_2             )

    ,PER_TILE_UNIT_INFO_MAC(EPLR,UNIT_EPLR           )
    ,PER_TILE_UNIT_INFO_MAC(EPCL,UNIT_EPCL           )
    ,PER_TILE_UNIT_INFO_MAC(MPCL,UNIT_MPCL           )
    ,PER_TILE_UNIT_INFO_MAC(PREQ,UNIT_PREQ           )
    ,PER_TILE_UNIT_INFO_MAC(ERMRK,UNIT_ERMRK         )
    ,PER_TILE_UNIT_INFO_MAC(EREP,UNIT_EREP           )
    ,PER_TILE_UNIT_INFO_MAC(BMA,UNIT_BMA             )
    ,PER_TILE_UNIT_INFO_MAC(HBU,UNIT_HBU             )
    ,PER_TILE_UNIT_INFO_MAC(HA,UNIT_HA               )

    ,PER_TILE_UNIT_INFO_MAC(TCAM,UNIT_TCAM           )
    ,PER_TILE_UNIT_INFO_MAC(FDB,UNIT_FDB             )

    ,PER_TILE_UNIT_INFO_MAC(PCL,UNIT_IPCL            )

    ,PER_TILE_UNIT_INFO_MAC(CNC0,UNIT_CNC            )
    ,PER_TILE_UNIT_INFO_MAC(CNC1,UNIT_CNC_1          )
    ,PER_TILE_UNIT_INFO_MAC(CNC2,UNIT_CNC_2          )
    ,PER_TILE_UNIT_INFO_MAC(CNC3,UNIT_CNC_3          )

    ,PER_TILE_UNIT_INFO_MAC(EGF_QAG,UNIT_EGF_QAG     )
    ,PER_TILE_UNIT_INFO_MAC(EGF_SHT,UNIT_EGF_SHT     )
    ,PER_TILE_UNIT_INFO_MAC(EGF_EFT,UNIT_EGF_EFT     )

    ,PER_TILE_UNIT_INFO_MAC(IPLR0,UNIT_IPLR          )
    ,PER_TILE_UNIT_INFO_MAC(IPLR1,UNIT_IPLR1         )
    ,PER_TILE_UNIT_INFO_MAC(SMU,UNIT_SMU             )

    ,PER_TILE_UNIT_INFO_MAC(EQ,UNIT_EQ               )
    ,PER_TILE_UNIT_INFO_MAC(IOAM,UNIT_IOAM           )
    ,PER_TILE_UNIT_INFO_MAC(MLL,UNIT_MLL             )

    ,PER_TILE_UNIT_INFO_MAC(IPVX,UNIT_IPVX           )
    ,PER_TILE_UNIT_INFO_MAC(LPM,UNIT_LPM             )
    ,PER_TILE_UNIT_INFO_MAC(L2I,UNIT_L2I             )
    ,PER_TILE_UNIT_INFO_MAC(IPE,UNIT_IPE             )
    ,PER_TILE_UNIT_INFO_MAC(GOP0_16P_LED_0,UNIT_LED_0        )
    ,PER_TILE_UNIT_INFO_MAC(GOP1_16P_LED_0,UNIT_LED_1        )
    ,PER_TILE_UNIT_INFO_MAC(GOP2_16P_LED_0,UNIT_LED_2        )
    ,PER_TILE_UNIT_INFO_MAC(GOP3_16P_LED_0,UNIT_LED_3        )

    /* RFU is in the CnM section */
    ,PER_TILE_UNIT_INFO_MAC(CNM_CnM_RFU,UNIT_CNM_RFU    ) /*in CnM */
    /* MPP_RFU is in the CnM section */
    ,PER_TILE_UNIT_INFO_MAC(CNM_MPP_RFU ,UNIT_CNM_MPP_RFU) /*in CnM */

    /* SMI is in the CnM section */
    ,PER_TILE_UNIT_INFO_MAC(CNM_SMI_0 ,UNIT_GOP_SMI_0  ) /*in CnM */
    ,PER_TILE_UNIT_INFO_MAC(CNM_SMI_1 ,UNIT_GOP_SMI_1  ) /*in CnM */
     /* AAC is in the CnM section */
    ,PER_TILE_UNIT_INFO_MAC(CNM_AAC_0,UNIT_CNM_AAC    ) /*in CnM */

    ,PER_TILE_UNIT_INFO_MAC(CNM_Address_Decoder_iNIC     , UNIT_ADDR_CNM_Address_Decoder_iNIC     )/*in CnM */
    ,PER_TILE_UNIT_INFO_MAC(CNM_Address_Decoder_PCIe     , UNIT_ADDR_CNM_Address_Decoder_PCIe     )/*in CnM */
    ,PER_TILE_UNIT_INFO_MAC(CNM_Address_Decoder_iunit    , UNIT_ADDR_CNM_Address_Decoder_iunit    )/*in CnM */
    ,PER_TILE_UNIT_INFO_MAC(CNM_Address_Decoder_GDMA0    , UNIT_ADDR_CNM_Address_Decoder_GDMA0    )/*in CnM */
    ,PER_TILE_UNIT_INFO_MAC(CNM_Address_Decoder_GDMA1    , UNIT_ADDR_CNM_Address_Decoder_GDMA1    )/*in CnM */
    ,PER_TILE_UNIT_INFO_MAC(CNM_Address_Decoder_GDMA2    , UNIT_ADDR_CNM_Address_Decoder_GDMA2    )/*in CnM */
    ,PER_TILE_UNIT_INFO_MAC(CNM_Address_Decoder_GDMA3    , UNIT_ADDR_CNM_Address_Decoder_GDMA3    )/*in CnM */
    ,PER_TILE_UNIT_INFO_MAC(CNM_Address_Decoder_EHSM_DMA , UNIT_ADDR_CNM_Address_Decoder_EHSM_DMA )/*in CnM */
    ,PER_TILE_UNIT_INFO_MAC(CNM_Address_Decoder_AAC_0    , UNIT_ADDR_CNM_Address_Decoder_AAC_0    )/*in CnM */
    ,PER_TILE_UNIT_INFO_MAC(CNM_Address_Decoder_AAC_1    , UNIT_ADDR_CNM_Address_Decoder_AAC_1    )/*in CnM */
    ,PER_TILE_UNIT_INFO_MAC(CNM_Address_Decoder_AMB      , UNIT_ADDR_CNM_Address_Decoder_AMB      )/*in CnM */

     /* PEX MAC is in the CnM section */
    ,PER_TILE_UNIT_INFO_MAC(CNM_PCIe_MAC_DBI,UNIT_CNM_PEX_MAC   )/*in CnM */

    /* MAC and PCS for the 400G MACs */
    ,PER_TILE_UNIT_INFO_MAC(GOP0_16P_MAC800_0,UNIT_MAC_400G_0   )
    ,PER_TILE_UNIT_INFO_MAC(GOP0_16P_MAC800_1,UNIT_MAC_400G_1   )
    ,PER_TILE_UNIT_INFO_MAC(GOP1_16P_MAC800_0,UNIT_MAC_400G_2   )
    ,PER_TILE_UNIT_INFO_MAC(GOP1_16P_MAC800_1,UNIT_MAC_400G_3   )
    ,PER_TILE_UNIT_INFO_MAC(GOP2_16P_MAC800_0,UNIT_MAC_400G_4   )
    ,PER_TILE_UNIT_INFO_MAC(GOP2_16P_MAC800_1,UNIT_MAC_400G_5   )
    ,PER_TILE_UNIT_INFO_MAC(GOP3_16P_MAC800_0,UNIT_MAC_400G_6   )
    ,PER_TILE_UNIT_INFO_MAC(GOP3_16P_MAC800_1,UNIT_MAC_400G_7   )

    ,PER_TILE_UNIT_INFO_MAC(GOP0_16P_PCS800,UNIT_PCS_400G_0     )
    ,PER_TILE_UNIT_INFO_MAC(GOP1_16P_PCS800,UNIT_PCS_400G_1     )
    ,PER_TILE_UNIT_INFO_MAC(GOP2_16P_PCS800,UNIT_PCS_400G_2     )
    ,PER_TILE_UNIT_INFO_MAC(GOP3_16P_PCS800,UNIT_PCS_400G_3     )

    ,PER_TILE_UNIT_INFO_MAC(GOP1_CPU_MAC100    ,UNIT_MAC_CPU  )
    ,PER_TILE_UNIT_INFO_MAC(GOP1_CPU_PCS100    ,UNIT_PCS_CPU  )

    /*MIF */
    ,PER_TILE_UNIT_INFO_MAC(GOP0_16P_MIF_0,  UNIT_MIF_0              )
    ,PER_TILE_UNIT_INFO_MAC(GOP0_16P_MIF_1,  UNIT_MIF_1              )
    ,PER_TILE_UNIT_INFO_MAC(GOP0_4P_MIF   ,  UNIT_MIF_2              )
    ,PER_TILE_UNIT_INFO_MAC(GOP1_16P_MIF_0,  UNIT_MIF_3              )
    ,PER_TILE_UNIT_INFO_MAC(GOP1_16P_MIF_1,  UNIT_MIF_4              )
    ,PER_TILE_UNIT_INFO_MAC(GOP1_4P_MIF   ,  UNIT_MIF_5              )
    ,PER_TILE_UNIT_INFO_MAC(GOP2_16P_MIF_0,  UNIT_MIF_6              )
    ,PER_TILE_UNIT_INFO_MAC(GOP2_16P_MIF_1,  UNIT_MIF_7              )
    ,PER_TILE_UNIT_INFO_MAC(GOP2_4P_MIF   ,  UNIT_MIF_8              )
    ,PER_TILE_UNIT_INFO_MAC(GOP3_16P_MIF_0,  UNIT_MIF_9              )
    ,PER_TILE_UNIT_INFO_MAC(GOP3_16P_MIF_1, UNIT_MIF_10             )
    ,PER_TILE_UNIT_INFO_MAC(GOP3_4P_MIF   , UNIT_MIF_11             )
    ,PER_TILE_UNIT_INFO_MAC(GOP1_CPU_MIF  , UNIT_MIF_12             )
    ,PER_TILE_UNIT_INFO_MAC(GOP2_80P_MIF_0, UNIT_MIF_13             )
    ,PER_TILE_UNIT_INFO_MAC(GOP2_80P_MIF_1, UNIT_MIF_14             )
    ,PER_TILE_UNIT_INFO_MAC(GOP2_80P_MIF_2, UNIT_MIF_15             )
    ,PER_TILE_UNIT_INFO_MAC(GOP2_80P_MIF_3, UNIT_MIF_16             )

    /*ANP */
    ,PER_TILE_UNIT_INFO_MAC(GOP0_16P_ANP8_0,  UNIT_ANP_0              )
    ,PER_TILE_UNIT_INFO_MAC(GOP0_16P_ANP8_1,  UNIT_ANP_1              )
    ,PER_TILE_UNIT_INFO_MAC(GOP1_16P_ANP8_0,  UNIT_ANP_2              )
    ,PER_TILE_UNIT_INFO_MAC(GOP1_16P_ANP8_1,  UNIT_ANP_3              )
    ,PER_TILE_UNIT_INFO_MAC(GOP2_16P_ANP8_0,  UNIT_ANP_4              )
    ,PER_TILE_UNIT_INFO_MAC(GOP2_16P_ANP8_1,  UNIT_ANP_5              )
    ,PER_TILE_UNIT_INFO_MAC(GOP3_16P_ANP8_0,  UNIT_ANP_6              )
    ,PER_TILE_UNIT_INFO_MAC(GOP3_16P_ANP8_1,  UNIT_ANP_7              )
    ,PER_TILE_UNIT_INFO_MAC(GOP0_4P_ANP1_0 ,  UNIT_ANP_8              )
    ,PER_TILE_UNIT_INFO_MAC(GOP0_4P_ANP1_1 ,  UNIT_ANP_9              )
    ,PER_TILE_UNIT_INFO_MAC(GOP0_4P_ANP1_2 , UNIT_ANP_10             )
    ,PER_TILE_UNIT_INFO_MAC(GOP0_4P_ANP1_3 , UNIT_ANP_11             )
    ,PER_TILE_UNIT_INFO_MAC(GOP1_4P_ANP1_0 ,UNIT_ANP_12             )
    ,PER_TILE_UNIT_INFO_MAC(GOP1_4P_ANP1_1 ,UNIT_ANP_13             )
    ,PER_TILE_UNIT_INFO_MAC(GOP1_4P_ANP1_2 ,UNIT_ANP_14             )
    ,PER_TILE_UNIT_INFO_MAC(GOP1_4P_ANP1_3 ,UNIT_ANP_15             )
    ,PER_TILE_UNIT_INFO_MAC(GOP2_4P_ANP1_0 ,UNIT_ANP_16             )
    ,PER_TILE_UNIT_INFO_MAC(GOP2_4P_ANP1_1 ,UNIT_ANP_17             )
    ,PER_TILE_UNIT_INFO_MAC(GOP2_4P_ANP1_2 ,UNIT_ANP_18             )
    ,PER_TILE_UNIT_INFO_MAC(GOP2_4P_ANP1_3 ,UNIT_ANP_19             )
    ,PER_TILE_UNIT_INFO_MAC(GOP3_4P_ANP1_0 ,UNIT_ANP_20             )
    ,PER_TILE_UNIT_INFO_MAC(GOP3_4P_ANP1_1 ,UNIT_ANP_21             )
    ,PER_TILE_UNIT_INFO_MAC(GOP3_4P_ANP1_2 ,UNIT_ANP_22             )
    ,PER_TILE_UNIT_INFO_MAC(GOP3_4P_ANP1_3 ,UNIT_ANP_23             )
    ,PER_TILE_UNIT_INFO_MAC(GOP1_CPU_ANP1  ,  UNIT_ANP_CPU          )

    ,PER_TILE_UNIT_INFO_MAC(GOP0_16P_SDW_112G_X4_0,   UNIT_SERDES_0_0         )
    ,PER_TILE_UNIT_INFO_MAC(GOP0_16P_SDW_112G_X4_1,   UNIT_SERDES_0_1         )
    ,PER_TILE_UNIT_INFO_MAC(GOP0_16P_SDW_56G_X4_0 ,   UNIT_SERDES_0_2         )
    ,PER_TILE_UNIT_INFO_MAC(GOP0_16P_SDW_56G_X4_1 ,   UNIT_SERDES_0_3         )
    ,PER_TILE_UNIT_INFO_MAC(GOP1_16P_SDW_112G_X4_0,   UNIT_SERDES_0_4         )
    ,PER_TILE_UNIT_INFO_MAC(GOP1_16P_SDW_112G_X4_1,   UNIT_SERDES_1_0         )
    ,PER_TILE_UNIT_INFO_MAC(GOP1_16P_SDW_56G_X4_0 ,   UNIT_SERDES_1_1         )
    ,PER_TILE_UNIT_INFO_MAC(GOP1_16P_SDW_56G_X4_1 ,   UNIT_SERDES_1_2         )
    ,PER_TILE_UNIT_INFO_MAC(GOP2_16P_SDW_112G_X4_0,   UNIT_SERDES_1_3         )
    ,PER_TILE_UNIT_INFO_MAC(GOP2_16P_SDW_112G_X4_1,   UNIT_SERDES_1_4         )
    ,PER_TILE_UNIT_INFO_MAC(GOP2_16P_SDW_56G_X4_0 ,  UNIT_SERDES_2_0         )
    ,PER_TILE_UNIT_INFO_MAC(GOP2_16P_SDW_56G_X4_1 ,  UNIT_SERDES_2_1         )
    ,PER_TILE_UNIT_INFO_MAC(GOP3_16P_SDW_112G_X4_0,  UNIT_SERDES_2_2         )
    ,PER_TILE_UNIT_INFO_MAC(GOP3_16P_SDW_112G_X4_1,  UNIT_SERDES_2_3         )
    ,PER_TILE_UNIT_INFO_MAC(GOP3_16P_SDW_56G_X4_0 ,  UNIT_SERDES_2_4         )
    ,PER_TILE_UNIT_INFO_MAC(GOP3_16P_SDW_56G_X4_1 ,  UNIT_SERDES_3_0         )
    ,PER_TILE_UNIT_INFO_MAC(GOP0_4P_SDW_56G_X4    ,  UNIT_SERDES_3_1         )
    ,PER_TILE_UNIT_INFO_MAC(GOP1_4P_SDW_56G_X4    ,  UNIT_SERDES_3_2         )
    ,PER_TILE_UNIT_INFO_MAC(GOP2_4P_SDW_56G_X4    ,  UNIT_SERDES_3_3         )
    ,PER_TILE_UNIT_INFO_MAC(GOP3_4P_SDW_56G_X4    ,  UNIT_SERDES_3_4         )
    ,PER_TILE_UNIT_INFO_MAC(GOP1_CPU_SDW_56G_X1   ,  UNIT_SERDES_CPU         )

    /* Flexe */
    ,PER_TILE_UNIT_INFO_MAC(GOP2_80P_XC_0      ,  UNIT_FLEXE_XC0         )
    ,PER_TILE_UNIT_INFO_MAC(GOP2_80P_XC_TAI_0  ,  UNIT_FLEXE_XC0_TAI     )
    ,PER_TILE_UNIT_INFO_MAC(GOP2_80P_XC_1      ,  UNIT_FLEXE_XC1         )
    ,PER_TILE_UNIT_INFO_MAC(GOP2_80P_XC_TAI_1  ,  UNIT_FLEXE_XC1_TAI     )
    ,PER_TILE_UNIT_INFO_MAC(GOP2_80P_CODERS    ,  UNIT_FLEXE_CODERS      )
    ,PER_TILE_UNIT_INFO_MAC(GOP2_80P_SHIM_0    ,  UNIT_FLEXE_SHIM0       )
    ,PER_TILE_UNIT_INFO_MAC(GOP2_80P_SHIM_TAI_0,  UNIT_FLEXE_SHIM0_TAI   )
    ,PER_TILE_UNIT_INFO_MAC(GOP2_80P_SHIM_1    ,  UNIT_FLEXE_SHIM1       )
    ,PER_TILE_UNIT_INFO_MAC(GOP2_80P_SHIM_TAI_1,  UNIT_FLEXE_SHIM1_TAI   )

    ,PER_TILE_UNIT_INFO_MAC(CNM_GDMA_Dispatcher  ,  UNIT_CNM_GDMA_DISPATCHER)
    ,PER_TILE_UNIT_INFO_MAC(CNM_GDMA_0           ,  UNIT_CNM_GDMA               )
    ,PER_TILE_UNIT_INFO_MAC(CNM_GDMA_1           ,  UNIT_CNM_GDMA_1             )
    ,PER_TILE_UNIT_INFO_MAC(CNM_GDMA_2           ,  UNIT_CNM_GDMA_2             )
    ,PER_TILE_UNIT_INFO_MAC(CNM_GDMA_3           ,  UNIT_CNM_GDMA_3             )
    ,PER_TILE_UNIT_INFO_MAC(CNM_CNM_Interrupt  ,  UNIT_CNM_INTERRUPTS  )
    ,PER_TILE_UNIT_INFO_MAC(CNM_XSMI_0         ,  UNIT_CNM_XSMI_0             )
    ,PER_TILE_UNIT_INFO_MAC(CNM_XSMI_1         ,  UNIT_CNM_XSMI_1             )
    ,PER_TILE_UNIT_INFO_MAC(CNM_XSMI_2         ,  UNIT_CNM_XSMI_2             )

    /* must be last */
    ,{SMAIN_NOT_VALID_CNS,NULL,SMAIN_NOT_VALID_CNS}
};

/* number of units in the device */
#define AAS_NUM_UNITS sizeof(aas_units)/sizeof(aas_units[0])

static SMEM_GEN_UNIT_INFO_STC SORTED___aas_units[AAS_NUM_UNITS] =
{
    /* sorted and build during smemAasInit(...) from aas_units[] */
    {SMAIN_NOT_VALID_CNS,NULL,SMAIN_NOT_VALID_CNS}
};


/* NOTE: all units that are duplicated from tile 0 to pipe tile1 are added into this array in runtime !!!
    it is built from aas_units[].orig_nameStr*/
static SMEM_UNIT_DUPLICATION_INFO_STC aas_duplicatedUnits[800/*extra places for the tile 1 units */] =
{
    /* those explicitly listed here need unit allocation as are not duplicated within each pipe */

    {STR(UNIT_CNC)  ,3}, /* 3 duplication of this unit */
        {STR(UNIT_CNC_1)},
        {STR(UNIT_CNC_2)},
        {STR(UNIT_CNC_3)},

    {STR(UNIT_PB_SMB_WRITE_ARBITER_0)  ,1}, /* 1 duplication of this unit */
        {STR(UNIT_PB_SMB_WRITE_ARBITER_1)},

    {STR(UNIT_PB_GPC_GRP_CELL_READ_0)  ,4}, /* 4 duplication of this unit */
        {STR(UNIT_PB_GPC_GRP_CELL_READ_1)},
        {STR(UNIT_PB_GPC_GRP_CELL_READ_2)},
        {STR(UNIT_PB_GPC_GRP_CELL_READ_3)},
        {STR(UNIT_PB_GPC_GRP_CELL_READ_4)},

    {STR(UNIT_PB_GPC_GRP_PACKET_WRITE_0)  ,4}, /* 4 duplication of this unit */
        {STR(UNIT_PB_GPC_GRP_PACKET_WRITE_1)},
        {STR(UNIT_PB_GPC_GRP_PACKET_WRITE_2)},
        {STR(UNIT_PB_GPC_GRP_PACKET_WRITE_3)},
        {STR(UNIT_PB_GPC_GRP_PACKET_WRITE_4)},

    {STR(UNIT_PB_GPC_GRP_PACKET_READ_0)  ,4}, /* 4 duplication of this unit */
        {STR(UNIT_PB_GPC_GRP_PACKET_READ_1)},
        {STR(UNIT_PB_GPC_GRP_PACKET_READ_2)},
        {STR(UNIT_PB_GPC_GRP_PACKET_READ_3)},
        {STR(UNIT_PB_GPC_GRP_PACKET_READ_4)},

    {STR(UNIT_PB_SHARED_MEMO_BUF_0_0)  ,2}, /* 2 duplication of this unit */
        {STR( UNIT_PB_SHARED_MEMO_BUF_0_1)},
        {STR( UNIT_PB_SHARED_MEMO_BUF_1_0)},

    {STR(UNIT_PB_NEXT_POINTER_MEMO_0)  ,1}, /* 1 duplication of this unit */
        {STR(UNIT_PB_NEXT_POINTER_MEMO_1)},

    {STR(UNIT_RX_DMA)  ,3}, /* 3 duplication of this unit */
        {STR(UNIT_RX_DMA_1)},
        {STR(UNIT_RX_DMA_2)},
        {STR(UNIT_RX_DMA_3)},

    {STR(UNIT_TX_FIFO) ,3}, /* 3 duplication of this unit */
        {STR(UNIT_TX_FIFO_1)},
        {STR(UNIT_TX_FIFO_2)},
        {STR(UNIT_TX_FIFO_3)},

    {STR(UNIT_TX_DMA)  ,3}, /* 3 duplication of this unit */
        {STR(UNIT_TX_DMA_1)},
        {STR(UNIT_TX_DMA_2)},
        {STR(UNIT_TX_DMA_3)},

    {STR(UNIT_TXQ_PDS0)  ,3}, /* 3 duplication of this unit */
        {STR(UNIT_TXQ_PDS1)},
        {STR(UNIT_TXQ_PDS2)},
        {STR(UNIT_TXQ_PDS3)},

    {STR(UNIT_TXQ_SDQ0)  ,3}, /* 3 duplication of this unit */
        {STR(UNIT_TXQ_SDQ1)},
        {STR(UNIT_TXQ_SDQ2)},
        {STR(UNIT_TXQ_SDQ3)},

    {STR(UNIT_TXQ_QFC0)  ,3}, /* 3 duplication of this unit */
        {STR(UNIT_TXQ_QFC1)},
        {STR(UNIT_TXQ_QFC2)},
        {STR(UNIT_TXQ_QFC3)},

    {STR(UNIT_PCA_LMU_0)  ,31},
        {STR(UNIT_PCA_LMU_01)},
        {STR(UNIT_PCA_LMU_02)},
        {STR(UNIT_PCA_LMU_03)},
        {STR(UNIT_PCA_LMU_04)},
        {STR(UNIT_PCA_LMU_05)},
        {STR(UNIT_PCA_LMU_06)},
        {STR(UNIT_PCA_LMU_07)},
        {STR(UNIT_PCA_LMU_1)},
        {STR(UNIT_PCA_LMU_11)},
        {STR(UNIT_PCA_LMU_12)},
        {STR(UNIT_PCA_LMU_13)},
        {STR(UNIT_PCA_LMU_14)},
        {STR(UNIT_PCA_LMU_15)},
        {STR(UNIT_PCA_LMU_16)},
        {STR(UNIT_PCA_LMU_17)},
        {STR(UNIT_PCA_LMU_2)},
        {STR(UNIT_PCA_LMU_21)},
        {STR(UNIT_PCA_LMU_22)},
        {STR(UNIT_PCA_LMU_23)},
        {STR(UNIT_PCA_LMU_24)},
        {STR(UNIT_PCA_LMU_25)},
        {STR(UNIT_PCA_LMU_26)},
        {STR(UNIT_PCA_LMU_27)},
        {STR(UNIT_PCA_LMU_3)},
        {STR(UNIT_PCA_LMU_31)},
        {STR(UNIT_PCA_LMU_32)},
        {STR(UNIT_PCA_LMU_33)},
        {STR(UNIT_PCA_LMU_34)},
        {STR(UNIT_PCA_LMU_35)},
        {STR(UNIT_PCA_LMU_36)},
        {STR(UNIT_PCA_LMU_37)},
/**/


    {STR(UNIT_PCA_CTSU_0)  ,3}, /* 3 duplication of this unit */
        {STR(UNIT_PCA_CTSU_1)},
        {STR(UNIT_PCA_CTSU_2)},
        {STR(UNIT_PCA_CTSU_3)},

    {STR(UNIT_PCA_MACSEC_EXT_I_163_0)  ,15},  /* 15 more per device */
        {STR(UNIT_PCA_MACSEC_EXT_E_163_0)},
        {STR(UNIT_PCA_MACSEC_EXT_I_164_0)},
        {STR(UNIT_PCA_MACSEC_EXT_E_164_0)},
        {STR(UNIT_PCA_MACSEC_EXT_I_163_1)},
        {STR(UNIT_PCA_MACSEC_EXT_E_163_1)},
        {STR(UNIT_PCA_MACSEC_EXT_I_164_1)},
        {STR(UNIT_PCA_MACSEC_EXT_E_164_1)},
        {STR(UNIT_PCA_MACSEC_EXT_I_163_2)},
        {STR(UNIT_PCA_MACSEC_EXT_E_163_2)},
        {STR(UNIT_PCA_MACSEC_EXT_I_164_2)},
        {STR(UNIT_PCA_MACSEC_EXT_E_164_2)},
        {STR(UNIT_PCA_MACSEC_EXT_I_163_3)},
        {STR(UNIT_PCA_MACSEC_EXT_E_163_3)},
        {STR(UNIT_PCA_MACSEC_EXT_I_164_3)},
        {STR(UNIT_PCA_MACSEC_EXT_E_164_3)},

        {STR(UNIT_PCA_PZ_ARBITER_0), 3}, /* 3 more per device */
        {STR(UNIT_PCA_PZ_ARBITER_1)},
        {STR(UNIT_PCA_PZ_ARBITER_2)},
        {STR(UNIT_PCA_PZ_ARBITER_3)},

        {STR(UNIT_PCA_SFF_0), 3}, /* 3 more per device */
        {STR(UNIT_PCA_SFF_1)},
        {STR(UNIT_PCA_SFF_2)},
        {STR(UNIT_PCA_SFF_3)},

        {STR(UNIT_PCA_BRG_SHM_RX_0), 3}, /* 3 more per device */
        {STR(UNIT_PCA_BRG_SHM_RX_1)},
        {STR(UNIT_PCA_BRG_SHM_RX_2)},
        {STR(UNIT_PCA_BRG_SHM_RX_3)},

        {STR(UNIT_PCA_BRG_SHM_TX_0), 3}, /* 3 more per device */
        {STR(UNIT_PCA_BRG_SHM_TX_1)},
        {STR(UNIT_PCA_BRG_SHM_TX_2)},
        {STR(UNIT_PCA_BRG_SHM_TX_3)},

        {STR(UNIT_PCA_BRG_UNPACK_TX_0), 3}, /* 3 more per device */
        {STR(UNIT_PCA_BRG_UNPACK_TX_1)},
        {STR(UNIT_PCA_BRG_UNPACK_TX_2)},
        {STR(UNIT_PCA_BRG_UNPACK_TX_3)},

        {STR(UNIT_PCA_BRG_PACK_RX_0), 3}, /* 3 more per device */
        {STR(UNIT_PCA_BRG_PACK_RX_1)},
        {STR(UNIT_PCA_BRG_PACK_RX_2)},
        {STR(UNIT_PCA_BRG_PACK_RX_3)},

        {STR(UNIT_PCA_BRG_EDGE_RX_0), 3}, /* 3 more per device */
        {STR(UNIT_PCA_BRG_EDGE_RX_1)},
        {STR(UNIT_PCA_BRG_EDGE_RX_2)},
        {STR(UNIT_PCA_BRG_EDGE_RX_3)},

        {STR(UNIT_PCA_BRG_EDGE_TX_0), 3}, /* 3 more per device */
        {STR(UNIT_PCA_BRG_EDGE_TX_1)},
        {STR(UNIT_PCA_BRG_EDGE_TX_2)},
        {STR(UNIT_PCA_BRG_EDGE_TX_3)},


    {STR(UNIT_MIF_0)  ,16},  /* 16 more per device */
        {STR(UNIT_MIF_1)},
        {STR(UNIT_MIF_2)},
        {STR(UNIT_MIF_3)},
        {STR(UNIT_MIF_4)},
        {STR(UNIT_MIF_5)},
        {STR(UNIT_MIF_6)},
        {STR(UNIT_MIF_7)},
        {STR(UNIT_MIF_8)},
        {STR(UNIT_MIF_9)},
        {STR(UNIT_MIF_10)},
        {STR(UNIT_MIF_11)},
        {STR(UNIT_MIF_12)},
        {STR(UNIT_MIF_13)},
        {STR(UNIT_MIF_14)},
        {STR(UNIT_MIF_15)},
        {STR(UNIT_MIF_16)},

    {STR(UNIT_ANP_0)  ,24},  /* 24 more per device */
        {STR(UNIT_ANP_1)},
        {STR(UNIT_ANP_2)},
        {STR(UNIT_ANP_3)},
        {STR(UNIT_ANP_4)},
        {STR(UNIT_ANP_5)},
        {STR(UNIT_ANP_6)},
        {STR(UNIT_ANP_7)},
        {STR(UNIT_ANP_8)},
        {STR(UNIT_ANP_9)},
        {STR(UNIT_ANP_10)},
        {STR(UNIT_ANP_11)},
        {STR(UNIT_ANP_12)},
        {STR(UNIT_ANP_13)},
        {STR(UNIT_ANP_14)},
        {STR(UNIT_ANP_15)},
        {STR(UNIT_ANP_16)},
        {STR(UNIT_ANP_17)},
        {STR(UNIT_ANP_18)},
        {STR(UNIT_ANP_19)},
        {STR(UNIT_ANP_20)},
        {STR(UNIT_ANP_21)},
        {STR(UNIT_ANP_22)},
        {STR(UNIT_ANP_23)},
        {STR(UNIT_ANP_CPU)},

    {STR(UNIT_SERDES_0_0)  ,20},  /* 20 more per device */
        {STR(UNIT_SERDES_0_1)},
        {STR(UNIT_SERDES_0_2)},
        {STR(UNIT_SERDES_0_3)},
        {STR(UNIT_SERDES_0_4)},
        {STR(UNIT_SERDES_1_0)},
        {STR(UNIT_SERDES_1_1)},
        {STR(UNIT_SERDES_1_2)},
        {STR(UNIT_SERDES_1_3)},
        {STR(UNIT_SERDES_1_4)},
        {STR(UNIT_SERDES_2_0)},
        {STR(UNIT_SERDES_2_1)},
        {STR(UNIT_SERDES_2_2)},
        {STR(UNIT_SERDES_2_3)},
        {STR(UNIT_SERDES_2_4)},
        {STR(UNIT_SERDES_3_0)},
        {STR(UNIT_SERDES_3_1)},
        {STR(UNIT_SERDES_3_2)},
        {STR(UNIT_SERDES_3_3)},
        {STR(UNIT_SERDES_3_4)},
        {STR(UNIT_SERDES_CPU)},

    {STR(UNIT_TAI)  ,2},  /* 2 more per device */
        {STR(UNIT_TAI_1)},
        {STR(UNIT_TAI_2)},

    {STR(UNIT_LED_0)  ,3},  /* 3 more per device */
        {STR(UNIT_LED_1)},
        {STR(UNIT_LED_2)},
        {STR(UNIT_LED_3)},

    {STR(UNIT_MAC_400G_0)  ,7},  /* 7 more per device */
        {STR(UNIT_MAC_400G_1)},
        {STR(UNIT_MAC_400G_2)},
        {STR(UNIT_MAC_400G_3)},
        {STR(UNIT_MAC_400G_4)},
        {STR(UNIT_MAC_400G_5)},
        {STR(UNIT_MAC_400G_6)},
        {STR(UNIT_MAC_400G_7)},

    {STR(UNIT_PCS_400G_0)  ,3},  /* 3 more per device */
        {STR(UNIT_PCS_400G_1)},
        {STR(UNIT_PCS_400G_2)},
        {STR(UNIT_PCS_400G_3)},

    {STR(UNIT_CNM_GDMA)  ,3},  /* 3 more per device */
        {STR(UNIT_CNM_GDMA_1)},
        {STR(UNIT_CNM_GDMA_2)},
        {STR(UNIT_CNM_GDMA_3)},

    {STR(UNIT_EM)  ,7},  /* 7 more per device */
        {STR(UNIT_EM1)},
        {STR(UNIT_EM2)},
        {STR(UNIT_EM3)},
        {STR(UNIT_EM4)},
        {STR(UNIT_EM5)},
        {STR(UNIT_EM6)},
        {STR(UNIT_EM7)},

    {STR(UNIT_ADDR_CNM_Address_Decoder_iNIC)  , 10}, /* 10 more per device */
        {STR(UNIT_ADDR_CNM_Address_Decoder_PCIe      )},
        {STR(UNIT_ADDR_CNM_Address_Decoder_iunit     )},
        {STR(UNIT_ADDR_CNM_Address_Decoder_GDMA0     )},
        {STR(UNIT_ADDR_CNM_Address_Decoder_GDMA1     )},
        {STR(UNIT_ADDR_CNM_Address_Decoder_GDMA2     )},
        {STR(UNIT_ADDR_CNM_Address_Decoder_GDMA3     )},
        {STR(UNIT_ADDR_CNM_Address_Decoder_EHSM_DMA  )},
        {STR(UNIT_ADDR_CNM_Address_Decoder_AAC_0     )},
        {STR(UNIT_ADDR_CNM_Address_Decoder_AAC_1     )},
        {STR(UNIT_ADDR_CNM_Address_Decoder_AMB       )},

    {STR(UNIT_CNM_XSMI_0)  ,2},  /* 2 more per device */
        {STR(UNIT_CNM_XSMI_1)},
        {STR(UNIT_CNM_XSMI_2)},

    {NULL,0} /* must be last */
};

#define CPU_SDMA    81
#define LOOPBACK_LOCAL_CHANNEL      20
#define CPU_NETWORK_LOCAL_CHANNEL   21
#define CPU_SDMA_LOCAL_CHANNEL      22

#define CPU_NETWORK_GLOBAL_MAC_NUM  145

/* DMA : special ports mapping {global,local,DP}    */
static SPECIAL_PORT_MAPPING_CNS aas_DMA_specialPortMappingArr[] = {
/*{--globalPortNumber:IN----------   --localPortNumber:OUT-------------------  --unitIndex:OUT} */
/*80*/ {CPU_SDMA-1/*global DMA port*/,CPU_NETWORK_LOCAL_CHANNEL/*local DMA port*/,0/*DP[0]*/} /*CPU network port*/
/*81*/,{CPU_SDMA  /*global DMA port*/,CPU_SDMA_LOCAL_CHANNEL  /*local DMA port*/,0/*DP[0]*/} /*CPU GDMA 0*/
/*82*/,{CPU_SDMA+1/*global DMA port*/,CPU_SDMA_LOCAL_CHANNEL  /*local DMA port*/,1/*DP[1]*/} /*CPU GDMA 1*/
/*83*/,{CPU_SDMA+2/*global DMA port*/,CPU_SDMA_LOCAL_CHANNEL  /*local DMA port*/,2/*DP[2]*/} /*CPU GDMA 2*/

/*84*/,{CPU_SDMA+3/*global DMA port*/,LOOPBACK_LOCAL_CHANNEL  /*local DMA port*/,0/*DP[0]*/}
/*85*/,{CPU_SDMA+4/*global DMA port*/,LOOPBACK_LOCAL_CHANNEL  /*local DMA port*/,1/*DP[1]*/}
/*86*/,{CPU_SDMA+5/*global DMA port*/,LOOPBACK_LOCAL_CHANNEL  /*local DMA port*/,2/*DP[2]*/}
/*87*/,{CPU_SDMA+6/*global DMA port*/,LOOPBACK_LOCAL_CHANNEL  /*local DMA port*/,3/*DP[3]*/}

      ,{SMAIN_NOT_VALID_CNS, SMAIN_NOT_VALID_CNS, SMAIN_NOT_VALID_CNS}  /* must be last */
};


/* DMA for MG units only (CPU-SDMA) : special ports mapping {global,local,DP}    */
static SPECIAL_PORT_MAPPING_CNS aas_cpuPortSdma_specialPortMappingArr[] = {
    /* --globalPortNumber;IN  --localPortNumber;OUT       --unitIndex;OUT */
/*81*/{CPU_SDMA  /*global DMA port*/,CPU_SDMA_LOCAL_CHANNEL  /*local DMA port*/,0/*DP[0]*/}
/*82*/,{CPU_SDMA+1/*global DMA port*/,CPU_SDMA_LOCAL_CHANNEL  /*local DMA port*/,1/*DP[1]*/}
/*83*/,{CPU_SDMA+2/*global DMA port*/,CPU_SDMA_LOCAL_CHANNEL  /*local DMA port*/,2/*DP[2]*/}

    ,{SMAIN_NOT_VALID_CNS,SMAIN_NOT_VALID_CNS,SMAIN_NOT_VALID_CNS}  /* must be last */
};

/* GOP : special ports mapping {global,local,pipe}*/
static SPECIAL_PORT_MAPPING_CNS aas_GOP_specialPortMappingArr[] = {
    /* --globalPortNumber;IN  --localPortNumber;OUT       --unitIndex;OUT */
/*80*/ {CPU_SDMA-1/*global GOP port*/,CPU_SDMA-1/*local GOP port*/,0/*pipe*/}

    ,{SMAIN_NOT_VALID_CNS,SMAIN_NOT_VALID_CNS,SMAIN_NOT_VALID_CNS}  /* must be last */
};

#define CPU_SDMA_2_TILES    161
/* DMA : special ports mapping {global,local,DP}    */
static SPECIAL_PORT_MAPPING_CNS aas_2_tiles_DMA_specialPortMappingArr[] = {
    /* --globalPortNumber;IN  --localPortNumber;OUT       --unitIndex;OUT */
/*160*/ {CPU_SDMA_2_TILES-1/*global DMA port*/,20  /*local DMA port*/,0/*DP[0]*/}
/*161*/,{CPU_SDMA_2_TILES  /*global DMA port*/,CPU_SDMA_LOCAL_CHANNEL  /*local DMA port*/,0/*DP[0]*/}

    ,{SMAIN_NOT_VALID_CNS,SMAIN_NOT_VALID_CNS,SMAIN_NOT_VALID_CNS}  /* must be last */
};


/* DMA for MG units only (CPU-SDMA) : special ports mapping {global,local,DP}    */
static SPECIAL_PORT_MAPPING_CNS aas_2_tiles_cpuPortSdma_specialPortMappingArr[] = {
    /* --globalPortNumber;IN  --localPortNumber;OUT       --unitIndex;OUT */
/*161*/{CPU_SDMA_2_TILES  /*global DMA port*/,CPU_SDMA_LOCAL_CHANNEL  /*local DMA port*/,0/*DP[0]*/}

    ,{SMAIN_NOT_VALID_CNS,SMAIN_NOT_VALID_CNS,SMAIN_NOT_VALID_CNS}  /* must be last */
};

/* GOP : special ports mapping {global,local,pipe}*/
static SPECIAL_PORT_MAPPING_CNS aas_2_tiles_GOP_specialPortMappingArr[] = {
    /* --globalPortNumber;IN  --localPortNumber;OUT       --unitIndex;OUT */
/*160*/ {CPU_SDMA_2_TILES-1/*global GOP port*/,CPU_SDMA-1/*local GOP port*/,0/*pipe*/}

    ,{SMAIN_NOT_VALID_CNS,SMAIN_NOT_VALID_CNS,SMAIN_NOT_VALID_CNS}  /* must be last */
};

/**
* @internal smemAasGetMgUnitIndexFromAddress function
* @endinternal
*
* @brief   Get MG unit index from the regAddr
*
* @param[in] devObjPtr                - pointer to device object.
* @param[in] regAddress               - register address
*
* @retval the mg unit Index.
*         if the register is not MG register , it returns SMAIN_NOT_VALID_CNS
*/
static GT_U32  smemAasGetMgUnitIndexFromAddress(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN GT_U32                  regAddress
)
{
    skernelFatalError("smemAasGetMgUnitIndexFromAddress : no MG unit in sip7 addr[0x8.8%x]\n",
        regAddress);
    return SMAIN_NOT_VALID_CNS;
}


#undef MIF_N
#define MIF_N(_dp)   ((_dp/4)*(17-12)/*per tile*/) + (3*_dp)

#define  AAS_MIF_DP_20_PORTS(_dpIndex)/**/          \
      /*global*/           /*mac*/             /* channelInfo */ \
                                                                 /*sip6_MTI_EXTERNAL_representativePortIndex*/ \
                                                                                      /*serdes info*/ \
                                                                                                          /*globalSerdesNum*/ \
                                                                                                                            /*mifInfo*/  \
     {{0  + _dpIndex*20 , {0+_dpIndex*3, 0} ,  {0+_dpIndex*1,0}   ,0+_dpIndex*3 },    {0+_dpIndex*5,0} ,  0 + _dpIndex*20 ,{0+MIF_N(_dpIndex), 0}}\
    ,{{1  + _dpIndex*20 , {0+_dpIndex*3, 1} ,  {0+_dpIndex*1,1}   ,0+_dpIndex*3 },    {0+_dpIndex*5,1} ,  1 + _dpIndex*20 ,{0+MIF_N(_dpIndex), 1}}\
    ,{{2  + _dpIndex*20 , {0+_dpIndex*3, 2} ,  {0+_dpIndex*1,2}   ,0+_dpIndex*3 },    {0+_dpIndex*5,2} ,  2 + _dpIndex*20 ,{0+MIF_N(_dpIndex), 2}}\
    ,{{3  + _dpIndex*20 , {0+_dpIndex*3, 3} ,  {0+_dpIndex*1,3}   ,0+_dpIndex*3 },    {0+_dpIndex*5,3} ,  3 + _dpIndex*20 ,{0+MIF_N(_dpIndex), 3}}\
    ,{{4  + _dpIndex*20 , {0+_dpIndex*3, 4} ,  {0+_dpIndex*1,4}   ,0+_dpIndex*3 },    {1+_dpIndex*5,0} ,  4 + _dpIndex*20 ,{0+MIF_N(_dpIndex), 4}}\
    ,{{5  + _dpIndex*20 , {0+_dpIndex*3, 5} ,  {0+_dpIndex*1,5}   ,0+_dpIndex*3 },    {1+_dpIndex*5,1} ,  5 + _dpIndex*20 ,{0+MIF_N(_dpIndex), 5}}\
    ,{{6  + _dpIndex*20 , {0+_dpIndex*3, 6} ,  {0+_dpIndex*1,6}   ,0+_dpIndex*3 },    {1+_dpIndex*5,2} ,  6 + _dpIndex*20 ,{0+MIF_N(_dpIndex), 6}}\
    ,{{7  + _dpIndex*20 , {0+_dpIndex*3, 7} ,  {0+_dpIndex*1,7}   ,0+_dpIndex*3 },    {1+_dpIndex*5,3} ,  7 + _dpIndex*20 ,{0+MIF_N(_dpIndex), 7}}\
                                                                                                                                                  \
    ,{{8  + _dpIndex*20 , {1+_dpIndex*3, 0} ,  {0+_dpIndex*1,8 }  ,1+_dpIndex*3 },    {2+_dpIndex*5,0} ,  8 + _dpIndex*20 ,{1+MIF_N(_dpIndex), 0}}\
    ,{{9  + _dpIndex*20 , {1+_dpIndex*3, 1} ,  {0+_dpIndex*1,9 }  ,1+_dpIndex*3 },    {2+_dpIndex*5,1} ,  9 + _dpIndex*20 ,{1+MIF_N(_dpIndex), 1}}\
    ,{{10 + _dpIndex*20 , {1+_dpIndex*3, 2} ,  {0+_dpIndex*1,10}  ,1+_dpIndex*3 },    {2+_dpIndex*5,2} , 10 + _dpIndex*20 ,{1+MIF_N(_dpIndex), 2}}\
    ,{{11 + _dpIndex*20 , {1+_dpIndex*3, 3} ,  {0+_dpIndex*1,11}  ,1+_dpIndex*3 },    {2+_dpIndex*5,3} , 11 + _dpIndex*20 ,{1+MIF_N(_dpIndex), 3}}\
    ,{{12 + _dpIndex*20 , {1+_dpIndex*3, 4} ,  {0+_dpIndex*1,12}  ,1+_dpIndex*3 },    {3+_dpIndex*5,0} , 12 + _dpIndex*20 ,{1+MIF_N(_dpIndex), 4}}\
    ,{{13 + _dpIndex*20 , {1+_dpIndex*3, 5} ,  {0+_dpIndex*1,13}  ,1+_dpIndex*3 },    {3+_dpIndex*5,1} , 13 + _dpIndex*20 ,{1+MIF_N(_dpIndex), 5}}\
    ,{{14 + _dpIndex*20 , {1+_dpIndex*3, 6} ,  {0+_dpIndex*1,14}  ,1+_dpIndex*3 },    {3+_dpIndex*5,2} , 14 + _dpIndex*20 ,{1+MIF_N(_dpIndex), 6}}\
    ,{{15 + _dpIndex*20 , {1+_dpIndex*3, 7} ,  {0+_dpIndex*1,15}  ,1+_dpIndex*3 },    {3+_dpIndex*5,3} , 15 + _dpIndex*20 ,{1+MIF_N(_dpIndex), 7}}\
                                                                                                                                                  \
    ,{{16 + _dpIndex*20 , {2+_dpIndex*3, 0} ,  {0+_dpIndex*1,16 } ,2+_dpIndex*3 },    {4+_dpIndex*5,0 }, 16 + _dpIndex*20 ,{2+MIF_N(_dpIndex), 0}}\
    ,{{17 + _dpIndex*20 , {2+_dpIndex*3, 1} ,  {0+_dpIndex*1,17 } ,2+_dpIndex*3 },    {4+_dpIndex*5,1 }, 17 + _dpIndex*20 ,{2+MIF_N(_dpIndex), 1}}\
    ,{{18 + _dpIndex*20 , {2+_dpIndex*3, 2} ,  {0+_dpIndex*1,18 } ,2+_dpIndex*3 },    {4+_dpIndex*5,2 }, 18 + _dpIndex*20 ,{2+MIF_N(_dpIndex), 2}}\
    ,{{19 + _dpIndex*20 , {2+_dpIndex*3, 3} ,  {0+_dpIndex*1,19 } ,2+_dpIndex*3 },    {4+_dpIndex*5,3 }, 19 + _dpIndex*20 ,{2+MIF_N(_dpIndex), 3}}

#define  AAS_DP_20_PORTS(_dpIndex)/**/          \
      /*global*/           /*mac*/             /* channelInfo */ \
                                                                 /*sip6_MTI_EXTERNAL_representativePortIndex*/ \
                                                                                      /*serdes info*/ \
                                                                                                          /*globalSerdesNum*/ \
                                                                                                                            /*mifInfo*/  \
     {{0  + _dpIndex*20 , {0+_dpIndex*2, 0} ,  {0+_dpIndex*1,0}   ,0+_dpIndex*2 },    {0+_dpIndex*5,0} ,  0 + _dpIndex*20 ,{0+MIF_N(_dpIndex), 0}}\
    ,{{1  + _dpIndex*20 , {0+_dpIndex*2, 1} ,  {0+_dpIndex*1,1}   ,0+_dpIndex*2 },    {0+_dpIndex*5,1} ,  1 + _dpIndex*20 ,{0+MIF_N(_dpIndex), 1}}\
    ,{{2  + _dpIndex*20 , {0+_dpIndex*2, 2} ,  {0+_dpIndex*1,2}   ,0+_dpIndex*2 },    {0+_dpIndex*5,2} ,  2 + _dpIndex*20 ,{0+MIF_N(_dpIndex), 2}}\
    ,{{3  + _dpIndex*20 , {0+_dpIndex*2, 3} ,  {0+_dpIndex*1,3}   ,0+_dpIndex*2 },    {0+_dpIndex*5,3} ,  3 + _dpIndex*20 ,{0+MIF_N(_dpIndex), 3}}\
    ,{{4  + _dpIndex*20 , {0+_dpIndex*2, 4} ,  {0+_dpIndex*1,4}   ,0+_dpIndex*2 },    {1+_dpIndex*5,0} ,  4 + _dpIndex*20 ,{0+MIF_N(_dpIndex), 4}}\
    ,{{5  + _dpIndex*20 , {0+_dpIndex*2, 5} ,  {0+_dpIndex*1,5}   ,0+_dpIndex*2 },    {1+_dpIndex*5,1} ,  5 + _dpIndex*20 ,{0+MIF_N(_dpIndex), 5}}\
    ,{{6  + _dpIndex*20 , {0+_dpIndex*2, 6} ,  {0+_dpIndex*1,6}   ,0+_dpIndex*2 },    {1+_dpIndex*5,2} ,  6 + _dpIndex*20 ,{0+MIF_N(_dpIndex), 6}}\
    ,{{7  + _dpIndex*20 , {0+_dpIndex*2, 7} ,  {0+_dpIndex*1,7}   ,0+_dpIndex*2 },    {1+_dpIndex*5,3} ,  7 + _dpIndex*20 ,{0+MIF_N(_dpIndex), 7}}\
                                                                                                                                                  \
    ,{{8  + _dpIndex*20 , {1+_dpIndex*2, 0} ,  {0+_dpIndex*1,8 }  ,1+_dpIndex*2 },    {2+_dpIndex*5,0} ,  8 + _dpIndex*20 ,{1+MIF_N(_dpIndex), 0}}\
    ,{{9  + _dpIndex*20 , {1+_dpIndex*2, 1} ,  {0+_dpIndex*1,9 }  ,1+_dpIndex*2 },    {2+_dpIndex*5,1} ,  9 + _dpIndex*20 ,{1+MIF_N(_dpIndex), 1}}\
    ,{{10 + _dpIndex*20 , {1+_dpIndex*2, 2} ,  {0+_dpIndex*1,10}  ,1+_dpIndex*2 },    {2+_dpIndex*5,2} , 10 + _dpIndex*20 ,{1+MIF_N(_dpIndex), 2}}\
    ,{{11 + _dpIndex*20 , {1+_dpIndex*2, 3} ,  {0+_dpIndex*1,11}  ,1+_dpIndex*2 },    {2+_dpIndex*5,3} , 11 + _dpIndex*20 ,{1+MIF_N(_dpIndex), 3}}\
    ,{{12 + _dpIndex*20 , {1+_dpIndex*2, 4} ,  {0+_dpIndex*1,12}  ,1+_dpIndex*2 },    {3+_dpIndex*5,0} , 12 + _dpIndex*20 ,{1+MIF_N(_dpIndex), 4}}\
    ,{{13 + _dpIndex*20 , {1+_dpIndex*2, 5} ,  {0+_dpIndex*1,13}  ,1+_dpIndex*2 },    {3+_dpIndex*5,1} , 13 + _dpIndex*20 ,{1+MIF_N(_dpIndex), 5}}\
    ,{{14 + _dpIndex*20 , {1+_dpIndex*2, 6} ,  {0+_dpIndex*1,14}  ,1+_dpIndex*2 },    {3+_dpIndex*5,2} , 14 + _dpIndex*20 ,{1+MIF_N(_dpIndex), 6}}\
    ,{{15 + _dpIndex*20 , {1+_dpIndex*2, 7} ,  {0+_dpIndex*1,15}  ,1+_dpIndex*2 },    {3+_dpIndex*5,3} , 15 + _dpIndex*20 ,{1+MIF_N(_dpIndex), 7}}

#define  AAS_PCS_PORTS(_pcsIndex)/**/          \
      /*global*/           /*mac*/             /* channelInfo */ \
                                                                 /*sip6_MTI_EXTERNAL_representativePortIndex*/ \
                                                                                      /*serdes info*/ \
                                                                                                          /*globalSerdesNum*/ \
                                                                                                                            /*mifInfo*/  \
     {{0  + _pcsIndex*20 , {_pcsIndex, 0} ,  {_pcsIndex,0}   ,0+_pcsIndex*1 },    {0+_pcsIndex*5,0} ,  0 + _pcsIndex*20 ,{0+MIF_N(_pcsIndex), 0}}\
    ,{{1  + _pcsIndex*20 , {_pcsIndex, 1} ,  {_pcsIndex,1}   ,0+_pcsIndex*1 },    {0+_pcsIndex*5,1} ,  1 + _pcsIndex*20 ,{0+MIF_N(_pcsIndex), 1}}\
    ,{{2  + _pcsIndex*20 , {_pcsIndex, 2} ,  {_pcsIndex,2}   ,0+_pcsIndex*1 },    {0+_pcsIndex*5,2} ,  2 + _pcsIndex*20 ,{0+MIF_N(_pcsIndex), 2}}\
    ,{{3  + _pcsIndex*20 , {_pcsIndex, 3} ,  {_pcsIndex,3}   ,0+_pcsIndex*1 },    {0+_pcsIndex*5,3} ,  3 + _pcsIndex*20 ,{0+MIF_N(_pcsIndex), 3}}\
    ,{{4  + _pcsIndex*20 , {_pcsIndex, 4} ,  {_pcsIndex,4}   ,0+_pcsIndex*1 },    {1+_pcsIndex*5,0} ,  4 + _pcsIndex*20 ,{0+MIF_N(_pcsIndex), 4}}\
    ,{{5  + _pcsIndex*20 , {_pcsIndex, 5} ,  {_pcsIndex,5}   ,0+_pcsIndex*1 },    {1+_pcsIndex*5,1} ,  5 + _pcsIndex*20 ,{0+MIF_N(_pcsIndex), 5}}\
    ,{{6  + _pcsIndex*20 , {_pcsIndex, 6} ,  {_pcsIndex,6}   ,0+_pcsIndex*1 },    {1+_pcsIndex*5,2} ,  6 + _pcsIndex*20 ,{0+MIF_N(_pcsIndex), 6}}\
    ,{{7  + _pcsIndex*20 , {_pcsIndex, 7} ,  {_pcsIndex,7}   ,0+_pcsIndex*1 },    {1+_pcsIndex*5,3} ,  7 + _pcsIndex*20 ,{0+MIF_N(_pcsIndex), 7}}\
                                                                                                                                                \
    ,{{8  + _pcsIndex*20 , {_pcsIndex, 8} ,   {_pcsIndex,8 }  ,0+_pcsIndex*1 },    {2+_pcsIndex*5,0} ,  8 + _pcsIndex*20 ,{1+MIF_N(_pcsIndex), 0}}\
    ,{{9  + _pcsIndex*20 , {_pcsIndex, 9} ,   {_pcsIndex,9 }  ,0+_pcsIndex*1 },    {2+_pcsIndex*5,1} ,  9 + _pcsIndex*20 ,{1+MIF_N(_pcsIndex), 1}}\
    ,{{10 + _pcsIndex*20 , {_pcsIndex, 10} ,  {_pcsIndex,10}  ,0+_pcsIndex*1 },    {2+_pcsIndex*5,2} , 10 + _pcsIndex*20 ,{1+MIF_N(_pcsIndex), 2}}\
    ,{{11 + _pcsIndex*20 , {_pcsIndex, 11} ,  {_pcsIndex,11}  ,0+_pcsIndex*1 },    {2+_pcsIndex*5,3} , 11 + _pcsIndex*20 ,{1+MIF_N(_pcsIndex), 3}}\
    ,{{12 + _pcsIndex*20 , {_pcsIndex, 12} ,  {_pcsIndex,12}  ,0+_pcsIndex*1 },    {3+_pcsIndex*5,0} , 12 + _pcsIndex*20 ,{1+MIF_N(_pcsIndex), 4}}\
    ,{{13 + _pcsIndex*20 , {_pcsIndex, 13} ,  {_pcsIndex,13}  ,0+_pcsIndex*1 },    {3+_pcsIndex*5,1} , 13 + _pcsIndex*20 ,{1+MIF_N(_pcsIndex), 5}}\
    ,{{14 + _pcsIndex*20 , {_pcsIndex, 14} ,  {_pcsIndex,14}  ,0+_pcsIndex*1 },    {3+_pcsIndex*5,2} , 14 + _pcsIndex*20 ,{1+MIF_N(_pcsIndex), 6}}\
    ,{{15 + _pcsIndex*20 , {_pcsIndex, 15} ,  {_pcsIndex,15}  ,0+_pcsIndex*1 },    {3+_pcsIndex*5,3} , 15 + _pcsIndex*20 ,{1+MIF_N(_pcsIndex), 7}}


static MAC_NUM_INFO_EXT_STC aas100GMifPortsArr[] = {
    /*global*/      /*mac*/   /* channelInfo */   /*sip6_MTI_EXTERNAL_representativePortIndex*/
                                                            /*serdes info*/     /*globalSerdesNum*/
     AAS_MIF_DP_20_PORTS(0)/* 0..15*/
    ,AAS_MIF_DP_20_PORTS(1)/*20..35*/
    ,AAS_MIF_DP_20_PORTS(2)/*40..55*/
    ,AAS_MIF_DP_20_PORTS(3)/*60..75*/

    ,{{SMAIN_NOT_VALID_CNS,{0,0},{0,0},0},{0,0},SMAIN_NOT_VALID_CNS,{0,0}}
};

/* info about the 50/100/200/400G MACs */
static MAC_NUM_INFO_EXT_STC aas100GMacPortsArr[] = {
    /*global*/      /*mac*/   /* channelInfo */   /*sip6_MTI_EXTERNAL_representativePortIndex*/
                                                            /*serdes info*/     /*globalSerdesNum*/
     AAS_DP_20_PORTS(0)/* 0..15*/
    ,AAS_DP_20_PORTS(1)/*20..35*/
    ,AAS_DP_20_PORTS(2)/*40..55*/
    ,AAS_DP_20_PORTS(3)/*60..75*/

    ,{{SMAIN_NOT_VALID_CNS,{0,0},{0,0},0},{0,0},SMAIN_NOT_VALID_CNS,{0,0}}
};

static MAC_NUM_INFO_EXT_STC aas100GPcsPortsArr[] = {
    /*global*/      /*mac*/   /* channelInfo */   /*sip6_MTI_EXTERNAL_representativePortIndex*/
                                                            /*serdes info*/     /*globalSerdesNum*/
     AAS_PCS_PORTS(0)/* 0..15*/
    ,AAS_PCS_PORTS(1)/*20..35*/
    ,AAS_PCS_PORTS(2)/*40..55*/
    ,AAS_PCS_PORTS(3)/*60..75*/

    ,{{SMAIN_NOT_VALID_CNS,{0,0},{0,0},0},{0,0},SMAIN_NOT_VALID_CNS,{0,0}}
};


/* info about the CPU MACs */
/* NOTE : the device hold actually single GOP port !!! that is connected to DP[0] in PIPE2 and connected to DP[1] in Aldrin3/Cygnus3 */
static MAC_NUM_INFO_EXT_STC aasCpuPortsArr[] = {
  /* {------global-------------   -mac-    ---------channelInfo--------  sip6_MTI_EXTERNAL_representativePortIndex} */
                                                                           /* serdes info  globalSerdesNum  mifInfo */
    {{CPU_NETWORK_GLOBAL_MAC_NUM, {1, 0},  {1, CPU_NETWORK_LOCAL_CHANNEL}, 0 },  {20,0},        80,         {12,0}}

    ,{{SMAIN_NOT_VALID_CNS,{0,0},{0,0},0},{0,0},SMAIN_NOT_VALID_CNS,{0,0}}
};

#define NUM_OF_ARRAY_TYPES  2 /*aas100GPortsArr,aasCpuPortsArr*/

/* info about the 50/100/200/400G MACs */
static MAC_NUM_INFO_EXT_STC aas_2_tiles_100GPortsArr[] = {
    /*global*/      /*mac*/   /* channelInfo */   /*sip6_MTI_EXTERNAL_representativePortIndex*/
                                                            /*serdes info*/     /*globalSerdesNum*/
    /*Tile 0*/
     AAS_DP_20_PORTS(0)/* 0..19*/
    ,AAS_DP_20_PORTS(1)/*20..39*/
    ,AAS_DP_20_PORTS(2)/*40..59*/
    ,AAS_DP_20_PORTS(3)/*60..79*/

    /*Tile 1*/
    ,AAS_DP_20_PORTS(4)/* 80..99 */
    ,AAS_DP_20_PORTS(5)/*100..119*/
    ,AAS_DP_20_PORTS(6)/*120..139*/
    ,AAS_DP_20_PORTS(7)/*140..159*/

    ,{{SMAIN_NOT_VALID_CNS,{0,0},{0,0},0},{0,0},SMAIN_NOT_VALID_CNS,{0,0}}
};

/* info about the CPU MACs */
/* NOTE : the device hold actually single GOP port !!! that is connected to DP[0] in PIPE2 and connected to DP[1] in Aldrin3/Cygnus3 */
static MAC_NUM_INFO_EXT_STC aas_2_tiles_CpuPortsArr[] = {
    /*global*/      /*mac*/   /* channelInfo */   /*sip6_MTI_EXTERNAL_representativePortIndex*/
                                                                    /*serdes info*/     /*globalSerdesNum*/  /*mifInfo */
    {{160,           {0, 0} ,         {0, 20}             , 0    },      {40,0},             160,                 {12,0}}

    ,{{SMAIN_NOT_VALID_CNS,{0,0},{0,0},0},{0,0},SMAIN_NOT_VALID_CNS,{0,0}}
};

#undef MIF_N
#undef AAS_DP_20_PORTS


/**
* @internal smemAasGopPortByAddrGet function
* @endinternal
*
* @brief   get global MAC port id according to associated address (in GOP unit).
*
* @param[in] devObjPtr                - pointer to device object.
* @param[in] address                  - the  in the  space of the port
*
* @note the port id
*
*/
static GT_U32 smemAasGopPortByAddrGet
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN GT_U32                   address
)
{
    GT_U32 unitIndex;
    GT_U32 ii;
    GT_U32 localPortInUnit = 0;
    GT_U32 unitBase;
    GT_U32 unitSize;
    GT_U32 startTxCounters;
    GT_U32 portDivider;
    GT_U32 isCpuPort = 0;
    MAC_NUM_INFO_EXT_STC *aas100GPortsPtr = devObjPtr->numOfTiles == 1 ? aas100GMacPortsArr : aas_2_tiles_100GPortsArr;
    MAC_NUM_INFO_EXT_STC *aas100GPcsPortsPtr = devObjPtr->numOfTiles == 1 ? aas100GPcsPortsArr : aas_2_tiles_100GPortsArr;
    MAC_NUM_INFO_EXT_STC *aasCpuPortsPtr  = devObjPtr->numOfTiles == 1 ? aasCpuPortsArr  : aas_2_tiles_CpuPortsArr;
    GT_U32  localAddrInTile = address % devObjPtr->tileOffset;
    GT_U32  globalAddrInDevice = address;
    GT_U32  tileId = address / devObjPtr->tileOffset;
    GT_BOOL isPcsArrShouldBeUsed = GT_FALSE;
    address = globalAddrInDevice;

    for (ii=0; ii< NUM_TSU_UNITS; ii++)
    {
        if (address >= devObjPtr->memUnitBaseAddrInfo.tsu[ii] &&
            address <  (devObjPtr->memUnitBaseAddrInfo.tsu[ii] + (512 *_1K)))
        {
            unitBase = devObjPtr->memUnitBaseAddrInfo.tsu[ii];
            if(address >= unitBase + 0x00004000 &&
               address < (unitBase + 0x00004200))
            {
                localPortInUnit = (address - (unitBase + 0x4000)) / 0x8;
            }
            else
            if(address >= unitBase + 0x00004800 &&
               address < (unitBase + 0x00004a00))
            {
                localPortInUnit = (address - (unitBase + 0x4800)) / 0x8;
            }
            else
            if(address >= unitBase + 0x00001400 &&
               address < (unitBase + 0x00001500))
            {
                localPortInUnit = (address - (unitBase + 0x1400)) / 0x4;
            }
            else
            {
                skernelFatalError("smemAasGopPortByAddrGet : unknown port for address [0x%8.8x] as 'TSU unit' (case 1)\n",address);
                return 0;
            }

            unitIndex = ii;

            for(ii = 0 ; aas100GPortsPtr[ii].genInfo.globalMacNum != SMAIN_NOT_VALID_CNS; ii++)
            {
                if(aas100GPortsPtr[ii].genInfo.channelInfo.unitIndex   == unitIndex &&
                   aas100GPortsPtr[ii].genInfo.channelInfo.indexInUnit == localPortInUnit)
                {
                    return aas100GPortsPtr[ii].genInfo.globalMacNum;
                }
            }
            return SMAIN_NOT_VALID_CNS;
        }
    }

    address = localAddrInTile;
    for(ii = 0; ii < SIM_MAX_ANP_UNITS; ii++)
    {
        if(address >=  devObjPtr->memUnitBaseAddrInfo.anp[ii] &&
           address <  (devObjPtr->memUnitBaseAddrInfo.anp[ii] + (64   *     _1K)) )
        {
            unitBase = devObjPtr->memUnitBaseAddrInfo.anp[ii] + ANP_OFFSET;
            if(address >= unitBase + 0x00000100 &&
               address < (unitBase + 0x00000104 + 8*0x2a4))
            {
                /* 0x00000094 : SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->sip_6_10_ANP[anpNum].ANP.Interrupt_Summary_Cause */
                /* 0x00000098 : SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->sip_6_10_ANP[anpNum].ANP.Interrupt_Summary_Mask */
                localPortInUnit = (address - (unitBase + 0x00000100)) / 0x2a4;
                break;
            }
        }
    }
    unitIndex = ii;

    if(ii < 3)
    {
        /* matched as address in MTI_ANP  */
        return (localPortInUnit*2)+(ii*16)+tileId*80;
    }
    else if(ii < SIM_MAX_ANP_UNITS)
    {
        skernelFatalError("smemAasGopPortByAddrGet : in ANP: unknown port for address [0x%8.8x] as 'Gop unit' \n",
            address);
    }
    else
    {
        /* match not found - continue */
    }
    /**********************/
    /* End of ANP section */
    /**********************/
    address = globalAddrInDevice;

    for(ii = 0 ; ii < NUM_MAC_UNITS*devObjPtr->numOfTiles; ii++)
    {
        if(address >=  devObjPtr->memUnitBaseAddrInfo.macWrap[ii] &&
           address <  (devObjPtr->memUnitBaseAddrInfo.macWrap[ii] + (64*_1K)) )
        {
            unitSize = MAC_MIB_UNIT_SIZE;
            startTxCounters = START_MIB_TX_PER_PORT;
            /* support the dual MIB counters per 'port' (EMAC,PMAC) */
            portDivider = 2;

            unitBase = devObjPtr->memUnitBaseAddrInfo.macMib[ii];

            if(address >= unitBase &&
               address < (unitBase + unitSize))
            {
                /* mib unit */
                /* calculate the local port in the unit */
                if(address >= (unitBase + START_MIB_RX_PER_PORT) &&
                   address <  (unitBase + startTxCounters))
                {
                    /* rx registers */
                    localPortInUnit = (address - unitBase) / (43 * 0x4);

                    /* support the dual MIB counters per 'port' (EMAC,PMAC) */
                    localPortInUnit /= portDivider;
                    break;
                }

                if(address >= (unitBase + startTxCounters))
                {
                    /* tx registers */
                    localPortInUnit = (address - unitBase) / (34 * 0x4);

                    /* support the dual MIB counters per 'port' (EMAC,PMAC) */
                    localPortInUnit /= portDivider;
                    break;
                }

                break;/* common to the unit */
            }

            /* MTI 400G mac */
            unitBase = devObjPtr->memUnitBaseAddrInfo.macWrap[ii] + MAC_400G_OFFSET;

            if(address >= unitBase &&
               address < (unitBase + (PORT0_100G_OFFSET-MAC_400G_OFFSET)))
            {
                /* 200G/400G port */
                localPortInUnit = 4 * ((address - unitBase) / MAC_STEP_PORT_OFFSET);
                break;
            }

            unitBase = devObjPtr->memUnitBaseAddrInfo.macWrap[ii] +  PORT0_100G_OFFSET;
            if(address >= unitBase &&
               address < (unitBase + (8*MAC_STEP_PORT_OFFSET)))
            {
                /* 100G/50G port */
                localPortInUnit = (address - unitBase) / MAC_STEP_PORT_OFFSET;
                break;
            }

            unitBase = devObjPtr->memUnitBaseAddrInfo.macWrap[ii] + MAC_EXT_BASE_OFFSET;

            if(address >= unitBase + 0x00000094 &&
               address < (unitBase + 0x00000098 + (8 * 0x18)))
            {
                /* 0x00000094 : SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->sip6_MTI[portNum].MTI_EXT_PORT.portInterruptCause */
                /* 0x00000098 : SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->sip6_MTI[portNum].MTI_EXT_PORT.portInterruptMask */
                localPortInUnit = (address - (unitBase + 0x00000094)) / 0x18;
                break;
            }

            if(address == (unitBase + 0x00000068) ||
               address == (unitBase + 0x0000006c) )
            {
                /* 0x00000068 : SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->sip6_MTI[portNum].MTI_EXT_PORT.segPortInterruptCause */
                /* 0x0000006c : SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->sip6_MTI[portNum].MTI_EXT_PORT.segPortInterruptMask */
                localPortInUnit = 0;
                break;
            }

            if(address == (unitBase + 0x00000068 + 0x14) ||
               address == (unitBase + 0x0000006c + 0x14) )
            {
                /* 0x00000068 : SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->sip6_MTI[portNum].MTI_EXT_PORT.segPortInterruptCause */
                /* 0x0000006c : SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->sip6_MTI[portNum].MTI_EXT_PORT.segPortInterruptMask */
                localPortInUnit = 4;
                break;
            }

            break; /* common to the unit */
        }

        if(address >=  devObjPtr->memUnitBaseAddrInfo.macPcs[ii] &&
           address <  (devObjPtr->memUnitBaseAddrInfo.macPcs[ii] + (128*_1K)) )
        {
            isPcsArrShouldBeUsed = GT_TRUE;

            unitBase = devObjPtr->memUnitBaseAddrInfo.macPcs[ii] + PCS_400G_OFFSET;
            if(address >= unitBase && address < (unitBase + (16*_1K)))
            {
                /*PCS400G/200G*/
                localPortInUnit =  ((address - unitBase) / PCS_STEP_PORT_OFFSET) * 4; /*0,4,8,12*/
                break;
            }

            unitBase = devObjPtr->memUnitBaseAddrInfo.macPcs[ii] + PCS_PORT0_100G_OFFSET;
            if(address >= unitBase &&
               address < (unitBase + (16*PCS_STEP_PORT_OFFSET)))
            {
                /* 100G/50G port */
                localPortInUnit = (address - unitBase) / PCS_STEP_PORT_OFFSET;
                break;
            }

            unitBase = devObjPtr->memUnitBaseAddrInfo.macPcs[ii] + PCS_LPCS_OFFSET;
            if(address >= unitBase &&
               address < (unitBase + (8*LPCS_STEP_PORT_OFFSET)))
            {
                /* LPCS port */
                localPortInUnit = (address - unitBase) / LPCS_STEP_PORT_OFFSET;
                break;
            }
            break;
        }

        if (ii==0) /* check for the CPU port */
        {
            if(address >=  devObjPtr->memUnitBaseAddrInfo.cpuMacWrap[ii] &&
               address <  (devObjPtr->memUnitBaseAddrInfo.cpuMacWrap[ii] + (64*_1K)) )
            {
                /* NOTE: (if matched) will always be matched on ii=0 and never on ii=1 */
                isCpuPort = 1;
                break;
            }

            if(address >=  devObjPtr->memUnitBaseAddrInfo.cpuMacPcs[ii] &&
               address <  (devObjPtr->memUnitBaseAddrInfo.cpuMacPcs[ii] + (64*_1K)) )
            {
                /* NOTE: (if matched) will always be matched on ii=0 and never on ii=1 */
                isCpuPort = 1;
                break;
            }
        }
    }

    unitIndex = ii;
    if(isCpuPort)
    {
        for(ii = 0 ; aasCpuPortsPtr[ii].genInfo.globalMacNum != SMAIN_NOT_VALID_CNS; ii++)
        {
            if(aasCpuPortsPtr[ii].genInfo.macInfo.unitIndex == unitIndex)
            {
                /* NOTE: will always be matched on ii=0 and never on ii=1 */
                return aasCpuPortsPtr[ii].genInfo.globalMacNum;
            }
        }

        skernelFatalError("smemAasGopPortByAddrGet : unknown cpu port for address [0x%8.8x] as 'Gop unit' \n",
            address);
        return 0;
    }


    if(ii == (NUM_MAC_UNITS*devObjPtr->numOfTiles))
    {
        skernelFatalError("smemAasGopPortByAddrGet : unknown address [0x%8.8x] as 'Gop unit' \n",
            address);
        return 0;
    }

    for(ii = 0 ; aas100GPortsPtr[ii].genInfo.globalMacNum != SMAIN_NOT_VALID_CNS; ii++)
    {
        if(isPcsArrShouldBeUsed == GT_TRUE)
        {
            if(aas100GPcsPortsPtr[ii].genInfo.macInfo.unitIndex   == unitIndex &&
               aas100GPcsPortsPtr[ii].genInfo.macInfo.indexInUnit == localPortInUnit)
            {
                return aas100GPcsPortsPtr[ii].genInfo.globalMacNum;
            }
        }
        else
        {
            if(aas100GPortsPtr[ii].genInfo.macInfo.unitIndex   == unitIndex &&
               aas100GPortsPtr[ii].genInfo.macInfo.indexInUnit == localPortInUnit)
            {
                return aas100GPortsPtr[ii].genInfo.globalMacNum;
            }
        }
    }

    skernelFatalError("smemAasGopPortByAddrGet : unknown port for address [0x%8.8x] as 'Gop unit' \n",
        address);
    return 0;
}


/* MIF unit+channe to Global Mac port table */
typedef struct
{
    GT_U8 unit;          /*0xFF - end of list */
    GT_U8 channelBase;
    GT_U8 channelAmount;
    GT_U8 globalMacBase;
    GT_U8 isChannelPreemptive;
} MIF_TO_MAC_RANGE_MAP_STC;

/* generic table used for conversion to both sides */
static const MIF_TO_MAC_RANGE_MAP_STC smemChtAasMIFtoMAC_MappingArr[] =
{
     {0, 0,  8,  0, 0}
    ,{1, 0, 12,  8, 0}
    ,{2, 0,  8, 20, 0}
    ,{3, 0, 12, 28, 0}
    ,{4, 0,  8, 40, 0}
    ,{5, 0, 12, 48, 0}
    ,{6, 0,  8, 60, 0}
    ,{7, 0, 12, 68, 0}
    ,{8, 0,  1, 80, 0}
    /*must be last*/
    ,{0xFF,0, 0,  0, 0}
};

/**
* @internal smemChtAasGlobalMacToMifUintChannel function
* @endinternal
*
* @brief   Convert Global MAC to MIF Unit Channel.
*
* @param[in]   globalPort         - Global MAC index.
* @param[in]   isPreemtive        - 1 - preemtive, otherwise - 0.
* @param[out]  mifUnitPtr         - (Pointer to) MIF unit index.
* @param[out]  mifChannelPtr      - (Pointer to) MIF Channel index.
*/
GT_STATUS smemChtAasGlobalMacToMifUintChannel
(
    IN   GT_U32   globalMac,
    IN   GT_U32   isPreemtive,
    OUT  GT_U32   *mifUnitPtr,
    OUT  GT_U32   *mifChannelPtr
)
{
    const MIF_TO_MAC_RANGE_MAP_STC *searchTabPtr =
        smemChtAasMIFtoMAC_MappingArr;
    GT_U32 ii;
    GT_U32 amount;
    GT_U32 base;

    if (isPreemtive != 0)
    {
        isPreemtive = 1;
    }
    for (ii = 0;(searchTabPtr[ii].unit != 0xFF); ii++)
    {
        if (searchTabPtr[ii].isChannelPreemptive != isPreemtive) continue;
        base = searchTabPtr[ii].globalMacBase;
        if (globalMac < base) continue;
        amount = searchTabPtr[ii].channelAmount;
        if (globalMac >= (base + amount)) continue;

        /* found */
        *mifUnitPtr = searchTabPtr[ii].unit;
        *mifChannelPtr = (globalMac - base) + searchTabPtr[ii].channelBase;
        return GT_OK;
    }
    return GT_NOT_FOUND;
}

/**
* @internal smemChtAasMifUintChannelToGlobalMac function
* @endinternal
*
* @brief   Convert MIF Unit Channel to Global MAC.
*
* @param[in]  mifUnit                  - MIF unit index.
* @param[in]  mifChannel               - MIF Channel index.
* @param[in]  isPreemptiveChannel      - 0 - channel is regular or express, 1 - preemptive.
* @param[out] globalPortPtr            - Pointer to Global MAC index.
*/
GT_STATUS smemChtAasMifUintChannelToGlobalMac
(
    IN  GT_U32   mifUnit,
    IN  GT_U32   mifChannel,
    IN  GT_U32   isPreemptiveChannel,
    OUT GT_U32   *globalMacPtr
)
{
    const MIF_TO_MAC_RANGE_MAP_STC *searchTabPtr =
        smemChtAasMIFtoMAC_MappingArr;
    GT_U32 ii;
    GT_U32 base;
    GT_U32 offset;

    for (ii = 0; (searchTabPtr[ii].unit != 0xFF); ii++)
    {
        if (isPreemptiveChannel != searchTabPtr[ii].isChannelPreemptive) continue;
        if (mifUnit != searchTabPtr[ii].unit) continue;
        base = searchTabPtr[ii].channelBase;
        if (mifChannel < base) continue;
        offset = mifChannel - base;
        if (offset >= searchTabPtr[ii].channelAmount) continue;

        /* found */
        *globalMacPtr = offset + searchTabPtr[ii].globalMacBase;
        return GT_OK;
    }
    return GT_NOT_FOUND;
}

/*******************************************************************************
*   smemAasPortInfoGet
*
* DESCRIPTION:
*       get port info relate to the portNum .
*
* INPUTS:
*       devObjPtr   - pointer to device object.
*       unitType    - the unit type
*       portNum     - the port num
* OUTPUTS:
*       portInfoPtr - (pointer to) the port info.
*
* RETURNS:
*      GT_OK       - the port is valid for the 'unitInfo'
*      GT_NOT_FOUND - the port is not valid for the 'unitInfo'
* COMMENTS:
*
*
*******************************************************************************/
static GT_STATUS smemAasPortInfoGet
(
    IN SKERNEL_DEVICE_OBJECT_T_PTR devObjPtr,
    IN SMEM_UNIT_TYPE_ENT      unitType,
    IN GT_U32                  portNum,
    OUT ENHANCED_PORT_INFO_STC *portInfoPtr
)
{
    GT_U32  ii,jj,jjMax = 1;
    MAC_NUM_INFO_EXT_STC   *tmpMacInfoPtr;
    GT_U32      sip6_MTI_bmpPorts = 0xFFFFFFFF;
    GT_U32      specific_sip6_MTI_EXTERNAL_representativePortIndex;
    GT_U32  unitIndex,indexInUnit;
    GT_U32  regIndex,startBit,regAddr,sd_mux_control;
    GT_U32  serdesUnitIndex,serdesIndexInUnit;
    GT_U32  cider_localPortInGop;
    MAC_NUM_INFO_EXT_STC *aas100GMifPortsPtr = devObjPtr->numOfTiles == 1 ? aas100GMifPortsArr : aas_2_tiles_100GPortsArr;
    MAC_NUM_INFO_EXT_STC *aas100GMacPortsPtr = devObjPtr->numOfTiles == 1 ? aas100GMacPortsArr : aas_2_tiles_100GPortsArr;
    MAC_NUM_INFO_EXT_STC *aas100GPcsPortsPtr = devObjPtr->numOfTiles == 1 ? aas100GPcsPortsArr : aas_2_tiles_100GPortsArr;
    MAC_NUM_INFO_EXT_STC *aasCpuPortsPtr  = devObjPtr->numOfTiles == 1 ? aasCpuPortsArr  : aas_2_tiles_CpuPortsArr;

    if(unitType == SMEM_UNIT_TYPE_MTI_MAC_USX_E)
    {
        /* AAS not have USX */
        return GT_NOT_FOUND;
    }

    /*special case*/
    if (unitType == SMEM_UNIT_TYPE_EPI_MIF_UNIT_ID_TO_DP_E)
    {
        GT_U32  mifUnitId = portNum;/* !!! the parameter used as mifUnitId !!! */
        GT_U32  local_mif_channel_number = portInfoPtr->simplePortInfo.indexInUnit;/* !!! the parameter used as input !!! */
        GT_U32  dpUnitIndex     ;
        GT_U32  localPortInDp   ;
        GT_BIT  portSupportPreemption = 0;

        if(mifUnitId >= devObjPtr->numOfMifs)
        {
            skernelFatalError("smemAasPortInfoGet : unknown mifUnitId [%d] \n",mifUnitId);
            return GT_FAIL;
        }

        /* have 3 MIF units per DP */
        /* 8 ports, 8 ports, 4 ports */
        /* additional per tile - CPU port MIF and 4 14-ports FlexE MIFs */
        dpUnitIndex   =
            mifUnitIndexToDp[mifUnitId % mifUnitsPerTile] + ((mifUnitId /mifUnitsPerTile) * numOfDpPerTile);
        localPortInDp = mifUnitStartPortInDp[mifUnitId % mifUnitsPerTile] + local_mif_channel_number;

        portSupportPreemption = 0;/* TBD */

        portInfoPtr->simplePortInfo.unitIndex   = dpUnitIndex;   /* the 'dpUnitIndex' */
        portInfoPtr->simplePortInfo.indexInUnit = localPortInDp; /* the converted mif local channel to DP local channel */
        portInfoPtr->sip6_MTI_EXTERNAL_representativePortIndex = 0;/*not used*/
        portInfoPtr->sip6_MTI_bmpPorts[0] = (portSupportPreemption << 0);/*bit 0 is 'isPreemptiveChannel'*/
        portInfoPtr->sip6_MTI_bmpPorts[1] = 0;/*not used*/
        return GT_OK;
    }

    switch(unitType)
    {
        case SMEM_UNIT_TYPE_PCA_TSU_CHANNEL_E:
        case SMEM_UNIT_TYPE_PCA_LMU_CHANNEL_E:
        case SMEM_UNIT_TYPE_EPI_MIF_TYPE_E:
        case SMEM_UNIT_TYPE_EPI_MIF_CHANNEL_E:
            jjMax = NUM_OF_ARRAY_TYPES;
            break;
        case SMEM_UNIT_TYPE_MTI_MAC_50G_E:
            cider_localPortInGop = (portNum % 20);
            if(cider_localPortInGop < 16)
            {
                sip6_MTI_bmpPorts = 0x000000FF;/* 8 ports in each group : bits : 0..7 */
            }
            else
            {
                sip6_MTI_bmpPorts = 0x0000000F;/* 4 ports in the group : bits : 16..19 */
            }
            break;
        case SMEM_UNIT_TYPE_MTI_PCS_50G_E:
            cider_localPortInGop = (portNum % 20);
            if(cider_localPortInGop < 16)
            {
                sip6_MTI_bmpPorts = 0x0000FFFF;/* 16 ports in the group : bits : 0..15 */
            }
            else
            {
                sip6_MTI_bmpPorts = 0x0000000F;/* 4 ports in the group : bits : 16..19 */
            }
            break;

        case SMEM_UNIT_TYPE_EPI_MAC_TO_SERDES_E:
            sip6_MTI_bmpPorts = 0x0;   /* not using this as SERDES muxing not have specific order */
            break;
        case SMEM_UNIT_TYPE_EPI_SERDES_TO_MAC_E:
            sip6_MTI_bmpPorts = 0x0000000f;   /* 4 SERDESes in group */
            break;
        case SMEM_UNIT_TYPE_MTI_MAC_CPU_E:
            sip6_MTI_bmpPorts = 0x00000001;   /* single port in the group */
            break;
        default:
            skernelFatalError("smemAasPortInfoGet : unknown type [%d] \n",unitType);
            return GT_NOT_FOUND;

    }

    for(jj = 0 ; jj < jjMax ; jj++)
    {
        switch(unitType)
        {
            case SMEM_UNIT_TYPE_PCA_TSU_CHANNEL_E:
            case SMEM_UNIT_TYPE_PCA_LMU_CHANNEL_E:
            case SMEM_UNIT_TYPE_EPI_MIF_TYPE_E:
            case SMEM_UNIT_TYPE_EPI_MIF_CHANNEL_E:
                tmpMacInfoPtr =
                    (jj == 0) ? aas100GMifPortsPtr :
                                aasCpuPortsPtr  ;
                break;
            case SMEM_UNIT_TYPE_MTI_MAC_50G_E:
            case SMEM_UNIT_TYPE_EPI_MAC_TO_SERDES_E:
                tmpMacInfoPtr = aas100GMacPortsPtr;
                break;
            case SMEM_UNIT_TYPE_MTI_PCS_50G_E:
                tmpMacInfoPtr = aas100GPcsPortsPtr;
                break;
            case SMEM_UNIT_TYPE_MTI_MAC_CPU_E:
                tmpMacInfoPtr = aasCpuPortsPtr;
                break;
            default:
                return GT_NOT_FOUND;
        }

        for(ii = 0 ;
            tmpMacInfoPtr->genInfo.globalMacNum != SMAIN_NOT_VALID_CNS ;
            ii++,tmpMacInfoPtr++)
        {
            if(unitType == SMEM_UNIT_TYPE_EPI_SERDES_TO_MAC_E)
            {
                /* we came with the global SERDES number */
                if(tmpMacInfoPtr->globalSerdesNum != portNum)
                {
                    continue;
                }
            }
            else
            if(tmpMacInfoPtr->genInfo.globalMacNum != portNum)
            {
                continue;
            }

            switch(unitType)
            {
                case SMEM_UNIT_TYPE_PCA_TSU_CHANNEL_E:
                    portInfoPtr->simplePortInfo = tmpMacInfoPtr->genInfo.channelInfo;
                    break;
                case SMEM_UNIT_TYPE_PCA_LMU_CHANNEL_E:
                    portInfoPtr->simplePortInfo.unitIndex   = tmpMacInfoPtr->genInfo.channelInfo.unitIndex;
                    /* Harrier use channel 0 in LMU for all channels */
                    portInfoPtr->simplePortInfo.indexInUnit = 0;
                    break;
                case SMEM_UNIT_TYPE_EPI_MIF_TYPE_E:
                    /* not relevant to device */
                    portInfoPtr->simplePortInfo.unitIndex   = 0;
                    portInfoPtr->simplePortInfo.indexInUnit = 0;/* not used */
                    if(devObjPtr->portsArr[portNum].state == SKERNEL_PORT_STATE_MTI_400_E)
                    {
                        GT_U32  numBits,regValue;
                        ENHANCED_PORT_INFO_STC tempPortInfo;
                        GT_U32  sip6_MTI_EXTERNAL_representativePort;
                        devObjPtr->devMemPortInfoGetPtr(devObjPtr, SMEM_UNIT_TYPE_MTI_PCS_50G_E  ,portNum, &tempPortInfo);
                        sip6_MTI_EXTERNAL_representativePort = tempPortInfo.sip6_MTI_EXTERNAL_representativePortIndex;
                        #define MTI_PORT_GLOBAL(dev,_representativePort)\
                            SMEM_CHT_MAC_REG_DB_SIP5_GET(dev)->sip6_MTI_EXTERNAL[_representativePort].MTI_GLOBAL
                        regAddr = MTI_PORT_GLOBAL(devObjPtr,sip6_MTI_EXTERNAL_representativePort).globalChannelControl;
                        startBit = 0;
                        numBits  = 4;
                        smemRegFldGet(devObjPtr, regAddr, startBit, numBits, &regValue);
                        if((portNum % 20) == 8)
                        {
                            /*MACs 8..15*/
                            regValue = regValue >> 2;
                        }
                        else /*(portNum % 20) == 0*/
                        {
                            /*MACs 0..7*/
                            regValue &= 0x3;
                        }
                        portInfoPtr->simplePortInfo.unitIndex = regValue ? 1 : 0 ;/* used as fake 'mif type' */
                    }
                    break;
                case SMEM_UNIT_TYPE_EPI_MIF_CHANNEL_E:
                    if(jj == 0)/*100G mac*/
                    {
                        /*100G mac */
                        portInfoPtr->simplePortInfo.unitIndex   = tmpMacInfoPtr->mifInfo.unitIndex;/*0..7,8*/
                        portInfoPtr->simplePortInfo.indexInUnit = tmpMacInfoPtr->mifInfo.indexInUnit;/*0..15*/
                        specific_sip6_MTI_EXTERNAL_representativePortIndex = portInfoPtr->simplePortInfo.unitIndex;/*0..7,8*/
                    }
                    else
                    {
                        portInfoPtr->simplePortInfo.unitIndex   = tmpMacInfoPtr->mifInfo.unitIndex;/*9*/
                        portInfoPtr->simplePortInfo.indexInUnit = tmpMacInfoPtr->mifInfo.indexInUnit;/*0*/
                        specific_sip6_MTI_EXTERNAL_representativePortIndex = portInfoPtr->simplePortInfo.unitIndex;/*9*/
                    }

                    /* set specific sip6_MTI_EXTERNAL_representativePort */
                    portInfoPtr->sip6_MTI_EXTERNAL_representativePortIndex = specific_sip6_MTI_EXTERNAL_representativePortIndex;
                    portInfoPtr->sip6_MTI_bmpPorts[0] = sip6_MTI_bmpPorts;
                    return GT_OK;

                case SMEM_UNIT_TYPE_EPI_MAC_TO_SERDES_E:
                    /* we got the local mac number : tmpMacInfoPtr->genInfo.macInfo.indexInUnit */
                    /* we need to get from the ANP unit the MAC_TO_SERDES muxing                */
                    unitIndex   = tmpMacInfoPtr->genInfo.macInfo.unitIndex;
                    indexInUnit = tmpMacInfoPtr->genInfo.macInfo.indexInUnit;
                    regIndex = indexInUnit / 4;
                    startBit = 8 * (indexInUnit % 4);
                    regAddr = SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->sip_6_10_ANP[unitIndex].ANP.Global_SD_Mux_Control[regIndex];
                    smemRegFldGet(devObjPtr,regAddr,startBit,8,&sd_mux_control);

                    /* 2 units of (4 lanes in SERDES unit) are connected to the ANP */
                    serdesUnitIndex   = tmpMacInfoPtr->serdesInfo.unitIndex & 0xffffffe;
                    serdesUnitIndex  += sd_mux_control / 4;
                    serdesIndexInUnit = sd_mux_control % 4;

                    portInfoPtr->simplePortInfo.unitIndex   = serdesUnitIndex;
                    portInfoPtr->simplePortInfo.indexInUnit = serdesIndexInUnit;
                    portInfoPtr->sip6_MTI_EXTERNAL_representativePortIndex = portInfoPtr->simplePortInfo.unitIndex;/*0..4*/
                    portInfoPtr->sip6_MTI_bmpPorts[0] = sip6_MTI_bmpPorts;
                    return GT_OK;

                case SMEM_UNIT_TYPE_EPI_SERDES_TO_MAC_E:
                    portInfoPtr->simplePortInfo = tmpMacInfoPtr->genInfo.macInfo;
                    portInfoPtr->sip6_MTI_EXTERNAL_representativePortIndex =  tmpMacInfoPtr->genInfo.globalMacNum;
                    portInfoPtr->sip6_MTI_bmpPorts[0] = sip6_MTI_bmpPorts;
                    return GT_OK;
                default:
                    portInfoPtr->simplePortInfo = tmpMacInfoPtr->genInfo.macInfo;
                    break;
            }

            portInfoPtr->sip6_MTI_EXTERNAL_representativePortIndex =  tmpMacInfoPtr->genInfo.sip6_MTI_EXTERNAL_representativePortIndex;
            portInfoPtr->sip6_MTI_bmpPorts[0] = sip6_MTI_bmpPorts;

            return GT_OK;
        }/* loop on ii*/
    } /* loop on jj*/


    return GT_NOT_FOUND;
}

/**
* @internal smemAasUnitPipeOffsetGet function
* @endinternal
*
* @brief   Get pipe offset for unit register address in data base.
*
* @param[in] devObjPtr                - pointer to device object.
* @param[in] regAddress               - unit register lookup addres
*
* @param[out] pipeIndexPtr             - (pointer to) the pipe index that hold the 'regAddress'
*                                      ignored if NULL
*
* @retval Pipe offset !== 0        - pipe1 offset
* @retval == 0                     - pipe1 offset not found (should not happen)
*/
static GT_U32 smemAasUnitPipeOffsetGet
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN GT_U32                   regAddress,
    IN GT_U32                   *pipeIndexPtr
)
{
    GT_U32  tileId = regAddress / devObjPtr->tileOffset;

    if(pipeIndexPtr)
    {
        *pipeIndexPtr = tileId;/* single pipe per tile */
    }

    return  tileId * devObjPtr->tileOffset;
}

static SMEM_UNIT_NAME_AND_INDEX_STC aasUnitNameAndIndexArr[AAS_NUM_UNITS]=
{
    /* filled in runtime from aas_units[] */
    /* must be last */
    {NULL ,                                SMAIN_NOT_VALID_CNS                     }
};
/* the addresses of the units that the aas uses */
static SMEM_UNIT_BASE_AND_SIZE_STC   aasUsedUnitsAddressesArray[AAS_NUM_UNITS]=
{
    {0,0}    /* filled in runtime from aas_units[] */
};

/* build once the sorted memory for the falcon .. for better memory search performance

    that use by :

    devObjPtr->devMemUnitNameAndIndexPtr      = aasUnitNameAndIndexArr;
    devObjPtr->genericUsedUnitsAddressesArray = aasUsedUnitsAddressesArray;


*/
static void build_SORTED___aas_units(void)
{
    GT_U32  numValidElem,ii;
    SMEM_GEN_UNIT_INFO_STC   *unitInfoPtr = &aas_units[0];

    if(SORTED___aas_units[0].base_addr != SMAIN_NOT_VALID_CNS)
    {
        /* already initialized */
        return;
    }

    memcpy(SORTED___aas_units,aas_units,sizeof(aas_units));

    numValidElem = 0;
    for(ii = 0 ; unitInfoPtr->size != SMAIN_NOT_VALID_CNS; ii++,unitInfoPtr++)
    {
        numValidElem++;
    }

    qsort(SORTED___aas_units, numValidElem, sizeof(SMEM_GEN_UNIT_INFO_STC),
          sim_sip6_units_cellCompare);

}

static void addDuplicatedUnitIfNotExists
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN GT_CHAR*         origUnitNamePtr,
    IN GT_CHAR*         dupUnitNamePtr
)
{
    GT_U32  ii,jj;
    SMEM_UNIT_DUPLICATION_INFO_STC   *unitInfoPtr_1 = &aas_duplicatedUnits[0];
    SMEM_UNIT_DUPLICATION_INFO_STC   *unitInfoPtr_2;
    GT_U32  found_1,found_2;


    for(ii = 0 ; unitInfoPtr_1->unitNameStr != NULL; ii++)
    {
        if(0 == strcmp(origUnitNamePtr,unitInfoPtr_1->unitNameStr))
        {
            found_1 = 1;
        }
        else
        {
            found_1 = 0;
        }

        found_2 = 0;

        unitInfoPtr_2 = unitInfoPtr_1+1;
        for(jj = 0 ; jj < unitInfoPtr_1->numOfUnits ; jj++,unitInfoPtr_2++)
        {
            if(found_1 == 0)
            {
                if(0 == strcmp(origUnitNamePtr,unitInfoPtr_2->unitNameStr))
                {
                    found_1 = 1;
                }
            }

            if(found_2 == 0)
            {
                if(0 == strcmp(dupUnitNamePtr,unitInfoPtr_2->unitNameStr))
                {
                    found_2 = 1;
                }
            }

            if(found_1 && found_2)
            {
                return;
            }
        }

        unitInfoPtr_1 = unitInfoPtr_2;
        ii += jj;
    }

    /* we need to add 2 entries to the DB (and 'NULL' entry) */
    if((ii+2) >= (sizeof(aas_duplicatedUnits)/sizeof(aas_duplicatedUnits[0])))
    {
        skernelFatalError("addDuplicatedUnitIfNotExists : array aas_duplicatedUnits[] not large enough need at least ([%d] cells)\n",
            (ii+2+1));
        return;
    }

    aas_duplicatedUnits[ii].unitNameStr = origUnitNamePtr;
    aas_duplicatedUnits[ii].numOfUnits = 1;

    aas_duplicatedUnits[ii+1].unitNameStr = dupUnitNamePtr;
    aas_duplicatedUnits[ii+1].numOfUnits = 0;

    aas_duplicatedUnits[ii+2].unitNameStr = NULL;
    aas_duplicatedUnits[ii+2].numOfUnits = 0;

    return ;
}

static void buildDevUnitAddr
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr
)
{
    /* build
        aasUsedUnitsAddressesArray - the addresses of the units that the Falcon uses
        aasUnitNameAndIndexArr - name of unit and index in aasUsedUnitsAddressesArray */
    GT_U32  ii;
    GT_U32  index;
    SMEM_GEN_UNIT_INFO_STC   *unitInfoPtr = &SORTED___aas_units[0];
    GT_U32  isError = 0;

    /* build once the sorted memory for the falcon .. for better memory search performance */
    build_SORTED___aas_units();

    index = 0;
    for(ii = 0 ; unitInfoPtr->size != SMAIN_NOT_VALID_CNS; ii++,unitInfoPtr++)
    {
        if(unitInfoPtr->orig_nameStr == PER_TILE_INDICATION_CNS)
        {
            /* the instance in Tile 0 (the next instances comes next) */
        }
        else
        if(unitInfoPtr->orig_nameStr)
        {
            addDuplicatedUnitIfNotExists(devObjPtr, unitInfoPtr->orig_nameStr, unitInfoPtr->nameStr);
        }

        if(index >= (sizeof(aasUsedUnitsAddressesArray) / sizeof(aasUsedUnitsAddressesArray[0])))
        {
            skernelFatalError("buildDevUnitAddr : over flow of units (1) \n");
        }

        if(index >= (sizeof(aasUnitNameAndIndexArr) / sizeof(aasUnitNameAndIndexArr[0])))
        {
            skernelFatalError("buildDevUnitAddr : over flow of units (2) \n");
        }

        aasUsedUnitsAddressesArray[index].unitBaseAddr = unitInfoPtr->base_addr ;
        aasUsedUnitsAddressesArray[index].unitSizeInBytes = unitInfoPtr->size;
        aasUnitNameAndIndexArr[index].unitNameIndex = index;
        aasUnitNameAndIndexArr[index].unitNameStr = unitInfoPtr->nameStr;
        index++;
    }

    if(index >= (sizeof(aasUnitNameAndIndexArr) / sizeof(aasUnitNameAndIndexArr[0])))
    {
        skernelFatalError("buildDevUnitAddr : over flow of units (3) \n");
    }
    /* indication of no more */
    aasUnitNameAndIndexArr[index].unitNameIndex = SMAIN_NOT_VALID_CNS;
    aasUnitNameAndIndexArr[index].unitNameStr = NULL;
    aasUsedUnitsAddressesArray[index].unitBaseAddr = SMAIN_NOT_VALID_CNS;
    aasUsedUnitsAddressesArray[index].unitSizeInBytes = 0;

    devObjPtr->devMemUnitNameAndIndexPtr = aasUnitNameAndIndexArr;
    devObjPtr->genericUsedUnitsAddressesArray = aasUsedUnitsAddressesArray;
    devObjPtr->genericNumUnitsAddresses = index+1;
    devObjPtr->devMemUnitPipeOffsetGet = smemAasUnitPipeOffsetGet;
    devObjPtr->support_memoryRanges = 1;

 /* check that the array is ascending ! (aasUsedUnitsAddressesArray) */
    for(ii = 0 ; ii < (index+1) ; ii++)
    {
        if(ii &&
            (aasUsedUnitsAddressesArray[ii].unitBaseAddr <=
             aasUsedUnitsAddressesArray[ii-1].unitBaseAddr))
        {
            printf("Error: at index[%d] unit[%s] addr[0x%8.8x] not higher than in prev index addr[0x%8.8x] unit[%s] \n",
                ii,
                aasUnitNameAndIndexArr[ii].unitNameStr,
                aasUsedUnitsAddressesArray[ii].unitBaseAddr,
                aasUsedUnitsAddressesArray[ii-1].unitBaseAddr,
                aasUnitNameAndIndexArr[ii-1].unitNameStr
                );
            printf("see list of units till this point     \n");

            /* we found error in the array , so lets see all the elements till the error */
            /* start the loop again */
            for(ii = 0 ; ii < (index+1) ; ii++)
            {
                printf("unitBaseAddr = [0x%8.8x] \n",
                    aasUsedUnitsAddressesArray[ii].unitBaseAddr);

                if(ii &&
                    (aasUsedUnitsAddressesArray[ii].unitBaseAddr <=
                     aasUsedUnitsAddressesArray[ii-1].unitBaseAddr))
                {
                    printf("Error: at index[%d] prev index higher \n",ii);
                    break;
                }
            }

            isError = 1;
            break;/* we are DONE */
        }

        if(isError)
        {
            break;
        }

        /* check if the previous unit size not overlapped with the current unit */
        if(ii &&
           (aasUsedUnitsAddressesArray[ii-1].unitBaseAddr + aasUsedUnitsAddressesArray[ii-1].unitSizeInBytes) >
            aasUsedUnitsAddressesArray[ii]  .unitBaseAddr)
        {
            printf("Error: at index[%d] unit[%s] addr[0x%8.8x]+size[0x%8.8x]=[0x%8.8x] higher than addr[0x%8.8x] in next unit unit[%s] \n",
                ii-1,
                aasUnitNameAndIndexArr[ii-1].unitNameStr,
                aasUsedUnitsAddressesArray[ii-1].unitBaseAddr,
                aasUsedUnitsAddressesArray[ii-1].unitSizeInBytes,
                aasUsedUnitsAddressesArray[ii-1].unitBaseAddr + aasUsedUnitsAddressesArray[ii-1].unitSizeInBytes,
                aasUsedUnitsAddressesArray[ii].unitBaseAddr,
                aasUnitNameAndIndexArr[ii].unitNameStr
                );
        }
    }

}

/* Active memory */

/**
* @internal smemAasActiveWriteQbvConfigChangeTimeReq function
* @endinternal
*
 * @brief   The function handle port binding to QBV tablset.
*
* @param[in] devObjPtr                - device object PTR.
* @param[in] address                  - Address for ASIC memory.
* @param[in] memPtr                   - Pointer to the register's memory in the simulation.
* @param[in] memSize                  - Size of memory to be written
* @param[in] param                    - Registers' specific parameter.
* @param[in] inMemPtr                 - Pointer to the memory to get register's content.
*/

static void smemAasActiveWriteQbvConfigChangeTimeReq(
    IN         SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN         GT_U32   address,
    IN         GT_U32   memSize,
    IN         GT_U32 * memPtr,
    IN         GT_UINTPTR   param,
    IN         GT_U32 * inMemPtr
)
{
    GT_U32              port;           /* Port number*/
    GT_U32              triger;       /* When set to 1 HW is notified that there is pending request.
                                                                        This bit is cleared by the device when the access action is completed*/
    GT_U32              tableSet,lastEntry,lengthAware;
    GT_U32              regAddr,regValue;


    DECLARE_FUNC_NAME(smemAasActiveWriteQbvConfigChangeTimeReq);

    /* data to be written */
    *memPtr = *inMemPtr;

    triger = SMEM_U32_GET_FIELD(*inMemPtr, 0, 1);
    if(triger == 0)
    {
        return;
    }

    port = SMEM_U32_GET_FIELD(*inMemPtr, 1, 6);
    tableSet = SMEM_U32_GET_FIELD(*inMemPtr, 7, 5);
    lastEntry = SMEM_U32_GET_FIELD(*inMemPtr, 12, 8);
    lengthAware= SMEM_U32_GET_FIELD(*inMemPtr, 20, 12);

    __LOG(("QBV triger received .Bind for port %d to tableset \n", port,tableSet));

    regAddr = SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->SIP6_TXQ_SDQ[0].QBV.portQbvTableSet[port];

    smemRegGet(devObjPtr,regAddr,&regValue);
    SMEM_U32_SET_FIELD(regValue, 0, 5,tableSet);
    SMEM_U32_SET_FIELD(regValue, 13, 8,lastEntry);
    smemRegSet(devObjPtr,regAddr,regValue);

    regAddr =SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->SIP6_TXQ_SDQ[0].QBV.configChangeTimeEgressTODOffset;
    smemRegGet(devObjPtr,regAddr,&regValue);
    regAddr = SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->SIP6_TXQ_SDQ[0].QBV.portEgressTodOffset[port];
    smemRegSet(devObjPtr,regAddr,regValue);

    regAddr =SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->SIP6_TXQ_SDQ[0].QBV.configChangeTimeCycleTime;
    smemRegGet(devObjPtr,regAddr,&regValue);
    regAddr = SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->SIP6_TXQ_SDQ[0].QBV.portTableSetCycleTime[port];
    smemRegSet(devObjPtr,regAddr,regValue);


    regAddr = SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->SIP6_TXQ_SDQ[0].QBV.portLengthAwrAttr[port];
    smemRegGet(devObjPtr,regAddr,&regValue);
    SMEM_U32_SET_FIELD(regValue, 0, 12,lengthAware);
    smemRegSet(devObjPtr,regAddr,regValue);


    /* clear <QBV Change Time Pending> */
    SMEM_U32_SET_FIELD(*memPtr, 0, 1, 0);

    return;

}

/**
* @internal smemAasUnitInitTai function
* @endinternal
*
* @brief   Allocate address type specific memories - for the TAI units
*/
static void smemAasUnitInitTai
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    INOUT SMEM_UNIT_CHUNKS_STC  * unitPtr
)
{
    {
        /* aligned to /Cider/EBU-IP/GOP/GOP LEGACY/TAI IP/TAI IP 7.0/TAI IP {7.1.6} */
        SMEM_CHUNK_BASIC_STC  chunksMem[]=
        {
            {SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000000, 0x000000F8)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000200, 0x00000208)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000300, 0x00000324)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000330, 0x0000035C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000400, 0x00000414)}

            /* dedicated register to emulate PHY timestamp queue with single entry */
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000500, 0x00000514)}


        };
        GT_U32  numOfChunks = sizeof(chunksMem)/sizeof(SMEM_CHUNK_BASIC_STC);

        smemInitMemChunk(devObjPtr,chunksMem,numOfChunks,unitPtr);

    }
}

/**
* @internal smemAasSpecificDeviceUnitAlloc_TAI_units
*           function
* @endinternal
*
* @brief   specific initialization units allocation that called before alloc units
*         of any device.
*         SIP units
* @param[in] devObjPtr                - pointer to device object.
*                                       Pointer to object for specific subunit
*/
void smemAasSpecificDeviceUnitAlloc_TAI_units
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr
)
{
    SMEM_DEVICE_UNIT_ALLOCATION_STC allocUnitsArr[] = {
         {STR(UNIT_TAI)         ,smemAasUnitInitTai}
        /* must be last */
        ,{NULL,NULL}
    };

    smemGenericUnitAlloc(devObjPtr,allocUnitsArr);
}

/**
* @internal smemAasActiveWriteRxDmaDebugClearAllCounters function
* @endinternal
*
* @brief   write of RxDma Debug Counter subunit disabled all counters cleared
*
* @param[in] devObjPtr                - device object PTR.
* @param[in] address                  - Address for ASIC memory.
* @param[in] memSize                  - size of the requested memory
* @param[in] memPtr                   - Pointer to the register's memory in the simulation.
* @param[in] param                    - Registers' specific parameter.
* @param[in] inMemPtr                 - Pointer to the memory to get register's content.
*/
void smemAasActiveWriteRxDmaDebugClearAllCounters (
    IN         SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN         GT_U32   address,
    IN         GT_U32   memSize,
    IN         GT_U32 * memPtr,
    IN         GT_UINTPTR   param,
    IN         GT_U32 * inMemPtr
)
{
    GT_U32  i,j;
    GT_U32 counterBase = (address & 0xFFFF0000);
    static const struct
    {
        GT_U32 baseOffset0; /*typically LSB*/
        GT_U32 baseOffset1; /*typically MSB, odd-value means not available */
        GT_U32 step;
        GT_U32 numOf;
    } counterOffsetArr[] =
    {
         {0x1F00, 0x1F04,  0, 1 }/*RX Ingress Stress and Errors Counters*/
        ,{0x1F80, 0x1F84,  0, 1 }/*RX Accum MEM Counters*/
        ,{0x2000, 0x2004,  0, 1 }/*RX to CP Counters*/
        ,{0x2080, 0x2084, 16, 2 }/*CP to RX Counters*/
        ,{0x2100, 0x2104,  0, 1 }/*RX to PB Counters*/
        ,{0x2180, 0x2184,  0, 1 }/*PB to RX Counters*/
        ,{0x2200, 0x2204,  0, 1 }/*RX to PDX Counters*/
        ,{0x2280, 0x2284,  0, 1 }/*PDX to RX Counters*/
        ,{0x2380, 0x2384, 16, ((NUM_PORTS_PER_DP_UNIT+3) * 4) }/*RX Ingress Drop Counters*/
        ,{0x2D80, 0x2D84, 16, (NUM_PORTS_PER_DP_UNIT+3)}/*RX Egress Drop Counters*/
    };
    static const GT_U32 counterOffsetArrSise =
        (sizeof(counterOffsetArr) / sizeof(counterOffsetArr[0]));

    /* data to be written */
    for (i = 0; (i < memSize); i++)
    {
        memPtr[i] = inMemPtr[i];
    }

    /* counters cleared on on disable, on enable nothing to do */
    if (inMemPtr[0] & 1) return;

    /* clear counters */
    for (i = 0; (i < counterOffsetArrSise); i++)
    {
        for (j = 0; (j < counterOffsetArr[i].numOf); j++)
        {
            smemRegSet(
                devObjPtr,
                (counterBase + counterOffsetArr[i].baseOffset0
                 + (j * counterOffsetArr[i].step)), 0);
            if (counterOffsetArr[i].baseOffset0 & 1) continue;
            smemRegSet(
                devObjPtr,
                (counterBase + counterOffsetArr[i].baseOffset1
                 + (j * counterOffsetArr[i].step)), 0);
        }
    }
}

/**
* @internal smemAasActiveReadRxDmaDebugClearCounter function
* @endinternal
*
* @brief   read of RxDma Debug Counter - may be clear on read
*
* @param[in] devObjPtr                - device object PTR.
* @param[in] address                  - Address for ASIC memory.
* @param[in] memSize                  - size of the requested memory
* @param[in] memPtr                   - Pointer to the register's memory in the simulation.
* @param[in] param                    - Registers' specific parameter.
* @param[in] outMemPtr                - Pointer to the memory to get register's content.
*/
void smemAasActiveReadRxDmaDebugClearCounter
(
    IN         SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN         GT_U32   address,
    IN         GT_U32   memSize,
    IN         GT_U32 * memPtr,
    IN         GT_UINTPTR   param,
    OUT        GT_U32 * outMemPtr
)
{
    GT_U32 dp0CfgRegAddr;
    GT_U32 cfgRegAddr;
    GT_U32 addrMask;
    GT_U32 fieldVal;

    param = param; /* unused parameter */

    dp0CfgRegAddr =
        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->sip6_rxDMA[0].debug.dp_rx_config_debug_counters;
    addrMask = 0xFFFF;
    cfgRegAddr = (address & (~ addrMask)) | (dp0CfgRegAddr & addrMask);
    /*  1 means Counters are cleared after each read */
    smemRegFldGet(devObjPtr, cfgRegAddr, 2, 1, &fieldVal);
    if (fieldVal == 0)
    {
        /* no clear on read */
        *outMemPtr = *memPtr;
        return;
    }

    /* msbAddr = lsbAddr + 4; <==> param != 0 */
    smemChtActiveReadCntrs64Bit(
        devObjPtr, address, memSize, memPtr,
        1/*param*/, outMemPtr);
}

/**
* @internal smemAasUnitRxDma function
* @endinternal
*
* @brief   Allocate address type specific memories
*
* @param[in] devObjPtr                - pointer to device object.
* @param[in,out] unitPtr                  - pointer to the unit chunk
*/
static void smemAasUnitRxDma
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    INOUT SMEM_UNIT_CHUNKS_STC  * unitPtr
)
{
    /* /Cider/EBU/Seahawk/Seahawk {Seahawk_CC_230515}/Tile/Core/DP/<RXDMA> RXDMA IP TLU/Units %r/RxDMA*/
    /*IP:  \Cider \EBU-IP \DP \RxDMA IP \RxDMA 10.0 - Seahawk1 \RXDMA {shk1_20230504} \RXDMA IP TLU \Units \RxDMA*/
    /*Mask: \Cider \EBU-IP \DP \RxDMA IP \RxDMA 10.0 - Seahawk1 \RXDMA {shk1_20230504}*/

    {
        START_BIND_UNIT_ACTIVE_MEM_MAC(devObjPtr,unitPtr)
        /* all counters cleared by writing 0 to enable register*/
        {0x00001D84, 0xFFFFFFFF  , NULL, 0, smemAasActiveWriteRxDmaDebugClearAllCounters, 0, NULL},
        /* all Debug Counters are read only and optiona; clear on read */
        /* RX Ingress Stress and Errors Counters */
        {0x00001F00, 0xFFFFFFF8  , smemAasActiveReadRxDmaDebugClearCounter, 0, NULL, 0, NULL},
        /* RX Accum MEM Counters */
        {0x00001F80, 0xFFFFFFF8  , smemAasActiveReadRxDmaDebugClearCounter, 0, NULL, 0, NULL},
        /* RX to CP Counters */
        {0x00002000, 0xFFFFFFF8  , smemAasActiveReadRxDmaDebugClearCounter, 0, NULL, 0, NULL},
        /* CP to RX Counters */
        {0x00002080, 0xFFFFFFF8  , smemAasActiveReadRxDmaDebugClearCounter, 0, NULL, 0, NULL},
        {0x00002090, 0xFFFFFFF8  , smemAasActiveReadRxDmaDebugClearCounter, 0, NULL, 0, NULL},
        /* RX to PB Counters */
        {0x00002100, 0xFFFFFFF8  , smemAasActiveReadRxDmaDebugClearCounter, 0, NULL, 0, NULL},
        /* RX to PDX Counters */
        {0x00002200, 0xFFFFFFF8  , smemAasActiveReadRxDmaDebugClearCounter, 0, NULL, 0, NULL},
        /* PDX to RX Counters */
        {0x00002280, 0xFFFFFFF8  , smemAasActiveReadRxDmaDebugClearCounter, 0, NULL, 0, NULL},
        /* RX Ingress Drop Counters ch%n Prioruty%p */
        /* 0x00642380 + 64*n+16*p: where n (0-22) represents channel, where p (0-3) represents prio */
        {0x00002380, 0xFFFFF808  , smemAasActiveReadRxDmaDebugClearCounter, 0, NULL, 0, NULL},
        /* RX Egress Drop Counters %n */
        /* 0x00642D80 + 0x10*n: where n (0-22) represents counter_index */
        {0x00002D80, 0xFFFFFE08  , smemAasActiveReadRxDmaDebugClearCounter, 0, NULL, 0, NULL},
        END_BIND_UNIT_ACTIVE_MEM_MAC(devObjPtr,unitPtr)
    }

    {
        SMEM_CHUNK_BASIC_STC  chunksMem[]=
        {
             {SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000000, 0x0000002C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000080, 0x00000084)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000100, 0x00000118)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001000, 0x00001004)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001080, 0x00001244)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001258, 0x000013EC)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000014F0, 0x000014FC)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001800, 0x0000182C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001C00, 0x00001C08)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001C80, 0x00001C94)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001CA0, 0x00001CA4)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001D00, 0x00001D00)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001D80, 0x00001DA0)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001E00, 0x00001E04)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001E80, 0x00001EA4)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001F00, 0x00001F0C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001F80, 0x00001F9C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00002000, 0x0000200C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00002080, 0x000020A0)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00002100, 0x0000210C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00002180, 0x00002190)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00002200, 0x00002210)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00002280, 0x0000228C)}
        };

        GT_U32  numOfChunks = sizeof(chunksMem)/sizeof(SMEM_CHUNK_BASIC_STC);
        smemInitMemChunk(devObjPtr,chunksMem, numOfChunks, unitPtr);
    }

    /* per channel */
    {
        SMEM_CHUNK_BASIC_STC  chunksMem[]=
        {
             {SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00000120,  4*(NUM_PORTS_PER_DP_UNIT+3))}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00000800,  4*(NUM_PORTS_PER_DP_UNIT+3))}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00000B00,  4*(NUM_PORTS_PER_DP_UNIT+3))}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x000013f0,  4*(NUM_PORTS_PER_DP_UNIT+3))}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00001500,  4*(NUM_PORTS_PER_DP_UNIT+3))}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00002380, 64*(NUM_PORTS_PER_DP_UNIT+3))}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00002D80, 16*(NUM_PORTS_PER_DP_UNIT+3))}
        };
        GT_U32  numOfChunks = sizeof(chunksMem)/sizeof(SMEM_CHUNK_BASIC_STC);
        SMEM_UNIT_CHUNKS_STC    tmpUnitChunk;

        update_mem_chunk_from_size_to_size (chunksMem,numOfChunks,
            4*(NUM_PORTS_PER_DP_UNIT+1),
            4*(RUNTIME_NUM_PORTS_PER_DP_UNIT+1));

        smemInitMemChunk(devObjPtr,chunksMem, numOfChunks, &tmpUnitChunk);

        /*add the tmp unit chunks to the main unit */
        smemInitMemCombineUnitChunks(devObjPtr,unitPtr,&tmpUnitChunk);
    }


    {
        static SMEM_REGISTER_DEFAULT_VALUE_STC myUnit_registersDefaultValueArr[] =
        {

             {DUMMY_NAME_PTR_CNS,            0x00000000,         0x03ff03ff,      1,    0x0         }
            ,{DUMMY_NAME_PTR_CNS,            0x00000004,         0x00002c00,      1,    0x0         }
            ,{DUMMY_NAME_PTR_CNS,            0x00000008,         0x00000016,      1,    0x0         }
            ,{DUMMY_NAME_PTR_CNS,            0x00000020,         0x000000C8,      1,    0x0         }
            ,{DUMMY_NAME_PTR_CNS,            0x00000028,         0x0000ffff,      1,    0x0         }
            ,{DUMMY_NAME_PTR_CNS,            0x0000002C,         0x00000008,      1,    0x0         }
            ,{DUMMY_NAME_PTR_CNS,            0x00000080,         0x00B20062,      1,    0x0         }
            ,{DUMMY_NAME_PTR_CNS,            0x00000084,         0x03d90007,      1,    0x0         }
            ,{DUMMY_NAME_PTR_CNS,            0x00000100,         0x0003ffff,      1,    0x0         }
            ,{DUMMY_NAME_PTR_CNS,            0x00000104,         0x00000002,      1,    0x0         }
            ,{DUMMY_NAME_PTR_CNS,            0x00000108,         0x000000ff,      1,    0x0         }
            ,{DUMMY_NAME_PTR_CNS,            0x0000010c,         0x00003fff,      4,    0x4         }
            ,{DUMMY_NAME_PTR_CNS,            0x00000120,         0x00800407,     (NUM_PORTS_PER_DP_UNIT+3),    0x4         }
            ,{DUMMY_NAME_PTR_CNS,            0x00000800,         0x00000016,     (NUM_PORTS_PER_DP_UNIT+3),    0x4,        }
            ,{DUMMY_NAME_PTR_CNS,            0x00000b00,         0x00000000,      1,    0x0         }
            ,{DUMMY_NAME_PTR_CNS,            0x00000b04,         0x00000001,      1,    0x0         }
            ,{DUMMY_NAME_PTR_CNS,            0x00000b08,         0x00000002,      1,    0x0         }
            ,{DUMMY_NAME_PTR_CNS,            0x00000b0c,         0x00000003,      1,    0x0         }
            ,{DUMMY_NAME_PTR_CNS,            0x00000b10,         0x00000004,      1,    0x0         }
            ,{DUMMY_NAME_PTR_CNS,            0x00000b14,         0x00000005,      1,    0x0         }
            ,{DUMMY_NAME_PTR_CNS,            0x00000b18,         0x00000006,      1,    0x0         }
            ,{DUMMY_NAME_PTR_CNS,            0x00000b1c,         0x00000007,      1,    0x0         }
            ,{DUMMY_NAME_PTR_CNS,            0x00000b20,         0x00000008,      1,    0x0         }
            ,{DUMMY_NAME_PTR_CNS,            0x00000b24,         0x00000009,      1,    0x0         }
            ,{DUMMY_NAME_PTR_CNS,            0x00000b28,         0x0000000a,      1,    0x0         }
            ,{DUMMY_NAME_PTR_CNS,            0x00000b2c,         0x0000000b,      1,    0x0         }
            ,{DUMMY_NAME_PTR_CNS,            0x00000b30,         0x0000000c,      1,    0x0         }
            ,{DUMMY_NAME_PTR_CNS,            0x00000b34,         0x0000000d,      1,    0x0         }
            ,{DUMMY_NAME_PTR_CNS,            0x00000b38,         0x0000000e,      1,    0x0         }
            ,{DUMMY_NAME_PTR_CNS,            0x00000b3c,         0x0000000f,      1,    0x0         }
            ,{DUMMY_NAME_PTR_CNS,            0x00000b40,         0x00000010,      1,    0x0         }
            ,{DUMMY_NAME_PTR_CNS,            0x00000b44,         0x00000011,      1,    0x0         }
            ,{DUMMY_NAME_PTR_CNS,            0x00000b48,         0x00000012,      1,    0x0         }
            ,{DUMMY_NAME_PTR_CNS,            0x00000b4c,         0x00000013,      1,    0x0         }
            ,{DUMMY_NAME_PTR_CNS,            0x00000b50,         0x00000014,      1,    0x0         }
            ,{DUMMY_NAME_PTR_CNS,            0x00000b54,         0x00000015,      1,    0x0         }
            ,{DUMMY_NAME_PTR_CNS,            0x00001000,         0x00000003,      1,    0x0         }
            ,{DUMMY_NAME_PTR_CNS,            0x00001240,         0x00000800,      1,    0x0         }
            ,{DUMMY_NAME_PTR_CNS,            0x00001244,         0x000086dd,      1,    0x0         }
            ,{DUMMY_NAME_PTR_CNS,            0x00001258,         0x00008847,      1,    0x0         }
            ,{DUMMY_NAME_PTR_CNS,            0x0000125c,         0x00008848,      1,    0x0         }
            ,{DUMMY_NAME_PTR_CNS,            0x00001290,         0xffffffff,      4,    0x4         }
            ,{DUMMY_NAME_PTR_CNS,            0x000012A0,         0x0000ffff,      4,    0x4         }
            ,{DUMMY_NAME_PTR_CNS,            0x000013d0,         0x00018100,      4,    0x4         }
            ,{DUMMY_NAME_PTR_CNS,            0x000013e0,         0x00008100,      1,    0x0         }
            ,{DUMMY_NAME_PTR_CNS,            0x000013e4,         0x00008a88,      1,    0x0         }
            ,{DUMMY_NAME_PTR_CNS,            0x00001c00,         0xffffffff,      1,    0x0         }
            ,{DUMMY_NAME_PTR_CNS,            0x00001c04,         0xffffffff,      1,    0x0         }
            ,{DUMMY_NAME_PTR_CNS,            0x00001c08,         0x00000001,      1,    0x0         }
            ,{DUMMY_NAME_PTR_CNS,            0x00001d00,         0xffff0000,      1,    0x0         }
            ,{DUMMY_NAME_PTR_CNS,            0x00001d80,         0x00000005,      1,    0x0         }
            ,{DUMMY_NAME_PTR_CNS,            0x00001d88,         0xffffffff,      2,    0x4         }
            ,{DUMMY_NAME_PTR_CNS,            0x00001e00,         0x00000001,      1,    0x0         }
            ,{DUMMY_NAME_PTR_CNS,            0x00001e80,         0x00005555,      1,    0x0         }
            ,{DUMMY_NAME_PTR_CNS,            0x00001e84,         0x00055555,      1,    0x0         }
            ,{DUMMY_NAME_PTR_CNS,            0x00001e88,         0x55555555,      1,    0x0         }
            ,{DUMMY_NAME_PTR_CNS,            0x00001e8c,         0x01555555,      2,    0x4         }
            ,{DUMMY_NAME_PTR_CNS,            0x00001e90,         0x01555555,      2,    0x4         }
            ,{DUMMY_NAME_PTR_CNS,            0x00001e94,         0x00000015,      1,    0x0         }
            ,{DUMMY_NAME_PTR_CNS,            0x00001e98,         0x00005555,      1,    0x0         }
            ,{DUMMY_NAME_PTR_CNS,            0x00001e9c,         0x00055555,      1,    0x0         }
            ,{DUMMY_NAME_PTR_CNS,            0x00001ea0,         0x55555555,      1,    0x1         }
            ,{DUMMY_NAME_PTR_CNS,            0x00001ea4,         0x00000555,      1,    0x1         }
            ,{DUMMY_NAME_PTR_CNS,            0x00001f08,         0x00000033,      1,    0x0         }
            ,{DUMMY_NAME_PTR_CNS,            0x00001f0c,         0x0000004c,      1,    0x0         }
            ,{DUMMY_NAME_PTR_CNS,            0x00001f88,         0x0000000b,      1,    0x0         }
            ,{DUMMY_NAME_PTR_CNS,            0x00001f8c,         0x0000002a,      1,    0x0         }
            ,{DUMMY_NAME_PTR_CNS,            0x00002008,         0x00000006,      1,    0x0         }
            ,{DUMMY_NAME_PTR_CNS,            0x00002088,         0x000000ff,      2,    0x10        }
            ,{DUMMY_NAME_PTR_CNS,            0x0000208C,         0x00000080,      2,    0x10        }
            ,{DUMMY_NAME_PTR_CNS,            0x00002108,         0x0000000a,      1,    0x0         }
            ,{DUMMY_NAME_PTR_CNS,            0x0000210c,         0x0000000a,      1,    0x0         }
            ,{DUMMY_NAME_PTR_CNS,            0x00002188,         0x00000001,      1,    0x0         }
            ,{DUMMY_NAME_PTR_CNS,            0x0000218c,         0x00000007,      1,    0x0         }
            ,{DUMMY_NAME_PTR_CNS,            0x00002208,         0x0000000f,      1,    0x0         }
            ,{DUMMY_NAME_PTR_CNS,            0x00002288,         0x0000000f,      1,    0x0         }
            ,{DUMMY_NAME_PTR_CNS,            0x00002388,         0x000000ff,      ((NUM_PORTS_PER_DP_UNIT+3) * 4),    0x10 }
            ,{DUMMY_NAME_PTR_CNS,            0x00002D88,         0x000000ff,      (NUM_PORTS_PER_DP_UNIT+3),    0x10 }
            ,{DUMMY_NAME_PTR_CNS,            0x00002D8C,         0x0000F800,      (NUM_PORTS_PER_DP_UNIT+3),    0x10 }
            ,{NULL,            0,         0x00000000,      0,    0x0      }
        };
        static SMEM_LINK_LIST_REGISTER_DEFAULT_VALUE_STC list = {myUnit_registersDefaultValueArr,NULL};
        unitPtr->unitDefaultRegistersPtr = &list;

        update_list_register_default_size_to_size(myUnit_registersDefaultValueArr,
            NUM_PORTS_PER_DP_UNIT+1,
            RUNTIME_NUM_PORTS_PER_DP_UNIT+1);


    }
    {/*start of unit sip6_rxDMA[] */

       {/*start of unit configs */
            {/*start of unit rejectConfigs */
                SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->sip6_rxDMA[0].configs.rejectConfigs.rejectPktCommand = 0x00001000;
                SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->sip6_rxDMA[0].configs.rejectConfigs.rejectCPUCode = 0x00001004;

            }/*end of unit rejectConfigs */


            {/*start of unit preIngrPrioritizationConfStatus */
                {/*00007d0+n * 0x4*/
                    GT_U32    n;
                    for(n = 0 ; n <= 3 ; n++) {
                        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->rxDMA[0].globalRxDMAConfigs.preIngrPrioritizationConfStatus.VLANUPPriorityArrayProfile[n] =
                            0x00001080+n * 0x4;
                    }/* end of loop n */
                }/*00007d0+n * 0x4*/
                {/*0000b5c+n*0x4*/
                    GT_U32    n;
                    for(n = 0 ; n <= 3 ; n++) {
                        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->rxDMA[0].globalRxDMAConfigs.preIngrPrioritizationConfStatus.VIDConf[n] =
                            0x000012b0+n*0x4;
                    }/* end of loop n */
                }/*0000b5c+n*0x4*/
                {/*0000d3c+n * 0x4*/
                    GT_U32    n;
                    for(n = 0 ; n <= 3 ; n++) {
                        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->rxDMA[0].globalRxDMAConfigs.preIngrPrioritizationConfStatus.UPDSATagArrayProfile[n] =
                            0x000013c0+n * 0x4;
                    }/* end of loop n */
                }/*0000d3c+n * 0x4*/
                {/*00007f0+m*0x4 + n*0x20*/
                    GT_U32    n,m;
                    for(n = 0 ; n <= 3 ; n++) {
                        for(m = 0 ; m <= 7 ; m++) {
                            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->rxDMA[0].globalRxDMAConfigs.preIngrPrioritizationConfStatus.qoSDSAPriorityArrayProfileSegment[n][m] =
                                0x00001090+m*0x4 + n*0x20;
                        }/* end of loop m */
                    }/* end of loop n */
                }/*00007f0+m*0x4 + n*0x20*/
                {/*0000e74+n*0x4*/
                    GT_U32    n;
                    for(n = 0 ; n <= 3 ; n++) {
                        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->rxDMA[0].globalRxDMAConfigs.preIngrPrioritizationConfStatus.profileTPID[n] =
                            0x000013d0+n*0x4;
                    }/* end of loop n */
                }/*0000e74+n*0x4*/
                SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->rxDMA[0].globalRxDMAConfigs.preIngrPrioritizationConfStatus.preingressPrioritizationEnable = 0x00001c08;
                {/*0000f74+n*0x4*/
                    GT_U32    n;
                    for(n = 0 ; n <= 3 ; n++) {
                        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->rxDMA[0].globalRxDMAConfigs.preIngrPrioritizationConfStatus.VLANEtherTypeConf[n] =
                            0x000013e0+n*0x4;
                    }/* end of loop n */
                }/*0000f74+n*0x4*/
                {/*0000880+n * 0x4*/
                    GT_U32    n;
                    for(n = 0 ; n <= 3 ; n++) {
                        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->rxDMA[0].globalRxDMAConfigs.preIngrPrioritizationConfStatus.MPLSEXPPriorityArrayProfile[n] =
                            0x00001110+n * 0x4;
                    }/* end of loop n */
                }/*0000880+n * 0x4*/
                {/*0000ab4+n*0x4*/
                    GT_U32    n;
                    for(n = 0 ; n <= 1 ; n++) {
                        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->rxDMA[0].globalRxDMAConfigs.preIngrPrioritizationConfStatus.MPLSEtherTypeConf[n] =
                            0x00001258+n*0x4;
                    }/* end of loop n */
                }/*0000ab4+n*0x4*/
                {/*00009fc+n * 0x4*/
                    GT_U32    n;
                    for(n = 0 ; n <= 3 ; n++) {
                        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->rxDMA[0].globalRxDMAConfigs.preIngrPrioritizationConfStatus.MACDAPriorityArrayProfile[n] =
                            0x00001220+n * 0x4;
                    }/* end of loop n */
                }/*00009fc+n * 0x4*/
                {/*0000b34+n *0x4*/
                    GT_U32    n;
                    for(n = 0 ; n <= 3 ; n++) {
                        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->rxDMA[0].globalRxDMAConfigs.preIngrPrioritizationConfStatus.MACDAMask4LsbConf[n] =
                            0x00001290+n *0x4;
                    }/* end of loop n */
                }/*0000b34+n *0x4*/
                {/*0000b48+n*0x4*/
                    GT_U32    n;
                    for(n = 0 ; n <= 3 ; n++) {
                        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->rxDMA[0].globalRxDMAConfigs.preIngrPrioritizationConfStatus.MACDAMask2MsbConf[n] =
                            0x000012a0+n*0x4;
                    }/* end of loop n */
                }/*0000b48+n*0x4*/
                {/*0000af4+n*0x4*/
                    GT_U32    n;
                    for(n = 0 ; n <= 3 ; n++) {
                        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->rxDMA[0].globalRxDMAConfigs.preIngrPrioritizationConfStatus.MACDA4LsbBytesConf[n] =
                            0x00001270+n*0x4;
                    }/* end of loop n */
                }/*0000af4+n*0x4*/
                {/*0000b14+n*0x4*/
                    GT_U32    n;
                    for(n = 0 ; n <= 3 ; n++) {
                        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->rxDMA[0].globalRxDMAConfigs.preIngrPrioritizationConfStatus.MACDA2MsbBytesConf[n] =
                            0x00001280+n*0x4;
                    }/* end of loop n */
                }/*0000b14+n*0x4*/
                {/*0001174+n*0x4*/
                    GT_U32    n;
                    for(n = 0 ; n <= 3 ; n++) {
                        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->rxDMA[0].globalRxDMAConfigs.preIngrPrioritizationConfStatus.latencySensitiveEtherTypeConf[n] =
                            0x000014f0+n*0x4;
                    }/* end of loop n */
                }/*0001174+n*0x4*/
                {/*0000bdc+m*0x4 + n*0x40*/
                    GT_U32    n,m;
                    for(n = 0 ; n <= 3 ; n++) {
                        for(m = 0 ; m <= 15 ; m++) {
                            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->rxDMA[0].globalRxDMAConfigs.preIngrPrioritizationConfStatus.IPv6TCPriorityArrayProfileSegment[n][m] =
                                0x000012c0+m*0x4 + n*0x40;
                        }/* end of loop m */
                    }/* end of loop n */
                }/*0000bdc+m*0x4 + n*0x40*/
                SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->rxDMA[0].globalRxDMAConfigs.preIngrPrioritizationConfStatus.IPv6EtherTypeConf = 0x00001244;
                {/*00008a4+m*0x4 + n*0x40*/
                    GT_U32    n,m;
                    for(n = 0 ; n <= 3 ; n++) {
                        for(m = 0 ; m <= 15 ; m++) {
                            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->rxDMA[0].globalRxDMAConfigs.preIngrPrioritizationConfStatus.IPv4ToSPriorityArrayProfileSegment[n][m] =
                                0x00001120+m*0x4 + n*0x40;
                        }/* end of loop m */
                    }/* end of loop n */
                }/*00008a4+m*0x4 + n*0x40*/
                SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->rxDMA[0].globalRxDMAConfigs.preIngrPrioritizationConfStatus.IPv4EtherTypeConf = 0x00001240;
                {/*0000ad4+n*0x4*/
                    GT_U32    n;
                    for(n = 0 ; n <= 3 ; n++) {
                        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->rxDMA[0].globalRxDMAConfigs.preIngrPrioritizationConfStatus.genericEtherType[n] =
                            0x00001260+n*0x4;
                    }/* end of loop n */
                }/*0000ad4+n*0x4*/
                {/*0000a2c+n*0x4*/
                    GT_U32    n;
                    for(n = 0 ; n <= 3 ; n++) {
                        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->rxDMA[0].globalRxDMAConfigs.preIngrPrioritizationConfStatus.etherTypePriorityArrayProfile[n] =
                            0x00001230+n*0x4;
                    }/* end of loop n */
                }/*0000a2c+n*0x4*/
                {/*0001074+n*0x4*/
                    GT_U32    n;
                    for(n = 0 ; n <= RUNTIME_NUM_PORTS_PER_DP_UNIT ; n++) {  /* manually fixed from : for(n = 0 ; n <= 63 ; n++) { */
                        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->rxDMA[0].globalRxDMAConfigs.preIngrPrioritizationConfStatus.channelPIPConfigReg[n] =
                            0x00013f0+n*0x4;
                    }/* end of loop n */
                }/*0001074+n*0x4*/

                SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->rxDMA[0].globalRxDMAConfigs.preIngrPrioritizationConfStatus.contextId_PIPPrioThresholds0 = 0x0001c00;
                SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->rxDMA[0].globalRxDMAConfigs.preIngrPrioritizationConfStatus.contextId_PIPPrioThresholds1 = 0x0001c04;
            }/*end of unit preIngrPrioritizationConfStatus */


            {/*start of unit dropThresholds */
                SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->sip6_rxDMA[0].configs.dropThresholds.lowPrioDropThreshold0 = 0x00000080;
                SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->sip6_rxDMA[0].configs.dropThresholds.lowPrioDropThreshold1 = 0x00000084;

            }/*end of unit dropThresholds */


            {/*start of unit dataAccumulator */
                SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->sip6_rxDMA[0].configs.dataAccumulator.PBFillLevelThresholds = 0x00000000;
                SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->sip6_rxDMA[0].configs.dataAccumulator.maxTailBC = 0x00000004;

            }/*end of unit dataAccumulator */


            {/*start of unit cutThrough */
                {/*0000038+n*0x4*/
                    GT_U32    n;
                    for(n = 0 ; n <= 3 ; n++) {
                        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->sip6_rxDMA[0].configs.cutThrough.CTGenericConfigs[n] =
                            0x0000010c+n*0x4;
                    }/* end of loop n */
                }/*0000038+n*0x4*/
                {/*0000050+n*0x4*/
                    GT_U32    n;
                    for(n = 0 ; n <= RUNTIME_NUM_PORTS_PER_DP_UNIT ; n++) {
                        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->sip6_rxDMA[0].configs.cutThrough.channelCTConfig[n] =
                            0x00000120+n*0x4;
                    }/* end of loop n */
                }/*0000050+n*0x4*/
                SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->sip6_rxDMA[0].configs.cutThrough.CTGeneralConfig = 0x00000100;
                SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->sip6_rxDMA[0].configs.cutThrough.CTErrorConfig = 0x00000104;
                SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->sip6_rxDMA[0].configs.cutThrough.CTUPEnable = 0x00000108;

            }/*end of unit cutThrough */


            {/*start of unit channelConfig */
                {/*00004a8+n*0x4*/
                    GT_U32    n;
                    for(n = 0 ; n <= RUNTIME_NUM_PORTS_PER_DP_UNIT ; n++) {
                        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->sip6_rxDMA[0].configs.channelConfig.channelToLocalDevSourcePort[n] =
                            0x0000b00+n*0x4;
                    }/* end of loop n */
                }/*00004a8+n*0x4*/
                {/*00005a8+n*0x4*/
                    GT_U32    n;
                    for(n = 0 ; n <= RUNTIME_NUM_PORTS_PER_DP_UNIT ; n++) {
                        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->sip6_rxDMA[0].configs.channelConfig.channelGeneralConfigs[n] =
                            0x0000800+n*0x4;
                    }/* end of loop n */
                }/*00005a8+n*0x4*/

            }/*end of unit channelConfig */


        }/*end of unit configs */

        {/*debug*/
            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->sip6_rxDMA[0].debug.dp_rx_enable_debug_counters = 0x00001D84;
            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->sip6_rxDMA[0].debug.dp_rx_config_debug_counters = 0x00001D80;

            {/*rxIngressDropCounter*/
                SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->sip6_rxDMA[0].debug.rxIngressDropCounter.rx_ingress_drop_count           = 0x00002380;
                SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->sip6_rxDMA[0].debug.rxIngressDropCounter.rx_ingress_drop_count_type_ref  = 0x00002388;
                SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->sip6_rxDMA[0].debug.rxIngressDropCounter.rx_ingress_drop_count_type_mask = 0x0000238C;
            }/*rxIngressDropCounter*/

            {/*rxToCpCounter*/
                SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->sip6_rxDMA[0].debug.rxToCpCounter.rx_to_cp_count           = 0x00002000;
                SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->sip6_rxDMA[0].debug.rxToCpCounter.rx_to_cp_count_type_ref  = 0x00002008;
                SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->sip6_rxDMA[0].debug.rxToCpCounter.rx_to_cp_count_type_mask = 0x0000200C;
            }/*rxToCpCounter*/

            {/*rxCpToRxCounter*/
                SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->sip6_rxDMA[0].debug.rxCpToRxCounter.cp_to_rx_count           = 0x00002080;
                SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->sip6_rxDMA[0].debug.rxCpToRxCounter.cp_to_rx_count_type_ref  = 0x00002088;
                SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->sip6_rxDMA[0].debug.rxCpToRxCounter.cp_to_rx_count_type_mask = 0x0000208C;
            }/*rxCpToRxCounter*/
        }/*debug*/

        {/* interrupts - manually added */
            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->sip6_rxDMA[0].interrupts.rxdma_interrupt_0_cause        = 0x00001C80;
            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->sip6_rxDMA[0].interrupts.rxdma_interrupt_0_mask         = 0x00001C84;
            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->sip6_rxDMA[0].interrupts.rxdma_interrupt_1_cause        = 0x00001C88;
            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->sip6_rxDMA[0].interrupts.rxdma_interrupt_1_mask         = 0x00001C8C;
            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->sip6_rxDMA[0].interrupts.rxdma_interrupt_2_cause        = 0x00001C90;
            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->sip6_rxDMA[0].interrupts.rxdma_interrupt_2_mask         = 0x00001C94;
            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->sip6_rxDMA[0].interrupts.rxdma_interrupt_summary_cause  = 0x00001CA0;
            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->sip6_rxDMA[0].interrupts.rxdma_interrupt_summary_mask   = 0x00001CA4;
        }/* interrupts - manually added */
    }/*end of unit sip6_rxDMA[] */
}

/**
* @internal smemAasUnitTxDma function
* @endinternal
*
* @brief   Allocate address type specific memories
* @param[in] devObjPtr                - pointer to device object.
* @param[in,out] unitPtr                  - pointer to the unit chunk
*/
static void smemAasUnitTxDma
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    INOUT SMEM_UNIT_CHUNKS_STC  * unitPtr
)
{
    /* /Cider/EBU/Seahawk/Seahawk {Seahawk_CC_230515}/Tile/Core/DP/<TXDMA> TXD IP TLU/Units %t/TXD*/
    /*IP: \Cider \EBU-IP \DP \TxDMA IP \TxDMA 10.0 - Seahawk1 \TXD IP {10.0.7} \TXD IP TLU \Units \TXD*/
    /*Mask: \Cider \EBU-IP \DP \TxDMA IP \TxDMA 10.0 - Seahawk1 \TXD IP Seahawk1 {10.0.7}*/

    START_BIND_UNIT_ACTIVE_MEM_MAC(devObjPtr,unitPtr)

    /*SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->sip6_txDMA[0].debug.txd_debug_config*/
    {0x0000800C, SMEM_FULL_MASK_CNS, NULL, 0 , smemFalconActiveWriteToTxDmaEnableDebugCounters,0},

    /* SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->sip6_txDMA[0].TXD_Status.global_status.events_counters.pds_desc_counter */
    {0x00004034, SMEM_FULL_MASK_CNS, NULL, 0 , smemChtActiveWriteToReadOnlyReg,0},

    END_BIND_UNIT_ACTIVE_MEM_MAC(devObjPtr,unitPtr)

    {
        SMEM_CHUNK_BASIC_STC  chunksMem[]=
        {
             {SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC  (0x00000000, 0x00000004)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC  (0x00000040, 0x00000040)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC  (0x00000044, 0x00000310)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC  (0x00000500, 0x0000053C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC  (0x00000580, 0x000005BC)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC  (0x00000600, 0x0000063C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC  (0x00000680, 0x000006BC)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC  (0x00000700, 0x0000073C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC  (0x00000800, 0x0000083C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00001000, (4*(NUM_PORTS_PER_DP_UNIT+3)))}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00001100, (4*(NUM_PORTS_PER_DP_UNIT+3)))}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00001200, (4*(NUM_PORTS_PER_DP_UNIT+3)))}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00001300, (4*(NUM_PORTS_PER_DP_UNIT+3)))}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00001400, (4*(NUM_PORTS_PER_DP_UNIT+3)))}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00001500, (4*(NUM_PORTS_PER_DP_UNIT+3)))}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00001600, (4*(NUM_PORTS_PER_DP_UNIT+3)))}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00001700, (4*(NUM_PORTS_PER_DP_UNIT+3)))}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00001800, (4*(NUM_PORTS_PER_DP_UNIT+3)))}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC  (0x00004000, 0x00004004)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC  (0x00004008, 0x00004028)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC  (0x00004030, 0x00004054)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00004100, (4*(NUM_PORTS_PER_DP_UNIT+3)))}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00004200, (4*(NUM_PORTS_PER_DP_UNIT+3)))}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00004300, (4*(NUM_PORTS_PER_DP_UNIT+3)))}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00004400, (4*(NUM_PORTS_PER_DP_UNIT+3)))}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00004500, (4*(NUM_PORTS_PER_DP_UNIT+3)))}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC  (0x00006000, 0x00006000)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC  (0x00007000, 0x00007004)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC  (0x00008000, 0x00008018)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC  (0x00008020, 0x0000803C)}
        };
        GT_U32  numOfChunks = sizeof(chunksMem)/sizeof(SMEM_CHUNK_BASIC_STC);

        update_mem_chunk_from_size_to_size (chunksMem,numOfChunks,
            4*(NUM_PORTS_PER_DP_UNIT+1),
            4*(RUNTIME_NUM_PORTS_PER_DP_UNIT+1));

        smemInitMemChunk(devObjPtr,chunksMem, numOfChunks, unitPtr);
    }

    {
        static SMEM_REGISTER_DEFAULT_VALUE_STC myUnit_registersDefaultValueArr[] =
        {
             {DUMMY_NAME_PTR_CNS,            0x00000000,         0x00000081,      1,    0x0      }
            ,{DUMMY_NAME_PTR_CNS,            0x00000004,         0x0000003C,      1,    0x0      }
            ,{DUMMY_NAME_PTR_CNS,            0x00000040,         0x8000005B,      1,    0x0      }
            /* arbiter - first 23 slots enable */
            ,{DUMMY_NAME_PTR_CNS,            0x00000044,         0x80000000,      1,    0x0      }
            ,{DUMMY_NAME_PTR_CNS,            0x00000048,         0x80000001,      1,    0x0      }
            ,{DUMMY_NAME_PTR_CNS,            0x0000004C,         0x80000002,      1,    0x0      }
            ,{DUMMY_NAME_PTR_CNS,            0x00000050,         0x80000003,      1,    0x0      }
            ,{DUMMY_NAME_PTR_CNS,            0x00000054,         0x80000004,      1,    0x0      }
            ,{DUMMY_NAME_PTR_CNS,            0x00000058,         0x80000005,      1,    0x0      }
            ,{DUMMY_NAME_PTR_CNS,            0x0000005C,         0x80000006,      1,    0x0      }
            ,{DUMMY_NAME_PTR_CNS,            0x00000060,         0x80000007,      1,    0x0      }
            ,{DUMMY_NAME_PTR_CNS,            0x00000064,         0x80000008,      1,    0x0      }
            ,{DUMMY_NAME_PTR_CNS,            0x00000068,         0x80000009,      1,    0x0      }
            ,{DUMMY_NAME_PTR_CNS,            0x0000006C,         0x8000000A,      1,    0x0      }
            ,{DUMMY_NAME_PTR_CNS,            0x00000070,         0x8000000B,      1,    0x0      }
            ,{DUMMY_NAME_PTR_CNS,            0x00000074,         0x8000000C,      1,    0x0      }
            ,{DUMMY_NAME_PTR_CNS,            0x00000078,         0x8000000D,      1,    0x0      }
            ,{DUMMY_NAME_PTR_CNS,            0x0000007C,         0x8000000E,      1,    0x0      }
            ,{DUMMY_NAME_PTR_CNS,            0x00000080,         0x8000000F,      1,    0x0      }
            ,{DUMMY_NAME_PTR_CNS,            0x00000084,         0x80000010,      1,    0x0      }
            ,{DUMMY_NAME_PTR_CNS,            0x00000088,         0x80000011,      1,    0x0      }
            ,{DUMMY_NAME_PTR_CNS,            0x0000008C,         0x80000012,      1,    0x0      }
            ,{DUMMY_NAME_PTR_CNS,            0x00000090,         0x80000013,      1,    0x0      }
            ,{DUMMY_NAME_PTR_CNS,            0x00000094,         0x80000014,      1,    0x0      }
            ,{DUMMY_NAME_PTR_CNS,            0x00000098,         0x80000015,      1,    0x0      }
            ,{DUMMY_NAME_PTR_CNS,            0x0000009C,         0x80000016,      1,    0x0      }
            /* the next arbiter slots contains zerox */
            /*SDQ Maximum Credits 36,19,11,7,6,4,4,3,3,2,2,2,2,2,2,2 */
            ,{DUMMY_NAME_PTR_CNS,            0x00000500,         0x80000024,      1,    0x0      }
            ,{DUMMY_NAME_PTR_CNS,            0x00000504,         0x80000013,      1,    0x0      }
            ,{DUMMY_NAME_PTR_CNS,            0x00000508,         0x8000000B,      1,    0x0      }
            ,{DUMMY_NAME_PTR_CNS,            0x0000050C,         0x80000007,      1,    0x0      }
            ,{DUMMY_NAME_PTR_CNS,            0x00000510,         0x80000006,      1,    0x0      }
            ,{DUMMY_NAME_PTR_CNS,            0x00000514,         0x80000004,      2,    0x4      }
            ,{DUMMY_NAME_PTR_CNS,            0x0000051C,         0x80000003,      2,    0x4      }
            ,{DUMMY_NAME_PTR_CNS,            0x00000524,         0x80000002,      7,    0x4      }
            /*SDQ Threshold Bytes (both fields) 3024,1596,924,588,504,336,336,252_9_times*/
            ,{DUMMY_NAME_PTR_CNS,            0x00000580,         0x0BD00BD0,      1,    0x0      }
            ,{DUMMY_NAME_PTR_CNS,            0x00000584,         0x063C063C,      1,    0x0      }
            ,{DUMMY_NAME_PTR_CNS,            0x00000588,         0x039C039C,      1,    0x0      }
            ,{DUMMY_NAME_PTR_CNS,            0x0000058C,         0x024C024C,      1,    0x0      }
            ,{DUMMY_NAME_PTR_CNS,            0x00000590,         0x01F801F8,      1,    0x0      }
            ,{DUMMY_NAME_PTR_CNS,            0x00000594,         0x01500150,      2,    0x4      }
            ,{DUMMY_NAME_PTR_CNS,            0x0000059C,         0x00FC00FC,      9,    0x4      }
            /*Maximum Cell Credits (155,363),(78,186),(39,96),(20,51),(20,42),(10,30),(10,24),(4,15),(3,12)_8_times*/
            ,{DUMMY_NAME_PTR_CNS,            0x00000600,         0x009B016B,      1,    0x0      }
            ,{DUMMY_NAME_PTR_CNS,            0x00000604,         0x004E00BA,      1,    0x0      }
            ,{DUMMY_NAME_PTR_CNS,            0x00000608,         0x00270060,      1,    0x0      }
            ,{DUMMY_NAME_PTR_CNS,            0x0000060C,         0x00140033,      1,    0x0      }
            ,{DUMMY_NAME_PTR_CNS,            0x00000610,         0x0014002A,      1,    0x0      }
            ,{DUMMY_NAME_PTR_CNS,            0x00000614,         0x000A001E,      1,    0x0      }
            ,{DUMMY_NAME_PTR_CNS,            0x00000618,         0x000A0018,      1,    0x0      }
            ,{DUMMY_NAME_PTR_CNS,            0x0000061C,         0x0004000F,      1,    0x0      }
            ,{DUMMY_NAME_PTR_CNS,            0x00000620,         0x0003000C,      8,    0x4      }
            /*Maximum Desc Credits 13,7,4,3,2_3_times,1_9_times*/
            ,{DUMMY_NAME_PTR_CNS,            0x00000680,         0x0000000D,      1,    0x0      }
            ,{DUMMY_NAME_PTR_CNS,            0x00000684,         0x00000007,      1,    0x0      }
            ,{DUMMY_NAME_PTR_CNS,            0x00000688,         0x00000004,      1,    0x0      }
            ,{DUMMY_NAME_PTR_CNS,            0x0000068C,         0x00000003,      1,    0x0      }
            ,{DUMMY_NAME_PTR_CNS,            0x00000690,         0x00000002,      3,    0x4      }
            ,{DUMMY_NAME_PTR_CNS,            0x0000069C,         0x00000001,      9,    0x4      }
            /*Inter Cell Rate Limiter: high 5042,2521,1261,631,316,158,76,64,32,16,7_6_times  Low 0x100*/
            ,{DUMMY_NAME_PTR_CNS,            0x00000700,         0x13B20100,      1,    0x0      }
            ,{DUMMY_NAME_PTR_CNS,            0x00000704,         0x09D90100,      1,    0x0      }
            ,{DUMMY_NAME_PTR_CNS,            0x00000708,         0x04F00100,      1,    0x0      }
            ,{DUMMY_NAME_PTR_CNS,            0x0000070C,         0x02770100,      1,    0x0      }
            ,{DUMMY_NAME_PTR_CNS,            0x00000710,         0x013C0100,      1,    0x0      }
            ,{DUMMY_NAME_PTR_CNS,            0x00000714,         0x009E0100,      1,    0x0      }
            ,{DUMMY_NAME_PTR_CNS,            0x00000718,         0x004C0100,      1,    0x0      }
            ,{DUMMY_NAME_PTR_CNS,            0x0000071C,         0x00400100,      1,    0x0      }
            ,{DUMMY_NAME_PTR_CNS,            0x00000720,         0x00200100,      1,    0x0      }
            ,{DUMMY_NAME_PTR_CNS,            0x00000724,         0x00100100,      1,    0x0      }
            ,{DUMMY_NAME_PTR_CNS,            0x00000728,         0x00070100,      6,    0x4      }
            /*Inter Word Rate Limiter: high 9780,4890,2445,1223,612,306,147,123,62,31,13_6_times Low 0x100 */
            ,{DUMMY_NAME_PTR_CNS,            0x00000800,         0x26340100,      1,    0x0      }
            ,{DUMMY_NAME_PTR_CNS,            0x00000804,         0x131A0100,      1,    0x0      }
            ,{DUMMY_NAME_PTR_CNS,            0x00000808,         0x09900100,      1,    0x0      }
            ,{DUMMY_NAME_PTR_CNS,            0x0000080C,         0x04C70100,      1,    0x0      }
            ,{DUMMY_NAME_PTR_CNS,            0x00000810,         0x02640100,      1,    0x0      }
            ,{DUMMY_NAME_PTR_CNS,            0x00000814,         0x01320100,      1,    0x0      }
            ,{DUMMY_NAME_PTR_CNS,            0x00000818,         0x00930100,      1,    0x0      }
            ,{DUMMY_NAME_PTR_CNS,            0x0000081C,         0x007B0100,      1,    0x0      }
            ,{DUMMY_NAME_PTR_CNS,            0x00000820,         0x003E0100,      1,    0x0      }
            ,{DUMMY_NAME_PTR_CNS,            0x00000824,         0x001F0100,      1,    0x0      }
            ,{DUMMY_NAME_PTR_CNS,            0x00000828,         0x000D0100,      6,    0x4      }
            /*TXD speed profile*/
            ,{DUMMY_NAME_PTR_CNS,            0x00001000,         0x00000004,     23,    0x4      }
            /*TXD Channel global config */
            ,{DUMMY_NAME_PTR_CNS,            0x00001100,         0x00000002,     23,    0x4      }
            /*Rate Limiter Enable*/
            ,{DUMMY_NAME_PTR_CNS,            0x00001200,         0x0000000F,     23,    0x4      }
            /*Inter Packet Gap Configuration*/
            ,{DUMMY_NAME_PTR_CNS,            0x00001300,         0x18000000,     23,    0x4      }
            /*Inter Packet Rate Limiter*/
            ,{DUMMY_NAME_PTR_CNS,            0x00001400,         0x04CF0100,     23,    0x4      }
            /*iner Packet Rate Max Tokens*/
            ,{DUMMY_NAME_PTR_CNS,            0x00001500,         0x000000C0,     23,    0x4      }
            /*Rate-Limit speedup*/
            ,{DUMMY_NAME_PTR_CNS,            0x00001600,         0x00C000A0,     23,    0x4      }
            /*Rate-Limit Granularity Fix*/
            ,{DUMMY_NAME_PTR_CNS,            0x00001700,         0x00010001,     23,    0x4      }
            /*DPWIP*/
            ,{DUMMY_NAME_PTR_CNS,            0x00001800,         0xFFFF0000,     23,    0x4      }
            /*TXD is Idle*/
            ,{DUMMY_NAME_PTR_CNS,            0x00004000,         0x00000001,      1,    0x0      }
            /*TXD Metal Fix Register*/
            ,{DUMMY_NAME_PTR_CNS,            0x00006000,         0xFFFF0000,      1,    0x0      }
            /*TXD Debug Configuration*/
            ,{DUMMY_NAME_PTR_CNS,            0x00008004,         0x00000801,      1,    0x0      }
            /*Enable or Disable interface*/
            ,{DUMMY_NAME_PTR_CNS,            0x00008018,         0x00000007,      1,    0x0      }
            ,{NULL,            0,         0x00000000,      0,    0x0      }
        };
        static SMEM_LINK_LIST_REGISTER_DEFAULT_VALUE_STC list = {myUnit_registersDefaultValueArr,NULL};
        unitPtr->unitDefaultRegistersPtr = &list;

        update_list_register_default_size_to_size(myUnit_registersDefaultValueArr,
            NUM_PORTS_PER_DP_UNIT+1,
            RUNTIME_NUM_PORTS_PER_DP_UNIT+1);
    }

    {/*start of unit sip6_txDMA[] */
        {/*start of unit globalConfigs */
            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->sip6_txDMA[0].configs.globalConfigs.txDMAGlobalConfig = 0x00000000;
        }/*end of unit globalConfigs */

        {/*start of unit speedProfileConfigurations */
            {/*0x00000500  + p*0x4*/
                GT_U32    p;
                for(p = 0 ; p < AAS_MAX_PROFILE_CNS; p++) {
                    SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->sip6_txDMA[0].configs.speedProfileConfigs.sdqMaxCredits[p] =
                        0x00000500  + p*0x4;
                    }/* end of loop p */
            }/*0x00000500  + p*0x4*/
            {/*0x00000580 + p*0x4*/
                GT_U32    p;
                for(p = 0 ; p < AAS_MAX_PROFILE_CNS; p++) {
                    SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->sip6_txDMA[0].configs.speedProfileConfigs.sdqThresholdBytes[p] =
                        0x00000580 + p*0x4;
                    }/* end of loop p */
            }/*0x00000580 + p*0x4*/
            {/*0x00000600 + p*0x4*/
                GT_U32    p;
                for(p = 0 ; p < AAS_MAX_PROFILE_CNS; p++) {
                    SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->sip6_txDMA[0].configs.speedProfileConfigs.maxCellsCredits[p] =
                        0x00000600 + p*0x4;
                    }/* end of loop p */
            }/*0x00000600 + p*0x4*/
            {/*0x00000700 + p*0x4*/
                GT_U32    p;
                for(p = 0 ; p < AAS_MAX_PROFILE_CNS; p++) {
                  SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->sip6_txDMA[0].configs.speedProfileConfigs.interCellRateLimiter[p] =
                        0x00000700 + p*0x4;
                    }/* end of loop p */
            }/*0x00000700 + p*0x4*/

        }/*end of unit speedProfileConfigurations */

        {/*start of unit channelConfigs */
            {/*0x00001000  + p*0x4*/
                GT_U32    p;
                for(p = 0 ; p <= RUNTIME_NUM_PORTS_PER_DP_UNIT; p++) { /* manually fixed from : for(p = 0 ; p < 64 ; n++) { */
                    SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->sip6_txDMA[0].configs.channelConfigs.speedProfile[p] =
                        0x00001000 +p*0x4;
                }/* end of loop n */
            }/*0x00001000  + p*0x4*/
        }/*end of unit channelConfigs */

        {/* manually added */
            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->sip6_txDMA[0].debug.txd_debug_config      = 0x00008004;
            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->sip6_txDMA[0].debug.enable_debug_Counters = 0x0000800C;

            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->sip6_txDMA[0].TXD_Status.global_status.events_counters.pds_desc_counter = 0x00004034;
        }

        {/* interrupts - manually added */
            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->sip6_txDMA[0].interrupts.txd_interrupt_cause = 0x00007000;
            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->sip6_txDMA[0].interrupts.txd_interrupt_mask  = 0x00007004;
        }/* interrupts - manually added */
    }/*end of unit sip6_txDMA[] */
}

/**
* @internal smemAasUnitTxFifo function
* @endinternal
*
* @brief   Allocate address type specific memories
*
* @param[in] devObjPtr                - pointer to device object.
* @param[in,out] unitPtr                  - pointer to the unit chunk
*/
static void smemAasUnitTxFifo
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    INOUT SMEM_UNIT_CHUNKS_STC  * unitPtr
)
{
    /* /Cider/EBU/Seahawk/Seahawk {Seahawk_CC_230515}/Tile/Core/DP/<TXFIFO> TXF TLU/Units %t/TXF*/
    /*IP: \Cider \EBU-IP \DP \TxFIFO IP \TxFIFO 10.0 - Seahawk1 \TXF IP {10.0.6} \TXF TLU \Units \TXF*/
    /*Mask: \Cider \EBU-IP \DP \TxFIFO IP \TxFIFO 10.0 - Seahawk1 \TXF IP SeaHawk {10.0.6}*/
    {
        SMEM_CHUNK_BASIC_STC  chunksMem[]=
        {
             {SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000000, 0x00000000)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000600, 0x0000062C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000800, 0x0000082C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000A00, 0x00000A2C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00001000, (4*(NUM_PORTS_PER_DP_UNIT+3)))}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00001100, (4*(NUM_PORTS_PER_DP_UNIT+3)))}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00002000, 0x00002000)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00003000, 0x00003000)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00004000, 0x00004004)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00005000, 0x0000500C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00005100, 0x0000510C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00005180, 0x0000519C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00005280, 0x00005290)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00005300, 0x00005304)}

        };
        GT_U32  numOfChunks = sizeof(chunksMem)/sizeof(SMEM_CHUNK_BASIC_STC);

        update_mem_chunk_from_size_to_size (chunksMem,numOfChunks,
            4*(NUM_PORTS_PER_DP_UNIT+1),
            4*(RUNTIME_NUM_PORTS_PER_DP_UNIT+1));

        smemInitMemChunk(devObjPtr,chunksMem, numOfChunks, unitPtr);
    }

    {
        static SMEM_REGISTER_DEFAULT_VALUE_STC myUnit_registersDefaultValueArr[] =
        {
             {DUMMY_NAME_PTR_CNS,            0x00000000,         0x0000002D,      1,    0x0  }
            ,{DUMMY_NAME_PTR_CNS,            0x00000600,         0x00000010,     12,    0x4  }
            ,{DUMMY_NAME_PTR_CNS,            0x00001000,         0x00000003,      1,    0x0  }
            ,{DUMMY_NAME_PTR_CNS,            0x00001004,         0x00000008,      (NUM_PORTS_PER_DP_UNIT+2),    0x4  }
            ,{DUMMY_NAME_PTR_CNS,            0x00003000,         0xffff0000,      1,    0x0  }
            ,{DUMMY_NAME_PTR_CNS,            0x00005100,         0x0000001f,      1,    0x0  }


            ,{NULL,            0,         0x00000000,      0,    0x0      }
        };
        static SMEM_LINK_LIST_REGISTER_DEFAULT_VALUE_STC list = {myUnit_registersDefaultValueArr,NULL};
        unitPtr->unitDefaultRegistersPtr = &list;

        update_list_register_default_size_to_size(myUnit_registersDefaultValueArr,
            NUM_PORTS_PER_DP_UNIT+1,
            RUNTIME_NUM_PORTS_PER_DP_UNIT+1);
    }
    {/*start of unit sip6_txFIFO[] */
        {/*start of unit globalConfigs */
            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->sip6_txFIFO[0].configs.globalConfigs.globalConfig1 = 0x00000000;
        }/*end of unit globalConfigs */

        {/*start of unit debug*/
            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->sip6_txFIFO[0].debug.statusBadAddr = 0x00005000;
        }/*end of unit debug*/

        {/* interrupts - manually added */
            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->sip6_txFIFO[0].interrupts.txf_interrupt_cause = 0x00004000;
            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->sip6_txFIFO[0].interrupts.txf_interrupt_mask = 0x00004004;
        }/* interrupts - manually added */

     }/*end of unit sip6_txFIFO[] */
}

/**
* @internal smemAasUnitPacketBuffer_pbCounter function
* @endinternal
 *
*/
static void smemAasUnitPacketBuffer_pbCounter
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    INOUT SMEM_UNIT_CHUNKS_STC  * unitPtr
)
{
    /* pbCounter*/
    /* /Cider/EBU/Seahawk/Seahawk {Seahawk_CC_230515}/Tile/Core/PB/<PB_COUNTER> pbc/PBC*/
    /*IP: \Cider \EBU-IP \Packet Buffer \PBC \PBC {PB_shk1_20230112} \pbc \PBC*/
    /*Mask: \Cider \EBU-IP \Packet Buffer \PBC \PBC {PB_shk1_20230112}*/
    {
        SMEM_CHUNK_BASIC_STC  chunksMem[]=
        {
            {SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x0000000C, 0x00000198)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001000, 0x0000105C)} /*debug ring moved from PB_CENTER*/
        };
        GT_U32  numOfChunks = sizeof(chunksMem)/sizeof(SMEM_CHUNK_BASIC_STC);

        smemInitMemChunk(devObjPtr, chunksMem, numOfChunks, unitPtr);
    }
}

/**
* @internal smemAasUnitPacketBuffer_smbWriteArbiter function
* @endinternal
 *
*/
static void smemAasUnitPacketBuffer_smbWriteArbiter
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    INOUT SMEM_UNIT_CHUNKS_STC  * unitPtr
)
{
    /* smbWriteArbiter */
    /* /Cider/EBU/Seahawk/Seahawk {Seahawk_CC_230515}/Tile/Core/PB/<WA> wa/WA %i*/
    /*IP: \Cider \EBU-IP \Packet Buffer \WA \WA 9.0 - Seahawk1 \WA {PB_shk1_20230112} \wa \WA*/
    /*Mask: \Cider \EBU-IP \Packet Buffer \WA \WA 9.0 - Seahawk1 \WA {PB_shk1_20230112}*/
    {
        SMEM_CHUNK_BASIC_STC  chunksMem[]=
        {
             {SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000004, 0x0000004C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000100, 0x00000114)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000160, 0x00000164)}
        };
        GT_U32  numOfChunks = sizeof(chunksMem)/sizeof(SMEM_CHUNK_BASIC_STC);

        smemInitMemChunk(devObjPtr, chunksMem, numOfChunks, unitPtr);
    }
}

/**
* @internal smemAasUnitPacketBuffer_packetWrite function
* @endinternal
 *
*/
static void smemAasUnitPacketBuffer_packetWrite
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    INOUT SMEM_UNIT_CHUNKS_STC  * unitPtr
)
{
    /* gpcPacketWrite */
    /* /Cider/EBU/Seahawk/Seahawk {Seahawk_CC_230515}/Tile/Core/PB/<GPC_PACKET_WRITE> gpw/GPW %i*/
    /*IP: \Cider \EBU-IP \Packet Buffer \GPW \GPW 9.0 - Seahawk1 \GPW {PB_shk1_20230425} \gpw \GPW*/
    /*Mask: \Cider \EBU-IP \Packet Buffer \GPW \GPW 9.0 - Seahawk1 \GPW {PB_shk1_20230425}*/
    {
        SMEM_CHUNK_BASIC_STC  chunksMem[]=
        {
            /* registers space */
              {SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000000, 0x00000020)}
             ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000040, 0x00000040)}
             ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000100, 0x0000015C)}
             ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000200, 0x00000208)}
             ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000300, 0x00000308)}
        };
        GT_U32  numOfChunks = sizeof(chunksMem)/sizeof(SMEM_CHUNK_BASIC_STC);

        smemInitMemChunk(devObjPtr, chunksMem, numOfChunks, unitPtr);
    }
}

/**
* @internal smemAasUnitPacketBuffer_packetRead function
* @endinternal
 *
*/
static void smemAasUnitPacketBuffer_packetRead
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    INOUT SMEM_UNIT_CHUNKS_STC  * unitPtr
)
{
    /* gpcPacketRead */
    /* /Cider/EBU/Seahawk/Seahawk {Seahawk_CC_230515}/Tile/Core/PB/<GPR> gpr/GPR %gpr*/
    /*IP: \Cider \EBU-IP \Packet Buffer \GPR HP \GPR 9.0 - Seahawk1 \GPR {PB_shk1_20230425} \gpr \GPR*/
    /*Mask: \Cider \EBU-IP \Packet Buffer \GPR HP \GPR 9.0 - Seahawk1 \GPR {PB_shk1_20230425}*/

    {
        static SMEM_CHUNK_BASIC_STC  chunksMem[]=
        {
            /* Configuration */
             {SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000000, 0x00000010)}
             /* Packet Count Configuration */
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000020, 0x00000024)}
            /*  Arbiter Configuration */
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000100, 0x00000100)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000200, 0x000004D4)}
            /*  Channel %n Configuration */
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000500, 0x0000055C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000600, 0x0000065C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000700, 0x0000075C)}
            /* Speed Profile Configurations */
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000900, 0x0000092C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000A00, 0x00000A2C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000B00, 0x00000B2C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000C00, 0x00000C2C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000D00, 0x00000D2C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000E00, 0x00000E2C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000F00, 0x00000F2C)}
            /* Debug */
            /*  FIFO Status 0 Channel */
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001000, 0x0000105C)}
            /*  FIFO Status 1 Channel */
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001100, 0x0000115C)}
            /* Debug */
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001200, 0x00001220)}
            /*Credit Counters*/
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001260, 0x00001290)}
            /* Latency Statistics */
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001294, 0x000012C8)}
            /*  Interrupts */
            /*  Interrupt Channel %i Cause */
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001300, 0x0000135C)}
            /*  Interrupt Channel %i Mask */
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001400, 0x0000145C)}
            /*  Interrupts */
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001500, 0x00001538)}
        };
        static GT_U32  numOfChunks = sizeof(chunksMem)/sizeof(SMEM_CHUNK_BASIC_STC);

        smemInitMemChunk(devObjPtr, chunksMem, numOfChunks, unitPtr);
    }
}

/**
* @internal smemAasUnitPacketBuffer_cellRead function
* @endinternal
 *
*/
static void smemAasUnitPacketBuffer_cellRead
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    INOUT SMEM_UNIT_CHUNKS_STC  * unitPtr
)
{
    /* gpcCellRead */
    /* /Cider/EBU/Seahawk/Seahawk {Seahawk_CC_230515}/Tile/Core/PB/<GCR> gcr/GCR %i*/
    /*IP: \Cider \EBU-IP \Packet Buffer \GCR \GCR {PB_shk1_20230112} \gcr \GCR*/
    /*Mask: \Cider \EBU-IP \Packet Buffer \GCR \GCR {PB_shk1_20230112}*/
    {
        SMEM_CHUNK_BASIC_STC  chunksMem[]=
        {
            /*Configuration*/
             {SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000000, 0x0000000C)}
            /*Debug*/
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000020, 0x00000028)}
            /*Debug. Latency Statistics*/
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x0000002C, 0x00000060)}
            /*Interrupts*/
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000000A0, 0x000000A8)}
        };
        GT_U32  numOfChunks = sizeof(chunksMem)/sizeof(SMEM_CHUNK_BASIC_STC);

        smemInitMemChunk(devObjPtr, chunksMem, numOfChunks, unitPtr);
    }
}

/**
* @internal smemAasUnitPacketBuffer_npmMc function
* @endinternal
 *
*/
static void smemAasUnitPacketBuffer_npmMc
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    INOUT SMEM_UNIT_CHUNKS_STC  * unitPtr
)
{
    /* npmMc */
    /* /Cider/EBU/Seahawk/Seahawk {Seahawk_CC_230515}/Tile/Core/PB/<NPM> npm/NPM %npm*/
    /*IP: \Cider \EBU-IP \Packet Buffer \NPM \NPM 9.0 - Seahawk1 \NPM {PB_shk1_20230112} \npm \NPM*/
    /*Mask: \Cider \EBU-IP \Packet Buffer \NPM \NPM 9.0 - Seahawk1 \NPM {PB_shk1_20230112}*/
    {
        SMEM_CHUNK_BASIC_STC  chunksMem[]=
        {
             /*General*/
              {SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000000, 0x0000000C)}
             /*Interrupt*/
             ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000100, 0x00000158)}
             /*Free Lists*/
             ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000200, 0x00000200)}
             ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000210, 0x0000021C)}
             /*Memory Units*/
             ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000300, 0x00000300)}
             /*Reference Counters*/
             ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000400, 0x00000400)}
             ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000410, 0x0000041C)}
             /*debug*/
             ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000508, 0x00000508)}
             ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x0000052C, 0x0000052C)}
             /* RAM Access. Reference Counters RAM*/
             ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001000, 0x00001000)}
             ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001010, 0x00001010)}
             ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001020, 0x00001020)}
             /* RAM Access. Next-Pointer Payload RAM*/
             ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001100, 0x00001100)}
             ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001110, 0x00001110)}
             /* RAM Access. Free List FIFO Buffer RAM*/
             ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001200, 0x00001200)}
             ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001210, 0x00001210)}
        };
        GT_U32  numOfChunks = sizeof(chunksMem)/sizeof(SMEM_CHUNK_BASIC_STC);

        smemInitMemChunk(devObjPtr, chunksMem, numOfChunks, unitPtr);
    }
}

/**
* @internal smemAasUnitPacketBuffer_sbmMc function
* @endinternal
 *
*/
static void smemAasUnitPacketBuffer_sbmMc
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    INOUT SMEM_UNIT_CHUNKS_STC  * unitPtr
)
{
    /* sbmMc */
    /* /Cider/EBU/Seahawk/Seahawk {Seahawk_CC_230515}/Tile/Core/PB/<SMB> smb/SMB %smb*/
    /*IP: \Cider \EBU-IP \Packet Buffer \SMB \SMB 9.0 - Seahawk1 \SMB {PB_shk1_20230112} \smb \SMB*/
    /*Mask: \Cider \EBU-IP \Packet Buffer \SMB \SMB 9.0 - Seahawk1 \SMB {PB_shk1_20230112}*/
    {
        SMEM_CHUNK_BASIC_STC  chunksMem[]=
        {
            /* registers space */
              {SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000000, 0x00000018)}
             ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x0000002C, 0x0000002C)}
             ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000030, 0x00000038)}
             ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000040, 0x00000040)}
             ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000050, 0x0000006C)}
             ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000070, 0x00000074)}
             ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000080, 0x0000008C)}
             ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000000A0, 0x000000AC)}
             ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000000C0, 0x000000CC)}
             ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000100, 0x00000104)}
             ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000110, 0x0000011C)}
             ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000120, 0x00000124)}
             ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000130, 0x00000134)}
             ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000140, 0x00000144)}
             ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000150, 0x00000154)}
             ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000160, 0x00000168)}
        };
        GT_U32  numOfChunks = sizeof(chunksMem)/sizeof(SMEM_CHUNK_BASIC_STC);

        smemInitMemChunk(devObjPtr, chunksMem, numOfChunks, unitPtr);
    }
}

/**
* @internal smemAasUnitPcaArbiter function
* @endinternal
*
* @brief   Allocate address type specific memories -- for the PCA Arbiter
*/
static void smemAasUnitPcaArbiter
(
    IN SKERNEL_DEVICE_OBJECT *devObjPtr,
    IN SMEM_UNIT_CHUNKS_STC  *unitPtr
)
{
    /* /Cider/EBU/Seahawk/Seahawk {Seahawk_CC_230515}/Tile/Core/PCA/<PizArb> PizArb IP TLU/pzarb %g*/
    /*IP: \Cider \EBU-IP \PCA \PizArb \PizArb 3.0 \PizArb {SHK-22chid-81rpid-CC2_070523} \PizArb IP TLU \pzarb*/
    /*Mask: \Cider \EBU-IP \PCA \PizArb \PizArb 3.0 \PizArb Seahawk1 22-CH {SHK-22chid-CC2_070523}*/

    SMEM_CHUNK_BASIC_STC  chunksMem[]=
    {
         {SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000000, 0x00000058)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000100, 0x00000158)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000200, 0x000005FC)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000600, 0x000009FC)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000A00, 0x00000A14)}
    };

    GT_U32  numOfChunks = sizeof(chunksMem)/sizeof(SMEM_CHUNK_BASIC_STC);
    smemInitMemChunk(devObjPtr,chunksMem, numOfChunks, unitPtr);

    {
        static SMEM_REGISTER_DEFAULT_VALUE_STC myUnit_registersDefaultValueArr[] =
        {
            /* Pizza arbiter slot configuration */
             {DUMMY_NAME_PTR_CNS,            0x00000200,         0x0000001F,      256,    0x4      }
            ,{DUMMY_NAME_PTR_CNS,            0x00000600,         0x0000001F,      256,    0x4      }
            /* Pizza arbiter control */
            ,{DUMMY_NAME_PTR_CNS,            0x00000A0C,         0x000000FF,        1,    0x0      }
            ,{DUMMY_NAME_PTR_CNS,            0x00000A10,         0x0000FFFF,        1,    0x0      }

            ,{NULL,            0,         0x00000000,      0,    0x0      }
        };
        static SMEM_LINK_LIST_REGISTER_DEFAULT_VALUE_STC list = {myUnit_registersDefaultValueArr,NULL};
        unitPtr->unitDefaultRegistersPtr = &list;
    }
}

/**
* @internal smemAasUnitPcaSffDefaultLLs function
* @endinternal
*
* @brief   default LLs registers values for PCA Sff
*/
static GT_U32 smemAasUnitPcaSffDefaultLLs
(
    IN struct SMEM_REGISTER_DEFAULT_VALUE_STRUCT *defRegsPtr,
    IN GT_U32 repCount
)
{
    GT_UNUSED_PARAM (defRegsPtr);
    return repCount;
}

/**
* @internal smemAasUnitPcaSff function
* @endinternal
*
* @brief   Allocate address type specific memories -- for the PCA Sff
*/
static void smemAasUnitPcaSff
(
    IN SKERNEL_DEVICE_OBJECT *devObjPtr,
    IN SMEM_UNIT_CHUNKS_STC  *unitPtr
)
{
    /* /Cider/EBU/Seahawk/Seahawk {Seahawk_CC_230515}/Tile/Core/PCA/<SFF> SFF IP TLU/Units %g*/
    /*IP: \Cider \EBU-IP \PCA \SFF IP \SFF 3.0 \SFF IP {SHK-22ch-CC-2} \SFF IP TLU \Units*/
    /*Mask: \Cider \EBU-IP \PCA \SFF IP \SFF 3.0 \SFF IP Seahawk 22-CH {SHK-22ch-CC-2}*/
    SMEM_CHUNK_BASIC_STC  chunksMem[]=
    {
        /*Channel - Channel config*/
         {SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000600, 0x00000654)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000800, 0x00000854)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000A00, 0x00000DFC)} /* real 176 entries, memory for 256 */
        /*Chan Interrupt*/
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000200, 0x00000254)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000400, 0x00000454)}
        /*Chan Statistics*/
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001800, 0x00001854)}
        /*Chan Status*/
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001200, 0x00001254)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001400, 0x00001454)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001600, 0x00001654)}
        /*Glob Config*/
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000000, 0x00000000)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000008, 0x00000008)}
        /*Glob Interrupts*/
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000010, 0x00000014)}
        /*Glob Status*/
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000018, 0x00000018)}
        /*SFF Interrupt Summary*/
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000020, 0x00000024)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000030, 0x00000030)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000040, 0x00000040)}
        /*Selected CHID Statistics*/
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000060, 0x00000060)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000070, 0x000000B4)}
    };

    GT_U32  numOfChunks = sizeof(chunksMem)/sizeof(SMEM_CHUNK_BASIC_STC);
    smemInitMemChunk(devObjPtr,chunksMem, numOfChunks, unitPtr);

    {
        static SMEM_REGISTER_DEFAULT_VALUE_STC myUnit_registersDefaultValueArr[] =
        {
            /* Channeel Control Enable */
             {DUMMY_NAME_PTR_CNS,            0x00000600,         0x00000000,      22,    0x4      } /* diasable statistics */
            /* Channel Control Configuration - zeros*/
            /* LLs */
            ,{DUMMY_NAME_PTR_CNS,            0x00000A00,         0x00000000,      128,   0x4, 0,0, 0,0, &smemAasUnitPcaSffDefaultLLs}
            /* Channel Occupancy staistics */
            ,{DUMMY_NAME_PTR_CNS,            0x00001800,         0x00003F00,      22,    0x4      }

            ,{NULL,            0,         0x00000000,      0,    0x0      }
        };
        static SMEM_LINK_LIST_REGISTER_DEFAULT_VALUE_STC list = {myUnit_registersDefaultValueArr,NULL};
        unitPtr->unitDefaultRegistersPtr = &list;
    }
}

/**
* @internal smemAasUnitPcaMacsecExt function
* @endinternal
*
* @brief   Allocate address type specific memories -- for the PCA MACSEC Extension
*/
static void smemAasUnitPcaMacsecExt
(
    IN SKERNEL_DEVICE_OBJECT *devObjPtr,
    IN SMEM_UNIT_CHUNKS_STC  *unitPtr
)
{
    /* /Cider/EBU/Seahawk/Seahawk {Seahawk_CC_230515}/Tile/Core/PCA/<MACSEC> MACSEC Wrapper IP TLU/Units %g %i %j*/
    /*IP:  \Cider \EBU-IP \PCA \MACSEC Wrapper IP \MACSEC Wrapper IP 3.0 \MACSEC Wrapper IP {CC2_070523} \MACSEC Wrapper IP TLU \Units*/
    /*Mask: \Cider \EBU-IP \PCA \MACSEC Wrapper IP \MACSEC Wrapper IP 3.0 \MACSEC Wrapper IP Seahawk1 22-CH {CC2_070523}*/
    SMEM_CHUNK_BASIC_STC  chunksMem[]=
    {
        /*SDB Debug Monitor Pre MacSec*/
         {SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000000, 0x0000001C)}
        /*SDB Debug Monitor Post MacSec*/
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000100, 0x0000011C)}
        /*MacSec Error Handler*/
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000200, 0x00000208)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x0000020C, 0x00000288)}
        /*MacSec General*/
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000300, 0x00000324)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x0000035C, 0x000003C4)}
        /*MacSec Interrupts*/
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000500, 0x00000514)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000528, 0x00000534)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000548, 0x0000054C)}
    };

    GT_U32  numOfChunks = sizeof(chunksMem)/sizeof(SMEM_CHUNK_BASIC_STC);
    smemInitMemChunk(devObjPtr,chunksMem, numOfChunks, unitPtr);
}

/**
* @internal smemAasUnitPcaBrgShmIngr function
* @endinternal
*
* @brief   Allocate address type specific memories -- for the PCA SHM Ingress
*/
static void smemAasUnitPcaBrgShmIngr
(
    IN SKERNEL_DEVICE_OBJECT *devObjPtr,
    IN SMEM_UNIT_CHUNKS_STC  *unitPtr
)
{
    /* /Cider/EBU/Seahawk/Seahawk {Seahawk_CC_230515}/Tile/Core/PCA/<SHMI> INGSHM/INGSHM registers %g*/
    /*IP: \Cider \EBU-IP \PCA \SHM_ING \SHM ING 3.0 \SHM ING {SHM ING Seahawk1 FE 82-CH {230423}} \INGSHM \INGSHM registers*/
    /*Mask: \Cider \EBU-IP \PCA \SHM_ING \SHM ING 3.0 \SHM ING Seahawk1 22-CH {SHM ING Seahawk1 22-CH CC 230423}*/
    SMEM_CHUNK_BASIC_STC  chunksMem[]=
    {
        /*Global interrupts*/
         {SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000000, 0x0000000C)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000020, 0x00000028)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000040, 0x00000048)}
        /*Global config*/
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000060, 0x00000070)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000080, 0x000000BC)}
        /*channel config*/
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000100, 0x0000039C)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000500, 0x0000079C)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000900, 0x00000B9C)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001100, 0x0000139C)}
        /*channel statistics*/
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00002100, 0x0000239C)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00002900, 0x00002B9C)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00003100, 0x0000339C)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00003900, 0x00003B9C)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00004100, 0x0000439C)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00004900, 0x00004B9C)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00005100, 0x0000539C)}
        /*channel Interrupts*/
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00006100, 0x00006254)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00006500, 0x00006654)}
    };

    GT_U32  numOfChunks = sizeof(chunksMem)/sizeof(SMEM_CHUNK_BASIC_STC);
    smemInitMemChunk(devObjPtr,chunksMem, numOfChunks, unitPtr);

    {
        static SMEM_REGISTER_DEFAULT_VALUE_STC myUnit_registersDefaultValueArr[] =
        {
             {DUMMY_NAME_PTR_CNS,            0x00000100,         0x00007F00,      1,    0x0      }
            ,{DUMMY_NAME_PTR_CNS,            0x00000104,         0x00017F00,      1,    0x0      }
            ,{DUMMY_NAME_PTR_CNS,            0x00000108,         0x00027F00,      1,    0x0      }
            ,{DUMMY_NAME_PTR_CNS,            0x0000010C,         0x00037F00,      1,    0x0      }
            ,{DUMMY_NAME_PTR_CNS,            0x00000110,         0x00047F00,      1,    0x0      }
            ,{DUMMY_NAME_PTR_CNS,            0x00000114,         0x00057F00,      1,    0x0      }
            ,{DUMMY_NAME_PTR_CNS,            0x00000118,         0x00067F00,      1,    0x0      }
            ,{DUMMY_NAME_PTR_CNS,            0x0000011C,         0x00077F00,      1,    0x0      }
            ,{DUMMY_NAME_PTR_CNS,            0x00000120,         0x00087F00,      1,    0x0      }
            ,{DUMMY_NAME_PTR_CNS,            0x00000124,         0x00097F00,      1,    0x0      }
            ,{DUMMY_NAME_PTR_CNS,            0x00000128,         0x000A7F00,      1,    0x0      }
            ,{DUMMY_NAME_PTR_CNS,            0x0000012C,         0x000B7F00,      1,    0x0      }
            ,{DUMMY_NAME_PTR_CNS,            0x00000130,         0x000C7F00,      1,    0x0      }
            ,{DUMMY_NAME_PTR_CNS,            0x00000134,         0x000D7F00,      1,    0x0      }
            ,{DUMMY_NAME_PTR_CNS,            0x00000138,         0x000E7F00,      1,    0x0      }
            ,{DUMMY_NAME_PTR_CNS,            0x0000013C,         0x000F7F00,      1,    0x0      }
            ,{DUMMY_NAME_PTR_CNS,            0x00000140,         0x00107F00,      1,    0x0      }
            ,{DUMMY_NAME_PTR_CNS,            0x00000144,         0x00117F00,      1,    0x0      }
            ,{DUMMY_NAME_PTR_CNS,            0x00000148,         0x00127F00,      1,    0x0      }
            ,{DUMMY_NAME_PTR_CNS,            0x0000014C,         0x00137F00,      1,    0x0      }
            ,{DUMMY_NAME_PTR_CNS,            0x00000150,         0x00147F00,      1,    0x0      }
            ,{DUMMY_NAME_PTR_CNS,            0x00000154,         0x00157F00,      1,    0x0      }
            ,{DUMMY_NAME_PTR_CNS,            0x00000158,         0x00167F00,      1,    0x0      }
            ,{DUMMY_NAME_PTR_CNS,            0x0000015C,         0x00177F00,      1,    0x0      }
            ,{DUMMY_NAME_PTR_CNS,            0x00000160,         0x00187F00,      1,    0x0      }
            ,{DUMMY_NAME_PTR_CNS,            0x00000164,         0x00197F00,      1,    0x0      }

            ,{NULL,            0,         0x00000000,      0,    0x0      }
        };

        static SMEM_LINK_LIST_REGISTER_DEFAULT_VALUE_STC list = {myUnit_registersDefaultValueArr,NULL};
        unitPtr->unitDefaultRegistersPtr = &list;
    }
}

/**
* @internal smemAasUnitPcaBrgShmEgr function
* @endinternal
*
* @brief   Allocate address type specific memories -- for the PCA SHM Egress
*/
static void smemAasUnitPcaBrgShmEgr
(
    IN SKERNEL_DEVICE_OBJECT *devObjPtr,
    IN SMEM_UNIT_CHUNKS_STC  *unitPtr
)
{
    /* /Cider/EBU/Seahawk/Seahawk {Seahawk_CC_230515}/Tile/Core/PCA/<SHME> SHM_EGR/Units %g*/
    /*IP: \Cider \EBU-IP \PCA \SHM_EGR \SHM EGR 3.0 \SHM EGR {ccRTL_270423.0} \SHM_EGR \Units*/
    /*Mask: \Cider \EBU-IP \PCA \SHM_EGR \SHM EGR 3.0 \SHM EGR Seahawk1 22-CH Non FlexE {ccRTL_270423.0}*/
    SMEM_CHUNK_BASIC_STC  chunksMem[]=
    {
        /*channel config*/
         {SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000000, 0x00000054)}
         /*remote port config*/
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000140, 0x00000284)}
        /*channel Interrupts*/
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000400, 0x000004D0)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000500, 0x000005D0)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000600, 0x000006D0)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000700, 0x00000714)}
        /*channel statistics*/
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000800, 0x00000944)}
        /*Global config*/
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001200, 0x00001208)}
        /*Global interrupts*/
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001300, 0x0000130C)}
        /*Global status*/
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001400, 0x0000141C)}
    };

    GT_U32  numOfChunks = sizeof(chunksMem)/sizeof(SMEM_CHUNK_BASIC_STC);
    smemInitMemChunk(devObjPtr,chunksMem, numOfChunks, unitPtr);
}

/**
* @internal smemAasUnitPcaBrgUnpackTx function
* @endinternal
*
* @brief   Allocate address type specific memories -- for the PCA Unpack TX
*/
static void smemAasUnitPcaBrgUnpackTx
(
    IN SKERNEL_DEVICE_OBJECT *devObjPtr,
    IN SMEM_UNIT_CHUNKS_STC  *unitPtr
)
{
    /* /Cider/EBU/Seahawk/Seahawk {Seahawk_CC_230515}/Tile/Core/PCA/<TX_UNPACK> TX UPACK IP TLU/Units %g*/
    /*IP: \Cider \EBU-IP \PCA \TX UNPACK IP \TX UNPACK 3.0 \TX UNPACK {SHK-22ch-CC-2} \TX UPACK IP TLU \Units*/
    /*Mask: \Cider \EBU-IP \PCA \TX UNPACK IP \TX UNPACK 3.0 \TX UNPACK Seahawk 22-CH {SHK-22ch-CC-2}*/
    SMEM_CHUNK_BASIC_STC  chunksMem[]=
    {
        /*channel config*/
         {SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000600, 0x00000654)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000800, 0x00000854)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001000, 0x00001054)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001200, 0x00001254)}
        /*channel interrupts*/
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000200, 0x00000254)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000400, 0x00000454)}
        /*channel statistics*/
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00002000, 0x00002054)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00002200, 0x00002254)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00002400, 0x00002454)}
        /*channel status*/
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001400, 0x00001454)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001600, 0x00001654)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001800, 0x00001854)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001A00, 0x00001A54)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001C00, 0x00001C54)}
        /*global config*/
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000000, 0x00000008)}
        /*global interrupts*/
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000010, 0x00000014)}
        /*global status*/
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000018, 0x00000018)}
        /*selected channel statistics*/
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000070, 0x0000007C)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000084, 0x000000A0)}
        /*interrupt summary*/
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000020, 0x00000024)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000030, 0x00000030)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000040, 0x00000040)}
    };

    GT_U32  numOfChunks = sizeof(chunksMem)/sizeof(SMEM_CHUNK_BASIC_STC);
    smemInitMemChunk(devObjPtr,chunksMem, numOfChunks, unitPtr);
}

static void smemAasUnitDummy
(
    IN SKERNEL_DEVICE_OBJECT *devObjPtr,
    IN SMEM_UNIT_CHUNKS_STC  *unitPtr,
    IN GT_U32               sizeInBytes
)
{
    SMEM_CHUNK_BASIC_STC  chunksMem[]=
    {
         {SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0, 0/*set in run time */)}
    };
    GT_U32  numOfChunks = sizeof(chunksMem)/sizeof(SMEM_CHUNK_BASIC_STC);

    SMEM_CHUNK_BASIC_STC  *chunksMem_dynamic =
        smemDeviceObjMemoryAlloc__internal(devObjPtr,numOfChunks,sizeof(SMEM_CHUNK_BASIC_STC),__FILE__,__LINE__);

    chunksMem[0].numOfRegisters = sizeInBytes / 4;

    *chunksMem_dynamic = chunksMem[0];

    smemInitMemChunk(devObjPtr,chunksMem_dynamic, numOfChunks, unitPtr);
}

static void smemAasUnitDummy_64KB
(
    IN SKERNEL_DEVICE_OBJECT *devObjPtr,
    IN SMEM_UNIT_CHUNKS_STC  *unitPtr
)
{
    smemAasUnitDummy(devObjPtr,unitPtr,64*_1K);
}


static void smemAasUnitDummy_512KB
(
    IN SKERNEL_DEVICE_OBJECT *devObjPtr,
    IN SMEM_UNIT_CHUNKS_STC  *unitPtr
)
{
    smemAasUnitDummy(devObjPtr,unitPtr,512*_1K);
}

/**
* @internal smemAasUnitPcaBrgPackRx function
* @endinternal
*
* @brief   Allocate address type specific memories -- for the PCA Pack RX
*/
static void smemAasUnitPcaBrgPackRx
(
    IN SKERNEL_DEVICE_OBJECT *devObjPtr,
    IN SMEM_UNIT_CHUNKS_STC  *unitPtr
)
{
    /* /Cider/EBU/Seahawk/Seahawk {Seahawk_CC_230515}/Tile/Core/PCA/<RX_PACK> RX PACK IP TLU/Units %g*/
    /*IP: \Cider \EBU-IP \PCA \RX PACK IP \RX PACK 3.0 \RX PACK {SHK-22ch-CC-2} \RX PACK IP TLU \Units*/
    /*Mask: \Cider \EBU-IP \PCA \RX PACK IP \RX PACK 3.0 \RX PACK Seahawk 22-CH {SHK-22ch-CC-2}*/
    SMEM_CHUNK_BASIC_STC  chunksMem[]=
    {
        /*channel config*/
         {SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000600, 0x00000654)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000800, 0x00000854)}
        /*channel interrupts*/
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000200, 0x00000254)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000400, 0x00000454)}
        /*channel statistics*/
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001800, 0x00001854)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001A00, 0x00001A54)}
        /*channel status*/
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001000, 0x00001054)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001200, 0x00001254)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001400, 0x00001454)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001600, 0x00001654)}
        /*global config*/
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000000, 0x00000000)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000008, 0x00000008)}
        /*global interrupts*/
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000010, 0x00000014)}
        /*global status*/
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000018, 0x00000018)}
        /*interrupt summary*/
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000020, 0x00000024)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000030, 0x00000030)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000040, 0x00000040)}
        /*selected channel statistics*/
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000070, 0x00000090)}
    };

    GT_U32  numOfChunks = sizeof(chunksMem)/sizeof(SMEM_CHUNK_BASIC_STC);
    smemInitMemChunk(devObjPtr,chunksMem, numOfChunks, unitPtr);
}

/**
* @internal smemAasIsPreemptiveDmaChannelGet function
* @endinternal
*
* @brief   The function reads preemption status of channel.
*
* @param[in] devObjPtr                - device object PTR.
* @param[in] dataPath                 - DMA data Path.
* @param[in] localDmaChannel          - local DMA Channel.
*/
GT_BIT  smemAasIsPreemptiveDmaChannelGet
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN GT_U32                 dataPath,
    IN GT_U32                 localDmaChannel
)
{
    DECLARE_FUNC_NAME(smemAasIsPreemptiveDmaChannelGet);
    GT_U32 regAddr,regValue;
    GT_U32 dpIndex;
    DATA_PATH_INFO_STC  *dpInfoPtr;


    dpIndex = dataPath % devObjPtr->multiDataPath.maxDp;
    dpInfoPtr = &devObjPtr->multiDataPath.info[dpIndex];
    if (localDmaChannel >= dpInfoPtr->dataPathNumOfPorts)
    {
        return 0; /* out of range localDmaChannel - probably power-down value */
    }


     /* check if this is preemptive channel.
        the difference between express and regular port
        cannot be determinated
         */
    regAddr = SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->SIP6_TXQ_SDQ[dataPath].PortConfig.PortConfig[localDmaChannel];
    smemRegGet(devObjPtr,regAddr,&regValue);
    regValue= SMEM_U32_GET_FIELD(regValue,14,1);
    __LOG(("Channel %d is %s preemptive\n",localDmaChannel,regValue==1?"":"NOT"));
    return  regValue;
}

/**
* @internal smemAasMifToMac function
* @endinternal
*
* @brief   The function converts MIF channel to Mac channel.
*
* @param[in] devObjPtr                 - device object PTR.
* @param[in] mifUnit                   - mif unit index.
* @param[in] mifLocalChannel           - mif local channel.
* @param[out] dataPathPtr              - Pointer to data path.
* @param[out] localMacPtr              - Pointer to local MAC index. 0xFFFFFFFF if not found.
* @param[out] pairLocalMacPtr          - Pointer to pair local MAC index. 0xFFFFFFFF if not found.
* @param[out] isMacPreemptiveInPairPtr - Pointer to bit: is MAC Preemptive In Pair.
*
* @comment Pair MIF channels connected to different MACs when preemption not configured
*          can be connected to the same MAC when preemption configured.
*          For AAS the same MIF channel used for express and regular channels connected to different MACs.
*          The MIF channel used for preemptive and regular channels connected to the same MAC.
*
*/
void smemAasMifToMac
(
    IN  SKERNEL_DEVICE_OBJECT   *devObjPtr,
    IN  GT_U32                  mifUnit,
    IN  GT_U32                  mifLocalChannel,
    OUT GT_U32                  *dataPathPtr,
    OUT GT_U32                  *localMacPtr,
    OUT GT_U32                  *pairLocalMacPtr,
    OUT GT_BIT                  *isMacPreemptiveInPairPtr
)
{
    /* express MIG channel pairs indexed by preemptive - 255 means not exists */
    static const GT_U8 localMifExpressPairArr[] =
    {
        /* 0-7*/   255,   0, 255,   2, 255,   4, 255,   6
    };
    /* preemptive MIF channel pairs indexed by expres - 255 means not exists */
    static const GT_U8 localMifPreemptivePairArr[] =
    {
        /* 0-7*/     1, 255,   3, 255,   5, 255,   7, 255
    };
    GT_U32   tileIndex;
    GT_U32   mifUnitInTile;
    GT_U32   dataPathInTile;
    GT_U32   macOffset;
    GT_U32   pairMif;

    mifUnitInTile = mifUnit % mifUnitsPerTile;
    tileIndex     = mifUnit / mifUnitsPerTile;

    *localMacPtr         = 0xFFFFFFFF; /*not found as default*/
    *pairLocalMacPtr     = 0xFFFFFFFF; /*not found as default*/
    *isMacPreemptiveInPairPtr = 0;
    dataPathInTile = mifUnitIndexToDp[mifUnitInTile];
    *dataPathPtr = (tileIndex * mifUnitsPerTile) + dataPathInTile;

    if (mifUnitInTile > 12)
    {
        /*DP3-FlexE not supported*/
        return;
    }
    if (mifUnitInTile == 12/*CPU*/)
    {
        if (mifLocalChannel == 0)
        {
            *localMacPtr = 21;
        }
        return;
    }
    /* MIF units 2,5,8,11 */
    if (mifUnitInTile == ((dataPathInTile * 3) + 2))
    {
        /* serdes (and MACs) 16-19, loopback MAC20 - local cluster 2 */
        if (mifLocalChannel < 5)
        {
            *localMacPtr = 16 + mifLocalChannel;
        }
        return;
    }
    /* MIF units 0,1,3,4,6,7,9,10 */
    macOffset = ((mifUnitInTile - (dataPathInTile * 3)) % 2) * 8;
    if (mifLocalChannel > 8)
    {
        return;
    }
    if (mifLocalChannel == 8)
    {
        /* R8 mode MAC in local clustes 0,1 */
        *localMacPtr = macOffset;
        return;
    }
    pairMif = localMifExpressPairArr[mifLocalChannel];
    if (pairMif != 255)
    {
        /* MAC can be preemptable                        */
        /* MIF channel contains preemptive DMA channel   */
        /* pair MIF channel contains express DMA channel */
        *localMacPtr     = macOffset + mifLocalChannel;
        *pairLocalMacPtr = macOffset + pairMif;
        *isMacPreemptiveInPairPtr = 1;
    }
    pairMif = localMifPreemptivePairArr[mifLocalChannel];
    if (pairMif != 255)
    {
        /* MAC can be preemptable                           */
        /* MIF channel contains express DMA channel         */
        /* pair MIF channel contains preemptive DMA channel */
        *localMacPtr     = macOffset + mifLocalChannel;
        *pairLocalMacPtr = macOffset + pairMif;
        *isMacPreemptiveInPairPtr = 0;
        return;
    }
    /* MAC cannot be preemptable - this state not exppectes - should be treated earlier */
    *localMacPtr     = macOffset + mifLocalChannel;
}

/**
* @internal smemAasFindDmaDbMacMapping function
* @endinternal
*
* @brief   The function finds DMA channel in DB by MAC.
*          Called to configure express channel checking mapping of preemptive channel.
*
* @param[in] devObjPtr                - device object PTR.
* @param[in] dataPath                 - data Path.
* @param[in] macLocalChannelFind      - mif local channel.
* @param[out] txDmaGlobalPortNumPtr   - Pointer to TX Dma Global Port Number, 0xFFFFFFFF if not found.
*/
void smemAasFindDmaDbMacMapping
(
    IN SKERNEL_DEVICE_OBJECT    *devObjPtr,
    IN  GT_U32                  dataPath,
    IN  GT_U32                  macLocalChannelFind,
    OUT GT_U32                  *txDmaGlobalPortNumPtr,
    OUT GT_BIT                  *isPreemptiveChannelPtr
)
{
    GT_U32                      pipeId;
    GT_U32                      globalMacPortFind;
    GT_U32                      txDmaGlobalPortNum;
    GT_U32                      ii;
    SKERNEL_PORT_MIF_INFO_STC   *portMifInfoPtr;
    GT_U32                      dpIndex;
    DATA_PATH_INFO_STC          *dpInfoPtr;

    dpIndex = dataPath % devObjPtr->multiDataPath.maxDp;/* the dpIndex needed as local DP in the pipe */
    *txDmaGlobalPortNumPtr  = 0xFFFFFFFF;
    *isPreemptiveChannelPtr = 0;
    dpInfoPtr = &devObjPtr->multiDataPath.info[dpIndex];
    if (macLocalChannelFind >= dpInfoPtr->dataPathNumOfPorts)
    {
        return; /* out of range localDmaChannel - probably power-down value */
    }
    pipeId = smemGetCurrentPipeId(devObjPtr);
    /* convert dataPath and local mac port to global mac number */
    smemConvertPipeIdAndLocalPortToGlobal_withPipeAndDpIndex(
        devObjPtr,
        pipeId, /* current pipe */
        dpIndex, /* DP unit local to the current pipe */
        macLocalChannelFind,
        GT_FALSE,/* CPU port not muxed ... not relevant */
        &globalMacPortFind);
    for (txDmaGlobalPortNum = 0; (txDmaGlobalPortNum < devObjPtr->portsNumber); txDmaGlobalPortNum++)
    {
        portMifInfoPtr = &devObjPtr->portsArr[txDmaGlobalPortNum].mifInfo[0];
        for (ii = 0; (ii < SKERNEL_PORT_MIF_INFO_MAX_CNS); ii++,portMifInfoPtr++)
        {
            if (portMifInfoPtr->txEnabled && (portMifInfoPtr->txMacNum == globalMacPortFind))
            {
                *txDmaGlobalPortNumPtr  = txDmaGlobalPortNum;
                *isPreemptiveChannelPtr = portMifInfoPtr->egress_isPreemptiveChannel;
                return;
            }
        }
    }
}

/**
* @internal smemAasUpdateDmaDbMacMapping function
* @endinternal
*
* @brief   The function remaps DMA channel in DB to another MAC.
*          Called to update express channel mapping after preemptive channel mapped.
*
* @param[in] devObjPtr                - device object PTR.
* @param[in] dataPath                 - data Path.
* @param[in] macLocalChannelFind      - mif local channel to find.
* @param[in] macLocalChannelReplace   - mif local channel to replace.
* @param[in] isPreemptiveChannel      - is Preemptive Channel
*/
void smemAasUpdateDmaDbMacMapping
(
    IN SKERNEL_DEVICE_OBJECT    *devObjPtr,
    IN  GT_U32                  dataPath,
    IN  GT_U32                  macLocalChannelFind,
    IN  GT_U32                  macLocalChannelReplace,
    IN  GT_BIT                  isPreemptiveChannel
)
{
    GT_U32                      pipeId;
    GT_U32                      globalMacPortFind;
    GT_U32                      globalMacPortReplace;
    GT_U32                      txDmaGlobalPortNum;
    GT_U32                      ii;
    SKERNEL_PORT_MIF_INFO_STC   *portMifInfoPtr;
    GT_U32                      dpIndex;
    DATA_PATH_INFO_STC          *dpInfoPtr;

    dpIndex = dataPath % devObjPtr->multiDataPath.maxDp;/* the dpIndex needed as local DP in the pipe */
    dpInfoPtr = &devObjPtr->multiDataPath.info[dpIndex];
    if (macLocalChannelFind >= dpInfoPtr->dataPathNumOfPorts)
    {
        return; /* out of range localDmaChannel - probably power-down value */
    }
    if (macLocalChannelReplace >= dpInfoPtr->dataPathNumOfPorts)
    {
        return; /* out of range localDmaChannel - probably power-down value */
    }
    pipeId = smemGetCurrentPipeId(devObjPtr);
    /* convert dataPath and local mac port to global mac number */
    smemConvertPipeIdAndLocalPortToGlobal_withPipeAndDpIndex(
        devObjPtr,
        pipeId, /* current pipe */
        dpIndex, /* DP unit local to the current pipe */
        macLocalChannelFind,
        GT_FALSE,/* CPU port not muxed ... not relevant */
        &globalMacPortFind);
    smemConvertPipeIdAndLocalPortToGlobal_withPipeAndDpIndex(
        devObjPtr,
        pipeId, /* current pipe */
        dpIndex, /* DP unit local to the current pipe */
        macLocalChannelReplace,
        GT_FALSE,/* CPU port not muxed ... not relevant */
        &globalMacPortReplace);
    for (txDmaGlobalPortNum = 0; (txDmaGlobalPortNum < devObjPtr->portsNumber); txDmaGlobalPortNum++)
    {
        portMifInfoPtr = &devObjPtr->portsArr[txDmaGlobalPortNum].mifInfo[0];
        for (ii = 0; (ii < SKERNEL_PORT_MIF_INFO_MAX_CNS); ii++,portMifInfoPtr++)
        {
            if (portMifInfoPtr->txEnabled && (portMifInfoPtr->txMacNum == globalMacPortFind))
            {
                portMifInfoPtr->txMacNum                   = globalMacPortReplace;
                portMifInfoPtr->egress_isPreemptiveChannel = isPreemptiveChannel;
            }
        }
    }
}

/**
* @internal smemAasAddDmaDbMacMapping function
* @endinternal
*
* @brief   The function Adds DMA channel mapping to MAC to DB.
*
* @param[in] devObjPtr                - device object PTR.
* @param[in] dataPath                 - data Path.
* @param[in] macLocalChannel          - MAC local channel.
* @param[in] txDmaGlobalPortNumPtr    - TX Dma Global Port Number
* @param[in] txEnabled                - TX Enabled
* @param[in] isPreemptiveChannel      - is Preemptive Channel
*/
static void smemAasAddDmaDbMacMapping
(
    IN SKERNEL_DEVICE_OBJECT    *devObjPtr,
    IN  GT_U32                  dataPath,
    IN  GT_U32                  macLocalChannel,
    IN  GT_U32                  mifType,/*'fake' mifType*/
    IN  GT_U32                  txDmaGlobalPortNum,
    IN  GT_BIT                  txEnabled,
    IN  GT_BIT                  isPreemptiveChannel
)
{
    GT_U32                      pipeId;
    GT_U32                      globalMacPort;
    GT_U32                      ii;
    SKERNEL_PORT_MIF_INFO_STC   *portMifInfoPtr;
    GT_U32                      dpIndex;
    DATA_PATH_INFO_STC          *dpInfoPtr;

    dpIndex = dataPath % devObjPtr->multiDataPath.maxDp;/* the dpIndex needed as local DP in the pipe */
    dpInfoPtr = &devObjPtr->multiDataPath.info[dpIndex];
    if (macLocalChannel >= dpInfoPtr->dataPathNumOfPorts)
    {
        return; /* out of range localDmaChannel - probably power-down value */
    }
    pipeId = smemGetCurrentPipeId(devObjPtr);
    /* convert dataPath and local mac port to global mac number */
    smemConvertPipeIdAndLocalPortToGlobal_withPipeAndDpIndex(
        devObjPtr,
        pipeId, /* current pipe */
        dpIndex, /* DP unit local to the current pipe */
        macLocalChannel,
        GT_FALSE,/* CPU port not muxed ... not relevant */
        &globalMacPort);
    portMifInfoPtr = &devObjPtr->portsArr[txDmaGlobalPortNum].mifInfo[0];
    for (ii = 0; (ii < SKERNEL_PORT_MIF_INFO_MAX_CNS); ii++,portMifInfoPtr++)
    {
        if (portMifInfoPtr->txEnabled == 0) continue;
        if (portMifInfoPtr->txMacNum == globalMacPort &&
            portMifInfoPtr->mifType  == mifType)
        {
            portMifInfoPtr->egress_isPreemptiveChannel = isPreemptiveChannel;
            portMifInfoPtr->txEnabled = txEnabled;
            return;
        }
    }
    if (txEnabled == 0)
    {
        return;
    }
    portMifInfoPtr = &devObjPtr->portsArr[txDmaGlobalPortNum].mifInfo[0];
    for (ii = 0; (ii < SKERNEL_PORT_MIF_INFO_MAX_CNS); ii++,portMifInfoPtr++)
    {
        if (portMifInfoPtr->txEnabled == 0) break;
    }
    if (ii >= SKERNEL_PORT_MIF_INFO_MAX_CNS)
    {
        return;
    }

    portMifInfoPtr->txMacNum  = globalMacPort;
    portMifInfoPtr->mifType   = mifType;
    portMifInfoPtr->egress_isPreemptiveChannel = isPreemptiveChannel;
    portMifInfoPtr->txEnabled = txEnabled;
}

/**
* @internal smemAasDeleteDmaDbMacMapping function
* @endinternal
*
* @brief   The function deletes MAC from mapping to any channel.
*
* @param[in] devObjPtr                - device object PTR.
* @param[in] dataPath                 - data Path.
* @param[in] macLocalChannel          - mif local channel.
*/
void smemAasDeleteDmaDbMacMapping
(
    IN SKERNEL_DEVICE_OBJECT    *devObjPtr,
    IN  GT_U32                  dataPath,
    IN  GT_U32                  macLocalChannel
)
{
    GT_U32                      pipeId;
    GT_U32                      globalMacPort;
    GT_U32                      txDmaGlobalPortNum;
    GT_U32                      ii;
    SKERNEL_PORT_MIF_INFO_STC   *portMifInfoPtr;
    GT_U32                      dpIndex;
    DATA_PATH_INFO_STC          *dpInfoPtr;

    dpIndex = dataPath % devObjPtr->multiDataPath.maxDp;/* the dpIndex needed as local DP in the pipe */
    dpInfoPtr = &devObjPtr->multiDataPath.info[dpIndex];
    if (macLocalChannel >= dpInfoPtr->dataPathNumOfPorts)
    {
        return; /* out of range localDmaChannel - probably power-down value */
    }
    pipeId = smemGetCurrentPipeId(devObjPtr);
    /* convert dataPath and local mac port to global mac number */
    smemConvertPipeIdAndLocalPortToGlobal_withPipeAndDpIndex(
        devObjPtr,
        pipeId, /* current pipe */
        dpIndex, /* DP unit local to the current pipe */
        macLocalChannel,
        GT_FALSE,/* CPU port not muxed ... not relevant */
        &globalMacPort);
    for (txDmaGlobalPortNum = 0; (txDmaGlobalPortNum < devObjPtr->portsNumber); txDmaGlobalPortNum++)
    {
        portMifInfoPtr = &devObjPtr->portsArr[txDmaGlobalPortNum].mifInfo[0];
        for (ii = 0; (ii < SKERNEL_PORT_MIF_INFO_MAX_CNS); ii++,portMifInfoPtr++)
        {
            if (portMifInfoPtr->txEnabled && (portMifInfoPtr->txMacNum == globalMacPort))
            {
                portMifInfoPtr->txEnabled = 0;
            }
        }
    }
}

/**
* @internal smemAasPrintAllDmaDbMacMappings function
* @endinternal
*
* @brief   The function prints all MIF->MAC mappings in DB.
*
* @param[in] devObjPtr                - device object PTR.
*/
void smemAasPrintAllDmaDbMacMappings
(
    IN SKERNEL_DEVICE_OBJECT    *devObjPtr
)
{
    GT_U32                      txDmaGlobalPortNum;
    GT_U32                      ii;
    SKERNEL_PORT_MIF_INFO_STC   *portMifInfoPtr;

    simGeneralPrintf("MIF=>MAC mapping DB\n");
    for (txDmaGlobalPortNum = 0; (txDmaGlobalPortNum < devObjPtr->portsNumber); txDmaGlobalPortNum++)
    {
        portMifInfoPtr = &devObjPtr->portsArr[txDmaGlobalPortNum].mifInfo[0];
        for (ii = 0; (ii < SKERNEL_PORT_MIF_INFO_MAX_CNS); ii++,portMifInfoPtr++)
        {
            if (portMifInfoPtr->txEnabled)
            {
                simGeneralPrintf(
                    "GlobalDMA %d GlobalMAC %d mifType %d preemtive %d \n",
                    txDmaGlobalPortNum, portMifInfoPtr->txMacNum,
                    portMifInfoPtr->mifType,
                    portMifInfoPtr->egress_isPreemptiveChannel);
            }
        }
    }
    simGeneralPrintf("\n");
}

/**
* @internal smemAasPrintAllDmaDbMacMappingsUtil function
* @endinternal
*
* @brief   The function prints all MIF->MAC mappings in DB.
*
* @param[in] deviceId                - device Id.
*/
void smemAasPrintAllDmaDbMacMappingsUtil
(
    IN GT_U32    deviceId
)
{
    SKERNEL_DEVICE_OBJECT* devObjPtr;

    devObjPtr = smemTestDeviceIdToDevPtrConvert(deviceId);
    if (devObjPtr == NULL)
    {
        simGeneralPrintf("Device object not found\n");
        return;
    }
    smemAasPrintAllDmaDbMacMappings(devObjPtr);
}
/**
* @internal smemChtActiveAasWriteMifChannelMappingReg function
* @endinternal
*
* @brief   The function save the tx mapping to mac for better runtime performance
*          when mapping used by the traffic.
*
* @param[in] devObjPtr                - device object PTR.
* @param[in] address                  - Address for ASIC memory.
* @param[in] memPtr                   - Pointer to the register's memory in the simulation.
* @param[in] memSize                  - Size of memory to be written
* @param[in] param                    - Registers' specific parameter.
* @param[in] inMemPtr                 - Pointer to the memory to get register's content.
*/
static void smemChtActiveAasWriteMifChannelMappingReg
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN GT_U32   address,
    IN GT_U32   memSize,
    IN GT_U32 * memPtr,
    IN GT_UINTPTR   param,
    IN GT_U32 * inMemPtr
)
{
    GT_U32   dpIndex;
    GT_U32   mifUnitId,baseAddr;
    GT_U32   mifUnitIdMax=devObjPtr->numOfMifs?devObjPtr->numOfMifs:SIM_MAX_MIF_UNITS;
    GT_U32   local_mif_channel_number;/* local mif channel number */
    GT_U32   local_mac_number;   /*local mac port */
    GT_U32   txDmaGlobalPortNum; /* global dma port   */
    GT_U32   pairTxDmaGlobalPortNum; /* pair global dma port   */
    GT_U32   old_local_dma_number; /* old DMA number before the change */
    GT_U32   new_local_dma_number; /* new DMA number after  the change */
    GT_U32   pipeId;
    GT_BIT   oldTxEnabled;
    GT_BIT   newTxEnabled;
    GT_BIT   isPreemptiveChannel;
    static const GT_U32 mifChannelMappingRegBase = 0x00000A00;
    GT_U32   dataPath; /*datapath inside tile*/
    GT_U32   pair_local_mac_number;
    GT_BIT   isMacPreemptiveInPair;
    GT_BIT   isPreemptivePairChannel;
    GT_U32   local_mac_to_map;
    DATA_PATH_INFO_STC          *dpInfoPtr;
    GT_U32  mifType = 0;/* used as fake 'mif type' */

    /* old value */
    old_local_dma_number = (*memPtr)   & 0x3f;/* 6 bits */
    oldTxEnabled         = ((*memPtr) >> 6) & 1;
    /* new value */
    new_local_dma_number = (*inMemPtr) & 0x3f;/* 6 bits */
    newTxEnabled            = ((*inMemPtr) >> 6) & 1;

    /* data to be written */
    *memPtr = *inMemPtr;

    if(old_local_dma_number == new_local_dma_number)
    {
        /* not changed */
        return;
    }
    for(mifUnitId = 0; (mifUnitId < mifUnitIdMax); mifUnitId++)
    {
        baseAddr = devObjPtr->memUnitBaseAddrInfo.mif[mifUnitId];
        if ((address >= baseAddr) && (address < (baseAddr + (16*_1K))))
        {
            /* found unit */
            break;
        }
    }
    if (mifUnitId == mifUnitIdMax)
    {
        /* not found ?! */
        skernelFatalError("smemChtActiveAasWriteMifChannelMappingReg : mifUnitId was not enough for address [0x%8.8x] \n",
            address);

        return;
    }
    local_mif_channel_number = ((address & 0x3FFF)/*16K*/ - mifChannelMappingRegBase) / 4;

    smemAasMifToMac(
        devObjPtr, mifUnitId, local_mif_channel_number,
        &dataPath, &local_mac_number, &pair_local_mac_number, &isMacPreemptiveInPair);
    if (local_mac_number == 0xFFFFFFFF)
    {
        /* mapping not found */
        return ;
    }
    local_mac_to_map = local_mac_number;

    /* mif 8 used for MAC 0 in group 0 and MAC 8 in group 1 */
    /* so the MAC 0 need to hold info for both 'high speed' and 'low speed' */
    mifType = (local_mac_number == 0 || local_mac_number == 8) &&
                (local_mif_channel_number == 8) ? 1 : 0;

    isPreemptiveChannel = 0;
    if ((pair_local_mac_number != 0xFFFFFFFF)
        && (isMacPreemptiveInPair == 0))
    {
        /* channel can be express, pair - preemtive */
        smemAasFindDmaDbMacMapping(
            devObjPtr, dataPath, pair_local_mac_number,
            &pairTxDmaGlobalPortNum, &isPreemptivePairChannel);
        if ((pairTxDmaGlobalPortNum != 0xFFFFFFFF) && isPreemptivePairChannel)
        {
            /* the possible pair is preemptive - map to pair mac                           */
            /* this case will work only if preemptive channel MIF entry already configured */
            local_mac_to_map = pair_local_mac_number;
        }
    }

    if ((pair_local_mac_number != 0xFFFFFFFF)
        && isMacPreemptiveInPair && newTxEnabled)
    {
        /* channel can be preemtive, pair - express */
        isPreemptiveChannel = smemAasIsPreemptiveDmaChannelGet(
            devObjPtr, dataPath, new_local_dma_number);
        if (isPreemptiveChannel)
        {
            /* upbdate express channeel mapping in DB if already configured */
            smemAasUpdateDmaDbMacMapping(
                devObjPtr, dataPath,
                pair_local_mac_number/*macLocalChannelFind*/,
                local_mac_number/*macLocalChannelReplace*/,
                0 /*isPreemptiveChannel*/);
        }
    }

    dpIndex = dataPath % devObjPtr->multiDataPath.maxDp; /* the dpIndex needed as local DP in the pipe */
    dpInfoPtr = &devObjPtr->multiDataPath.info[dpIndex];
    pipeId = smemGetCurrentPipeId(devObjPtr);
    if (new_local_dma_number < dpInfoPtr->dataPathNumOfPorts)
    {
        /* convert dpIndex and local dma channel to global dma channel */
        smemConvertPipeIdAndLocalPortToGlobal_withPipeAndDpIndex(
            devObjPtr,
            pipeId, /* current pipe */
            dpIndex, /* DP unit local to the current pipe */
            new_local_dma_number,
            GT_FALSE,/* CPU port not muxed ... not relevant */
            &txDmaGlobalPortNum);
        smemAasAddDmaDbMacMapping(
            devObjPtr, dataPath, local_mac_to_map, mifType,
            txDmaGlobalPortNum, newTxEnabled, isPreemptiveChannel);
    }
    if (oldTxEnabled && (newTxEnabled == 0))
    {
        smemAasDeleteDmaDbMacMapping(
            devObjPtr, dataPath, local_mac_to_map);
    }
}

/**
* @internal smemAasUnitMif function
* @endinternal
*
* @brief   Allocate address type specific memories - for the MIF
*/
static void smemAasUnitMif
(
    IN SKERNEL_DEVICE_OBJECT *devObjPtr,
    IN SMEM_UNIT_CHUNKS_STC  *unitPtr
)
{
    /* /Cider/EBU/Seahawk/Seahawk {Seahawk_CC_230515}/Tile/Core/PCA/<MIF_9P > MIF/MIF registers %g %i*/
    /*IP: \Cider \EBU-IP \PCA \MIF IP \MIF IP 3.0 \MIF {MIF IP SHK 16-CH {CC 230423}} \MIF \MIF registers*/
    /*Mask: \Cider \EBU-IP \PCA \MIF IP \MIF IP 3.0 \MIF IP SHK 16-CH {MIF IP SHK 16-CH {CC 230423}}*/

    START_BIND_UNIT_ACTIVE_MEM_MAC(devObjPtr,unitPtr)
        /* 0x00000A00 - 0x0x00000A3C : up to 16 channels */
        {0x00000A00 , 0xFFFFFFC3, NULL, 0, smemChtActiveAasWriteMifChannelMappingReg, 0 /*param*/},
    END_BIND_UNIT_ACTIVE_MEM_MAC(devObjPtr,unitPtr)

    {
        SMEM_CHUNK_EXTENDED_STC  chunksMem[]=
        {
            /* MIF GLOBAL - start */
             {{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000000, 0x000000014)}} /*interrupt*/
            ,{{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000020, 0x000000028)}} /*config*/
            /* MIF GLOBAL - end */
            /* MIF Channel - start */
            /*interrupts*/
            ,{{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000100, 0x0000013C)}} /*cause*/
            ,{{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000180, 0x000001BC)}} /*mask*/
            /*statistics*/
            ,{{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000300, 0x0000033C)}}
            ,{{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000380, 0x000003BC)}}
            ,{{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000400, 0x0000043C)}}
            ,{{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000480, 0x000004BC)}}
            ,{{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000500, 0x0000053C)}}
            ,{{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000580, 0x000005BC)}}
            ,{{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000600, 0x0000063C)}}
            ,{{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000680, 0x000006BC)}}
            /*status*/
            ,{{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000800, 0x0000083C)}}
            ,{{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000880, 0x000008BC)}}
            /*config*/
            ,{{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000A00, 0x00000A3C)}}
            ,{{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000A80, 0x00000ABC)}}
            ,{{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000B00, 0x00000B3C)}}
            ,{{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000B80, 0x00000BBC)}}
            ,{{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000C00, 0x00000C3C)}}
             /* MIF Channel - end */
        };
        GT_U32  numOfChunks = sizeof(chunksMem)/sizeof(SMEM_CHUNK_EXTENDED_STC);

        smemInitMemChunkExt(devObjPtr,chunksMem, numOfChunks, unitPtr);
    }

    {
        static SMEM_REGISTER_DEFAULT_VALUE_STC myUnit_registersDefaultValueArr[] =
        {
             {DUMMY_NAME_PTR_CNS,        0x00000024,         0xFFFF0000,      1,   0x0            }
            ,{DUMMY_NAME_PTR_CNS,        0x00000028,         0x00000005,      1,   0x0            }

            ,{DUMMY_NAME_PTR_CNS,        0x00000800,         0x00001200,     16,   0x4            }
            ,{DUMMY_NAME_PTR_CNS,        0x00000880,         0x00001200,     16,   0x4            }

            ,{DUMMY_NAME_PTR_CNS,        0x00000A00,         0x7F203F3F,     16,   0x4            }
            ,{DUMMY_NAME_PTR_CNS,        0x00000A80,         0x00000001,     16,   0x4            }
            ,{DUMMY_NAME_PTR_CNS,        0x00000B00,         0x00000001,     16,   0x4            }
            ,{DUMMY_NAME_PTR_CNS,        0x00000C00,         0x00000008,     16,   0x4            }

            ,{NULL,                      0,                  0x00000000,      0,   0x0            }
        };
        static SMEM_LINK_LIST_REGISTER_DEFAULT_VALUE_STC list = {myUnit_registersDefaultValueArr,NULL};
        unitPtr->unitDefaultRegistersPtr = &list;
    }

}


/**
* @internal smemAasUnitMac400GWrap function
* @endinternal
*
* @brief   Allocate address type specific memories -- for the MAC 400G unit wrapper
*/
static void smemAasUnitMac400GWrap
(
    IN SKERNEL_DEVICE_OBJECT *devObjPtr,
    IN SMEM_UNIT_CHUNKS_STC  *unitPtr
)
{
    START_BIND_UNIT_ACTIVE_MEM_MAC(devObjPtr,unitPtr)

        /* Statistic counters - active memory read */
        /* SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->sip6_MTI_EXTERNAL[portNum/8].MTI_STATS.counterCapture[ii] */
        /* ii = 0..55 : address 0x20-0xfc

          lets brake it down:
                            addr        mask
          0x20 - 0x3c :     0x20      (~0x1F)
          0x40 - 0x7c :     0x40      (~0x3F)
          0x80 - 0xfc :     0x80      (~0x7F)
        */
        {MAC_MIB_OFFSET + 0x00000020, 0xFFFFFFE0, smemFalconActiveReadMtiStatisticCounters, SMEM_ACTIVE_MTI_MIB_SUPPORT_PREEMPTION_MAC, NULL , 0},
        {MAC_MIB_OFFSET + 0x00000040, 0xFFFFFFC0, smemFalconActiveReadMtiStatisticCounters, SMEM_ACTIVE_MTI_MIB_SUPPORT_PREEMPTION_MAC, NULL , 0},
        {MAC_MIB_OFFSET + 0x00000080, 0xFFFFFF80, smemFalconActiveReadMtiStatisticCounters, SMEM_ACTIVE_MTI_MIB_SUPPORT_PREEMPTION_MAC, NULL , 0},
        /* Statistic counters - active memory write control */
        /* SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->sip6_MTI_EXTERNAL[portNum/8].MTI_STATS.control */
        {MAC_MIB_OFFSET + 0x0000000C, SMEM_FULL_MASK_CNS, NULL, 0, smemFalconActiveWriteMtiStatisticControl, SMEM_ACTIVE_MTI_MIB_SUPPORT_PREEMPTION_MAC},


        /* MIB - END */

        /* SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->sip6_MTI_EXTERNAL[sip6_MTI_EXTERNAL_representativePortIndex].MTI_GLOBAL.globalInterruptSummaryCause */
        {MAC_EXT_BASE_OFFSET + 0x0000004C, SMEM_FULL_MASK_CNS, smemChtActiveReadIntrCauseReg, 0, smemChtActiveWriteIntrCauseReg, 0},


        /*0x00000094 + 0x18*portIndex + unitOffset*/
        /* SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->sip6_MTI[portNum].MTI_EXT_PORT.portInterruptCause */
        {MAC_EXT_BASE_OFFSET + 0x00000094 + 0x18*0, SMEM_FULL_MASK_CNS, smemChtActiveReadIntrCauseReg, 0, smemChtActiveWriteIntrCauseReg, 0},
        {MAC_EXT_BASE_OFFSET + 0x00000094 + 0x18*1, SMEM_FULL_MASK_CNS, smemChtActiveReadIntrCauseReg, 0, smemChtActiveWriteIntrCauseReg, 0},
        {MAC_EXT_BASE_OFFSET + 0x00000094 + 0x18*2, SMEM_FULL_MASK_CNS, smemChtActiveReadIntrCauseReg, 0, smemChtActiveWriteIntrCauseReg, 0},
        {MAC_EXT_BASE_OFFSET + 0x00000094 + 0x18*3, SMEM_FULL_MASK_CNS, smemChtActiveReadIntrCauseReg, 0, smemChtActiveWriteIntrCauseReg, 0},
        {MAC_EXT_BASE_OFFSET + 0x00000094 + 0x18*4, SMEM_FULL_MASK_CNS, smemChtActiveReadIntrCauseReg, 0, smemChtActiveWriteIntrCauseReg, 0},
        {MAC_EXT_BASE_OFFSET + 0x00000094 + 0x18*5, SMEM_FULL_MASK_CNS, smemChtActiveReadIntrCauseReg, 0, smemChtActiveWriteIntrCauseReg, 0},
        {MAC_EXT_BASE_OFFSET + 0x00000094 + 0x18*6, SMEM_FULL_MASK_CNS, smemChtActiveReadIntrCauseReg, 0, smemChtActiveWriteIntrCauseReg, 0},
        {MAC_EXT_BASE_OFFSET + 0x00000094 + 0x18*7, SMEM_FULL_MASK_CNS, smemChtActiveReadIntrCauseReg, 0, smemChtActiveWriteIntrCauseReg, 0},


        /* SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->sip6_MTI[portNum].MTI_EXT_PORT.portInterruptMask */
        {MAC_EXT_BASE_OFFSET + 0x00000098 + 0x18*0, SMEM_FULL_MASK_CNS, NULL, 0, smemFalconActiveWritePortInterruptsMaskReg, 0},
        {MAC_EXT_BASE_OFFSET + 0x00000098 + 0x18*1, SMEM_FULL_MASK_CNS, NULL, 0, smemFalconActiveWritePortInterruptsMaskReg, 0},
        {MAC_EXT_BASE_OFFSET + 0x00000098 + 0x18*2, SMEM_FULL_MASK_CNS, NULL, 0, smemFalconActiveWritePortInterruptsMaskReg, 0},
        {MAC_EXT_BASE_OFFSET + 0x00000098 + 0x18*3, SMEM_FULL_MASK_CNS, NULL, 0, smemFalconActiveWritePortInterruptsMaskReg, 0},
        {MAC_EXT_BASE_OFFSET + 0x00000098 + 0x18*4, SMEM_FULL_MASK_CNS, NULL, 0, smemFalconActiveWritePortInterruptsMaskReg, 0},
        {MAC_EXT_BASE_OFFSET + 0x00000098 + 0x18*5, SMEM_FULL_MASK_CNS, NULL, 0, smemFalconActiveWritePortInterruptsMaskReg, 0},
        {MAC_EXT_BASE_OFFSET + 0x00000098 + 0x18*6, SMEM_FULL_MASK_CNS, NULL, 0, smemFalconActiveWritePortInterruptsMaskReg, 0},
        {MAC_EXT_BASE_OFFSET + 0x00000098 + 0x18*7, SMEM_FULL_MASK_CNS, NULL, 0, smemFalconActiveWritePortInterruptsMaskReg, 0},


        /*0x00000068 + 0x14*portIndex + unitOffset*/
        /* SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->sip6_MTI[portNum].MTI_EXT_PORT.segPortInterruptCause */
        {MAC_EXT_BASE_OFFSET + 0x00000068 + 0x14*0, SMEM_FULL_MASK_CNS, smemChtActiveReadIntrCauseReg, 0, smemChtActiveWriteIntrCauseReg, 0},
        {MAC_EXT_BASE_OFFSET + 0x00000068 + 0x14*1, SMEM_FULL_MASK_CNS, smemChtActiveReadIntrCauseReg, 0, smemChtActiveWriteIntrCauseReg, 0},

        /* SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->sip6_MTI[portNum].MTI_EXT_PORT.segPortInterruptMask */
        {MAC_EXT_BASE_OFFSET + 0x0000006c + 0x14*0, SMEM_FULL_MASK_CNS, NULL, 0, smemFalconActiveWritePortInterruptsMaskReg, 0},
        {MAC_EXT_BASE_OFFSET + 0x0000006c + 0x14*1, SMEM_FULL_MASK_CNS, NULL, 0, smemFalconActiveWritePortInterruptsMaskReg, 0},

        /* Global Amps Lock Status */
        {MAC_EXT_BASE_OFFSET + 0x0000001c , SMEM_FULL_MASK_CNS, smemChtActiveReadConst, 0xFFFFFFFF, NULL, 0},

    END_BIND_UNIT_ACTIVE_MEM_MAC(devObjPtr,unitPtr)

    /* MIB - start */
    {
        SMEM_CHUNK_BASIC_STC  chunksMem[]=
        {
             {SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (MAC_MIB_OFFSET + 0x00000000, MAC_MIB_OFFSET + 0x00000014)}
             /* memories till start of RX counters per port */
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (MAC_MIB_OFFSET + 0x0000001C, MAC_MIB_OFFSET + 0x000000FC)}
             /* memories from start of RX counters per port , till TX counters per port */
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (MAC_MIB_OFFSET + START_MIB_RX_PER_PORT, MAC_MIB_OFFSET + START_MIB_TX_PER_PORT + SIZE_MIB_TX - 0x4)}
        };

        GT_U32  numOfChunks = sizeof(chunksMem)/sizeof(SMEM_CHUNK_BASIC_STC);
        smemInitMemChunk(devObjPtr,chunksMem, numOfChunks, unitPtr);
    }
    /* MIB - END */

    /* MAC 400G - start */
    {
        SMEM_CHUNK_EXTENDED_STC  chunksMem[]=
        {
            /* per MAC */
             {{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (MAC_400G_OFFSET + 0x00000000, MAC_400G_OFFSET + 0x00000020)} , FORMULA_SINGLE_PARAMETER(1 , MAC_STEP_PORT_OFFSET)}
            ,{{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (MAC_400G_OFFSET + 0x0000002C, MAC_400G_OFFSET + 0x0000002C)} , FORMULA_SINGLE_PARAMETER(1 , MAC_STEP_PORT_OFFSET)}
            ,{{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (MAC_400G_OFFSET + 0x00000040, MAC_400G_OFFSET + 0x00000044)} , FORMULA_SINGLE_PARAMETER(1 , MAC_STEP_PORT_OFFSET)}
            ,{{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (MAC_400G_OFFSET + 0x00000054, MAC_400G_OFFSET + 0x00000074)} , FORMULA_SINGLE_PARAMETER(1 , MAC_STEP_PORT_OFFSET)}
            ,{{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (MAC_400G_OFFSET + 0x0000007C, MAC_400G_OFFSET + 0x00000080)} , FORMULA_SINGLE_PARAMETER(1 , MAC_STEP_PORT_OFFSET)}

        };
        GT_U32  numOfChunks = sizeof(chunksMem)/sizeof(SMEM_CHUNK_EXTENDED_STC);
        SMEM_UNIT_CHUNKS_STC    tmpUnitChunk;

        smemInitMemChunkExt(devObjPtr,chunksMem, numOfChunks, &tmpUnitChunk);
        /*add the tmp unit chunks to the main unit */
        smemInitMemCombineUnitChunks(devObjPtr,unitPtr,&tmpUnitChunk);
    }
    /* MAC 400G - end */

    /* MAC 100G - start */
    {
        SMEM_CHUNK_EXTENDED_STC  chunksMem[]=
        {
            /* per MAC : ports 0..7 */
             {{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (PORT0_100G_OFFSET + 0x00000000, PORT0_100G_OFFSET + 0x00000020)} , FORMULA_SINGLE_PARAMETER(NUM_PORTS_PER_UNIT , MAC_STEP_PORT_OFFSET)}
            ,{{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (PORT0_100G_OFFSET + 0x00000040, PORT0_100G_OFFSET + 0x00000048)} , FORMULA_SINGLE_PARAMETER(NUM_PORTS_PER_UNIT , MAC_STEP_PORT_OFFSET)}
            ,{{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (PORT0_100G_OFFSET + 0x0000007C, PORT0_100G_OFFSET + 0x00000080)} , FORMULA_SINGLE_PARAMETER(NUM_PORTS_PER_UNIT , MAC_STEP_PORT_OFFSET)}

            ,{{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (PORT0_100G_OFFSET + 0x000000A8, PORT0_100G_OFFSET + 0x000000B0)} , FORMULA_SINGLE_PARAMETER(NUM_PORTS_PER_UNIT , MAC_STEP_PORT_OFFSET)}
            ,{{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (PORT0_100G_OFFSET + 0x000000B8, PORT0_100G_OFFSET + 0x000000B8)} , FORMULA_SINGLE_PARAMETER(NUM_PORTS_PER_UNIT , MAC_STEP_PORT_OFFSET)}
            ,{{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (PORT0_100G_OFFSET + 0x000000C0, PORT0_100G_OFFSET + 0x000000C0)} , FORMULA_SINGLE_PARAMETER(NUM_PORTS_PER_UNIT , MAC_STEP_PORT_OFFSET)}
            ,{{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (PORT0_100G_OFFSET + 0x000000C8, PORT0_100G_OFFSET + 0x000000C8)} , FORMULA_SINGLE_PARAMETER(NUM_PORTS_PER_UNIT , MAC_STEP_PORT_OFFSET)}
            ,{{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (PORT0_100G_OFFSET + 0x000000D0, PORT0_100G_OFFSET + 0x000000D0)} , FORMULA_SINGLE_PARAMETER(NUM_PORTS_PER_UNIT , MAC_STEP_PORT_OFFSET)}
            ,{{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (PORT0_100G_OFFSET + 0x000000D8, PORT0_100G_OFFSET + 0x000000D8)} , FORMULA_SINGLE_PARAMETER(NUM_PORTS_PER_UNIT , MAC_STEP_PORT_OFFSET)}
            ,{{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (PORT0_100G_OFFSET + 0x000000E0, PORT0_100G_OFFSET + 0x000000E8)} , FORMULA_SINGLE_PARAMETER(NUM_PORTS_PER_UNIT , MAC_STEP_PORT_OFFSET)}
            ,{{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (PORT0_100G_OFFSET + 0x00000108, PORT0_100G_OFFSET + 0x00000114)} , FORMULA_SINGLE_PARAMETER(NUM_PORTS_PER_UNIT , MAC_STEP_PORT_OFFSET)}
            ,{{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (PORT0_100G_OFFSET + 0x0000011C, PORT0_100G_OFFSET + 0x00000120)} , FORMULA_SINGLE_PARAMETER(NUM_PORTS_PER_UNIT , MAC_STEP_PORT_OFFSET)}
            ,{{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (PORT0_100G_OFFSET + 0x00000154, PORT0_100G_OFFSET + 0x00000174)} , FORMULA_SINGLE_PARAMETER(NUM_PORTS_PER_UNIT , MAC_STEP_PORT_OFFSET)}
        };
        GT_U32  numOfChunks = sizeof(chunksMem)/sizeof(SMEM_CHUNK_EXTENDED_STC);
        SMEM_UNIT_CHUNKS_STC    tmpUnitChunk;

        smemInitMemChunkExt(devObjPtr,chunksMem, numOfChunks, &tmpUnitChunk);
        /*add the tmp unit chunks to the main unit */
        smemInitMemCombineUnitChunks(devObjPtr,unitPtr,&tmpUnitChunk);
    }
    /* MAC 100G - end */

    /* MAC 400G EXT GLOBAL - start */
    {
        SMEM_CHUNK_BASIC_STC  chunksMem[]=
        {
            /* GLOBAL */
             {SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (MAC_EXT_BASE_OFFSET + 0x00000000, MAC_EXT_BASE_OFFSET + 0x00000008)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (MAC_EXT_BASE_OFFSET + 0x00000010, MAC_EXT_BASE_OFFSET + 0x0000002C)}
        };
        GT_U32  numOfChunks = sizeof(chunksMem)/sizeof(SMEM_CHUNK_BASIC_STC);
        SMEM_UNIT_CHUNKS_STC    tmpUnitChunk;

        smemInitMemChunk(devObjPtr,chunksMem, numOfChunks, &tmpUnitChunk);
        /*add the tmp unit chunks to the main unit */
        smemInitMemCombineUnitChunks(devObjPtr,unitPtr,&tmpUnitChunk);
    }
    /* MAC 400G EXT GLOBAL - end */


    /* MAC 400G EXT port - start */
    {
        SMEM_CHUNK_EXTENDED_STC  chunksMem[]=
        {
            /* per MAC */
            {{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (MAC_EXT_BASE_OFFSET + 0x00000100, MAC_EXT_BASE_OFFSET + 0x00000128)} , FORMULA_SINGLE_PARAMETER((NUM_PORTS_PER_UNIT+1) , 0x100)}
           ,{{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (MAC_EXT_BASE_OFFSET + 0x00000130, MAC_EXT_BASE_OFFSET + 0x00000144)} , FORMULA_SINGLE_PARAMETER((NUM_PORTS_PER_UNIT+1) , 0x100)}
           ,{{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (MAC_EXT_BASE_OFFSET + 0x00000150, MAC_EXT_BASE_OFFSET + 0x00000160)} , FORMULA_SINGLE_PARAMETER((NUM_PORTS_PER_UNIT+1) , 0x100)}
           ,{{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (MAC_EXT_BASE_OFFSET + 0x00000168, MAC_EXT_BASE_OFFSET + 0x00000188)} , FORMULA_SINGLE_PARAMETER((NUM_PORTS_PER_UNIT+1) , 0x100)}
           ,{{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (MAC_EXT_BASE_OFFSET + 0x00000190, MAC_EXT_BASE_OFFSET + 0x0000019C)} , FORMULA_SINGLE_PARAMETER((NUM_PORTS_PER_UNIT+1) , 0x100)}

        };
        GT_U32  numOfChunks = sizeof(chunksMem)/sizeof(SMEM_CHUNK_EXTENDED_STC);
        SMEM_UNIT_CHUNKS_STC    tmpUnitChunk;

        smemInitMemChunkExt(devObjPtr,chunksMem, numOfChunks, &tmpUnitChunk);
        /*add the tmp unit chunks to the main unit */
        smemInitMemCombineUnitChunks(devObjPtr,unitPtr,&tmpUnitChunk);
    }
    /* MAC 400G EXT port - end */

   {
        static SMEM_REGISTER_DEFAULT_VALUE_STC myUnit_registersDefaultValueArr[] =
        {
            /* MAC 400G GLOBAL EXT - start */
             {DUMMY_NAME_PTR_CNS,            0x00000004,         0x0000c350,      1,    0x4}
            ,{DUMMY_NAME_PTR_CNS,            0x00000008,         0x1bc207ff,      1,    0x4}
            ,{DUMMY_NAME_PTR_CNS,            0x00000024,         0x0000ffff,      1,    0x4}
           /* MAC 400G GLOBAL EXT - end */

           /* MAC 400G EXT - start */
            ,{DUMMY_NAME_PTR_CNS,            0x00000100,         0x0003ff10,      9,    0x100}
            ,{DUMMY_NAME_PTR_CNS,            0x00000124,         0x0000000f,      9,    0x100}
            ,{DUMMY_NAME_PTR_CNS,            0x00000170,         0x01000100,      9,    0x100}
            ,{DUMMY_NAME_PTR_CNS,            0x00000188,         0x00000007,      9,    0x100}
           /* MAC 400G EXT - end */

            /* MAC 400G - start */
            ,{DUMMY_NAME_PTR_CNS,            0x00009000,         0x00010102,      1,    0x4}
            ,{DUMMY_NAME_PTR_CNS,            0x00009008,         0x00000800,      1,    0x4}
            ,{DUMMY_NAME_PTR_CNS,            0x00009014,         0x00000600,      1,    0x4}
            ,{DUMMY_NAME_PTR_CNS,            0x0000901c,         0x00000001,      1,    0x4}
            ,{DUMMY_NAME_PTR_CNS,            0x00009020,         0x00000008,      1,    0x4}
            ,{DUMMY_NAME_PTR_CNS,            0x00009044,         0x5000000c,      1,    0x4}
            /* MAC 400G - end */

            /* MAC 100G - start */
            ,{DUMMY_NAME_PTR_CNS,            0x00001000,         0x00010200,      8,    0x1000}
            ,{DUMMY_NAME_PTR_CNS,            0x00001014,         0x00000600,      8,    0x1000}
            ,{DUMMY_NAME_PTR_CNS,            0x0000101c,         0x00000001,      8,    0x1000}
            ,{DUMMY_NAME_PTR_CNS,            0x00001020,         0x00000007,      8,    0x1000}
            ,{DUMMY_NAME_PTR_CNS,            0x00001040,         0x00600364,      8,    0x1000}
            ,{DUMMY_NAME_PTR_CNS,            0x00001044,         0x0000000c,      8,    0x1000}
            ,{DUMMY_NAME_PTR_CNS,            0x00001080,         0x00000100,      8,    0x1000}
            ,{DUMMY_NAME_PTR_CNS,            0x000010a8,         0x01780a00,      8,    0x1000}
            ,{DUMMY_NAME_PTR_CNS,            0x000010ac,         0x00000001,      8,    0x1000}
            ,{DUMMY_NAME_PTR_CNS,            0x00001114,         0x00000600,      8,    0x1000}
            ,{DUMMY_NAME_PTR_CNS,            0x0000111c,         0x00000001,      8,    0x1000}
            ,{DUMMY_NAME_PTR_CNS,            0x00001120,         0x00000007,      8,    0x1000}
            /* MAC 100G - end */

            ,{NULL,            0,         0x00000000,      0,    0x0      }
        };
        static SMEM_LINK_LIST_REGISTER_DEFAULT_VALUE_STC list = {myUnit_registersDefaultValueArr,NULL};
        unitPtr->unitDefaultRegistersPtr = &list;
    }
}

/**
* @internal smemAasUnitPcs400G function
* @endinternal
*
* @brief   Allocate address type specific memories -- for the MAC 400G unit wrapper
*/
static void smemAasUnitPcs400G
(
    IN SKERNEL_DEVICE_OBJECT *devObjPtr,
    IN SMEM_UNIT_CHUNKS_STC  *unitPtr
)
{
    START_BIND_UNIT_ACTIVE_MEM_MAC(devObjPtr,unitPtr)

        {PCS_400G_OFFSET + 0x00000000, SMEM_FULL_MASK_CNS, NULL, 0, smemFalconActiveWritePcsControl1, 0},
        {PCS_200G_OFFSET + 0x00000000, SMEM_FULL_MASK_CNS, NULL, 0, smemFalconActiveWritePcsControl1, 0},
        {PCS_400G_OFFSET + 0x00002000, SMEM_FULL_MASK_CNS, NULL, 0, smemFalconActiveWritePcsControl1, 0},
        {PCS_200G_OFFSET + 0x00002000, SMEM_FULL_MASK_CNS, NULL, 0, smemFalconActiveWritePcsControl1, 0},

#if 0

        {PCS_PORT0_100G_OFFSET + PCS_STEP_PORT_OFFSET * 0 + 0x00000000, SMEM_FULL_MASK_CNS, NULL, 0, smemFalconActiveWritePcsControl1, 0},
        {PCS_PORT0_100G_OFFSET + PCS_STEP_PORT_OFFSET * 1 + 0x00000000, SMEM_FULL_MASK_CNS, NULL, 0, smemFalconActiveWritePcsControl1, 0},
        {PCS_PORT0_100G_OFFSET + PCS_STEP_PORT_OFFSET * 2 + 0x00000000, SMEM_FULL_MASK_CNS, NULL, 0, smemFalconActiveWritePcsControl1, 0},
        {PCS_PORT0_100G_OFFSET + PCS_STEP_PORT_OFFSET * 3 + 0x00000000, SMEM_FULL_MASK_CNS, NULL, 0, smemFalconActiveWritePcsControl1, 0},
        {PCS_PORT0_100G_OFFSET + PCS_STEP_PORT_OFFSET * 4 + 0x00000000, SMEM_FULL_MASK_CNS, NULL, 0, smemFalconActiveWritePcsControl1, 0},
        {PCS_PORT0_100G_OFFSET + PCS_STEP_PORT_OFFSET * 5 + 0x00000000, SMEM_FULL_MASK_CNS, NULL, 0, smemFalconActiveWritePcsControl1, 0},
        {PCS_PORT0_100G_OFFSET + PCS_STEP_PORT_OFFSET * 6 + 0x00000000, SMEM_FULL_MASK_CNS, NULL, 0, smemFalconActiveWritePcsControl1, 0},
        {PCS_PORT0_100G_OFFSET + PCS_STEP_PORT_OFFSET * 7 + 0x00000000, SMEM_FULL_MASK_CNS, NULL, 0, smemFalconActiveWritePcsControl1, 0},
        /* support 4 ports in LPCS  */
        {PCS_LPCS_OFFSET      + LPCS_STEP_PORT_OFFSET * 0 + 0x00000000, SMEM_FULL_MASK_CNS , NULL, 0, smemFalconActiveWritePcsControl1, 0},
        {PCS_LPCS_OFFSET      + LPCS_STEP_PORT_OFFSET * 1 + 0x00000000, SMEM_FULL_MASK_CNS , NULL, 0, smemFalconActiveWritePcsControl1, 0},
        {PCS_LPCS_OFFSET      + LPCS_STEP_PORT_OFFSET * 2 + 0x00000000, SMEM_FULL_MASK_CNS , NULL, 0, smemFalconActiveWritePcsControl1, 0},
        {PCS_LPCS_OFFSET      + LPCS_STEP_PORT_OFFSET * 3 + 0x00000000, SMEM_FULL_MASK_CNS , NULL, 0, smemFalconActiveWritePcsControl1, 0},
        {PCS_LPCS_OFFSET      + LPCS_STEP_PORT_OFFSET * 4 + 0x00000000, SMEM_FULL_MASK_CNS , NULL, 0, smemFalconActiveWritePcsControl1, 0},
        {PCS_LPCS_OFFSET      + LPCS_STEP_PORT_OFFSET * 5 + 0x00000000, SMEM_FULL_MASK_CNS , NULL, 0, smemFalconActiveWritePcsControl1, 0},
        {PCS_LPCS_OFFSET      + LPCS_STEP_PORT_OFFSET * 6 + 0x00000000, SMEM_FULL_MASK_CNS , NULL, 0, smemFalconActiveWritePcsControl1, 0},
        {PCS_LPCS_OFFSET      + LPCS_STEP_PORT_OFFSET * 7 + 0x00000000, SMEM_FULL_MASK_CNS , NULL, 0, smemFalconActiveWritePcsControl1, 0},
#endif

        /* BASER_STATUS1 */
        {PCS_PORT0_100G_OFFSET + PCS_STEP_PORT_OFFSET * 0 + 0x00000080, SMEM_FULL_MASK_CNS, smemChtActiveReadConst, 0x1, NULL, 0},
        {PCS_PORT0_100G_OFFSET + PCS_STEP_PORT_OFFSET * 1 + 0x00000080, SMEM_FULL_MASK_CNS, smemChtActiveReadConst, 0x1, NULL, 0},
        {PCS_PORT0_100G_OFFSET + PCS_STEP_PORT_OFFSET * 2 + 0x00000080, SMEM_FULL_MASK_CNS, smemChtActiveReadConst, 0x1, NULL, 0},
        {PCS_PORT0_100G_OFFSET + PCS_STEP_PORT_OFFSET * 3 + 0x00000080, SMEM_FULL_MASK_CNS, smemChtActiveReadConst, 0x1, NULL, 0},
        {PCS_PORT0_100G_OFFSET + PCS_STEP_PORT_OFFSET * 4 + 0x00000080, SMEM_FULL_MASK_CNS, smemChtActiveReadConst, 0x1, NULL, 0},
        {PCS_PORT0_100G_OFFSET + PCS_STEP_PORT_OFFSET * 5 + 0x00000080, SMEM_FULL_MASK_CNS, smemChtActiveReadConst, 0x1, NULL, 0},
        {PCS_PORT0_100G_OFFSET + PCS_STEP_PORT_OFFSET * 6 + 0x00000080, SMEM_FULL_MASK_CNS, smemChtActiveReadConst, 0x1, NULL, 0},
        {PCS_PORT0_100G_OFFSET + PCS_STEP_PORT_OFFSET * 7 + 0x00000080, SMEM_FULL_MASK_CNS, smemChtActiveReadConst, 0x1, NULL, 0},

    END_BIND_UNIT_ACTIVE_MEM_MAC(devObjPtr,unitPtr)

    {
        SMEM_CHUNK_BASIC_STC  chunksMem[]=
        {
            /* PCS-800G_EXT - start */
             {SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000000, 0x0000007C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000088, 0x00000098)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000000A0, 0x000000B0)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000000B8, 0x000000C8)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000000D0, 0x000000E0)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000000E8, 0x000000F8)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000100, 0x00000110)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000118, 0x00000128)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000130, 0x00000140)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000148, 0x00000158)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000160, 0x00000170)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000178, 0x00000188)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000190, 0x000001A0)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000001A8, 0x000001B8)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000001C0, 0x000001D0)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000001D8, 0x000001E8)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000001F0, 0x00000218)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000300, 0x000007FC)}
            /* PCS-800G_EXT - end */

             /* PCS-LPCS - start */
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00013000, 0x00013020)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00013040, 0x0001305C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00013080, 0x000130A0)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000130C0, 0x000130DC)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00013100, 0x00013120)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00013140, 0x0001315C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00013180, 0x000131A0)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000131C0, 0x000131DC)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00013200, 0x00013220)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00013240, 0x0001325C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00013280, 0x000132A0)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000132C0, 0x000132DC)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00013300, 0x00013320)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00013340, 0x0001335C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00013380, 0x000133A0)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000133C0, 0x000133F4)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00014000, 0x00014020)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00014040, 0x0001405C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00014080, 0x000140A0)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000140C0, 0x000140DC)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00014100, 0x00014120)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00014140, 0x0001415C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00014180, 0x000141A0)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000141C0, 0x000141DC)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00014200, 0x00014220)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00014240, 0x0001425C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00014280, 0x000142A0)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000142C0, 0x000142DC)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00014300, 0x00014320)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00014340, 0x0001435C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00014380, 0x000143A0)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000143C0, 0x000143F4)}
            /* PCS-LPCS - end */

             /* PCS-100G - start (ports = 0,2,4,6,8,10,12,14) */
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001000, 0x00001020)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001038, 0x0000103C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001080, 0x000010B4)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000010C8, 0x000010D4)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001320, 0x0000136C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001640, 0x0000168C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001800, 0x0000180C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001820, 0x00001840)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001900, 0x0000199C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00003000, 0x00003020)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00003038, 0x0000303C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00003080, 0x000030B4)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000030C8, 0x000030D4)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00003320, 0x0000336C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00003640, 0x0000368C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00003800, 0x0000380C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00003820, 0x00003840)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00003900, 0x0000399C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00005000, 0x00005020)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00005038, 0x0000503C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00005080, 0x000050B4)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000050C8, 0x000050D4)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00005320, 0x0000536C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00005640, 0x0000568C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00005800, 0x0000580C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00005820, 0x00005840)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00005900, 0x0000599C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00007000, 0x00007020)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00007038, 0x0000703C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00007080, 0x000070B4)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000070C8, 0x000070D4)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00007320, 0x0000736C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00007640, 0x0000768C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00007800, 0x0000780C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00007820, 0x00007840)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00007900, 0x0000799C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00009000, 0x00009020)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00009038, 0x0000903C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00009080, 0x000090B4)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000090C8, 0x000090D4)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00009320, 0x0000936C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00009640, 0x0000968C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00009800, 0x0000980C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00009820, 0x00009840)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00009900, 0x0000999C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x0000B000, 0x0000B020)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x0000B038, 0x0000B03C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x0000B080, 0x0000B0B4)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x0000B0C8, 0x0000B0D4)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x0000B320, 0x0000B36C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x0000B640, 0x0000B68C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x0000B800, 0x0000B80C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x0000B820, 0x0000B840)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x0000B900, 0x0000B99C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x0000D000, 0x0000D020)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x0000D038, 0x0000D03C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x0000D080, 0x0000D0B4)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x0000D0C8, 0x0000D0D4)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x0000D320, 0x0000D36C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x0000D640, 0x0000D68C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x0000D800, 0x0000D80C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x0000D820, 0x0000D840)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x0000D900, 0x0000D99C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x0000F000, 0x0000F020)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x0000F038, 0x0000F03C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x0000F080, 0x0000F0B4)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x0000F0C8, 0x0000F0D4)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x0000F320, 0x0000F36C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x0000F640, 0x0000F68C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x0000F800, 0x0000F80C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x0000F820, 0x0000F840)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x0000F900, 0x0000F99C)}
             /* PCS-100G - end */

             /* PCS-200G - start (ports 4, 12)*/
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00018000, 0x00018024)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00018038, 0x0001803C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00018080, 0x00018084)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000180A8, 0x000180B4)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000180C8, 0x000180C8)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00018100, 0x0001811C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x0001A000, 0x0001A024)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x0001A038, 0x0001A03C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x0001A080, 0x0001A084)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x0001A0A8, 0x0001A0B4)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x0001A0C8, 0x0001A0C8)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x0001A100, 0x0001A11C)}
             /* PCS-200G - end */

            /* PCS-400G - start (ports 0,8)*/
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00017000, 0x00017024)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00017038, 0x0001703C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00017080, 0x00017084)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000170A8, 0x000170B4)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000170C8, 0x000170C8)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000170D0, 0x000170D4)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00017640, 0x0001767C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00017800, 0x0001780C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x0001781C, 0x00017824)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00017A00, 0x00017A0C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00019000, 0x00019024)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00019038, 0x0001903C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00019080, 0x00019084)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000190A8, 0x000190B4)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000190C8, 0x000190C8)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000190D0, 0x000190D4)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00019640, 0x0001967C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00019800, 0x0001980C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x0001981C, 0x00019824)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00019A00, 0x00019A0C)}
             /* PCS-400G - end */

             /* PCS-50G - start (ports = 1,3,5,7,9,11,13,15) */
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00002000, 0x00002020)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00002038, 0x0000203C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00002080, 0x000020B4)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000020C8, 0x000020C8)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000020D0, 0x000020D0)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00002320, 0x0000232C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00002640, 0x0000264C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00002800, 0x00002810)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00002820, 0x00002840)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00002900, 0x0000291C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00004000, 0x00004020)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00004038, 0x0000403C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00004080, 0x000040B4)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000040C8, 0x000040C8)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000040D0, 0x000040D0)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00004320, 0x0000432C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00004640, 0x0000464C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00004800, 0x00004810)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00004820, 0x00004840)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00004900, 0x0000491C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00006000, 0x00006020)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00006038, 0x0000603C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00006080, 0x000060B4)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000060C8, 0x000060C8)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000060D0, 0x000060D0)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00006320, 0x0000632C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00006640, 0x0000664C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00006800, 0x00006810)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00006820, 0x00006840)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00006900, 0x0000691C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00008000, 0x00008020)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00008038, 0x0000803C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00008080, 0x000080B4)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000080C8, 0x000080C8)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000080D0, 0x000080D0)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00008320, 0x0000832C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00008640, 0x0000864C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00008800, 0x00008810)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00008820, 0x00008840)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00008900, 0x0000891C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x0000A000, 0x0000A020)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x0000A038, 0x0000A03C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x0000A080, 0x0000A0B4)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x0000A0C8, 0x0000A0C8)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x0000A0D0, 0x0000A0D0)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x0000A320, 0x0000A32C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x0000A640, 0x0000A64C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x0000A800, 0x0000A810)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x0000A820, 0x0000A840)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x0000A900, 0x0000A91C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x0000C000, 0x0000C020)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x0000C038, 0x0000C03C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x0000C080, 0x0000C0B4)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x0000C0C8, 0x0000C0C8)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x0000C0D0, 0x0000C0D0)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x0000C320, 0x0000C32C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x0000C640, 0x0000C64C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x0000C800, 0x0000C810)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x0000C820, 0x0000C840)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x0000C900, 0x0000C91C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x0000E000, 0x0000E020)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x0000E038, 0x0000E03C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x0000E080, 0x0000E0B4)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x0000E0C8, 0x0000E0C8)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x0000E0D0, 0x0000E0D0)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x0000E320, 0x0000E32C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x0000E640, 0x0000E64C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x0000E800, 0x0000E810)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x0000E820, 0x0000E840)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x0000E900, 0x0000E91C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00010000, 0x00010020)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00010038, 0x0001003C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00010080, 0x000100B4)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000100C8, 0x000100C8)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000100D0, 0x000100D0)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00010320, 0x0001032C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00010640, 0x0001064C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00010800, 0x00010810)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00010820, 0x00010840)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00010900, 0x0001091C)}
             /* PCS-50G - end */

             /* PCS-RSFEC - start */
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00011000, 0x00011108)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00011110, 0x0001112C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00011180, 0x0001127C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00011284, 0x00011290)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000112C0, 0x000112C0)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000112C8, 0x000112C8)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000112D0, 0x000112D0)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000112D8, 0x000112D8)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000112E0, 0x000112E0)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000112E8, 0x000112E8)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000112F0, 0x000112F0)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000112F8, 0x000112F8)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00012000, 0x00012108)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00012110, 0x0001212C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00012180, 0x0001227C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00012284, 0x00012290)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000122C0, 0x000122C0)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000122C8, 0x000122C8)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000122D0, 0x000122D0)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000122D8, 0x000122D8)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000122E0, 0x000122E0)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000122E8, 0x000122E8)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000122F0, 0x000122F0)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000122F8, 0x000122F8)}
             /* PCS-RSFEC - end */

             /* PCS-RSFEC-STATISTIC - start */
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00015000, 0x00015014)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x0001501C, 0x000152EC)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00016000, 0x00016014)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x0001601C, 0x000162EC)}
             /* PCS-RSFEC-STATISTIC - end */

        };
        GT_U32  numOfChunks = sizeof(chunksMem)/sizeof(SMEM_CHUNK_BASIC_STC);

        smemInitMemChunk(devObjPtr,chunksMem, numOfChunks, unitPtr);
    }

    {
        static SMEM_REGISTER_DEFAULT_VALUE_STC myUnit_registersDefaultValueArr[] =
        {
             {DUMMY_NAME_PTR_CNS,        0x00000000 + 0x0000000c,         0x00000200,      1,    0x0            }

            /*PCS100*/
            ,{DUMMY_NAME_PTR_CNS,        0x00001000 + 0x00000000,         0x00002040,      8,    0x2000         }
            ,{DUMMY_NAME_PTR_CNS,        0x00001000 + 0x00000808,         0x00003fff,      8,    0x2000         }
            ,{DUMMY_NAME_PTR_CNS,        0x00001000 + 0x00000840,         0x00000303,      8,    0x2000         }
            ,{DUMMY_NAME_PTR_CNS,        0x00001000 + 0x00000900,         0x000068c1,      8,    0x2000         }
            ,{DUMMY_NAME_PTR_CNS,        0x00001000 + 0x00000904,         0x00000021,      8,    0x2000         }
            ,{DUMMY_NAME_PTR_CNS,        0x00001000 + 0x00000908,         0x0000719d,      8,    0x2000         }
            ,{DUMMY_NAME_PTR_CNS,        0x00001000 + 0x0000090C,         0x0000008e,      8,    0x2000         }
            ,{DUMMY_NAME_PTR_CNS,        0x00001000 + 0x00000910,         0x00004b59,      8,    0x2000         }
            ,{DUMMY_NAME_PTR_CNS,        0x00001000 + 0x00000914,         0x000000e8,      8,    0x2000         }
            ,{DUMMY_NAME_PTR_CNS,        0x00001000 + 0x00000918,         0x0000954d,      8,    0x2000         }
            ,{DUMMY_NAME_PTR_CNS,        0x00001000 + 0x0000091C,         0x0000007b,      8,    0x2000         }
            ,{DUMMY_NAME_PTR_CNS,        0x00001000 + 0x00000920,         0x000007F5,      8,    0x2000         }
            ,{DUMMY_NAME_PTR_CNS,        0x00001000 + 0x00000924,         0x00000009,      8,    0x2000         }
            ,{DUMMY_NAME_PTR_CNS,        0x00001000 + 0x00000928,         0x000014DD,      8,    0x2000         }
            ,{DUMMY_NAME_PTR_CNS,        0x00001000 + 0x0000092C,         0x000000C2,      8,    0x2000         }

            /*PCS50*/
            ,{DUMMY_NAME_PTR_CNS,        0x00002000 + 0x00000000,         0x00002040,      8,    0x2000         }
            ,{DUMMY_NAME_PTR_CNS,        0x00002000 + 0x00000808,         0x00003fff,      8,    0x2000         }
            ,{DUMMY_NAME_PTR_CNS,        0x00002000 + 0x00000840,         0x00000303,      8,    0x2000         }
            ,{DUMMY_NAME_PTR_CNS,        0x00002000 + 0x00000900,         0x00007690,      8,    0x2000         }
            ,{DUMMY_NAME_PTR_CNS,        0x00002000 + 0x00000904,         0x00000047,      8,    0x2000         }
            ,{DUMMY_NAME_PTR_CNS,        0x00002000 + 0x00000908,         0x0000C4F0,      8,    0x2000         }
            ,{DUMMY_NAME_PTR_CNS,        0x00002000 + 0x0000090C,         0x000000E6,      8,    0x2000         }
            ,{DUMMY_NAME_PTR_CNS,        0x00002000 + 0x00000910,         0x000065C5,      8,    0x2000         }
            ,{DUMMY_NAME_PTR_CNS,        0x00002000 + 0x00000914,         0x0000009b,      8,    0x2000         }
            ,{DUMMY_NAME_PTR_CNS,        0x00002000 + 0x00000918,         0x000079A2,      8,    0x2000         }
            ,{DUMMY_NAME_PTR_CNS,        0x00002000 + 0x0000091C,         0x0000003D,      8,    0x2000         }

            /*PCS400*/
            ,{DUMMY_NAME_PTR_CNS,        0x00017000 + 0x00000000,         0x00002068,      2,    0x2000         }
            ,{DUMMY_NAME_PTR_CNS,        0x00017000 + 0x00000010,         0x00000300,      2,    0x2000         }
            ,{DUMMY_NAME_PTR_CNS,        0x00017000 + 0x00000014,         0x00000008,      2,    0x2000         }
            ,{DUMMY_NAME_PTR_CNS,        0x00017000 + 0x0000001c,         0x0000000d,      2,    0x2000         }
            ,{DUMMY_NAME_PTR_CNS,        0x00017000 + 0x00000020,         0x00008000,      2,    0x2000         }
            ,{DUMMY_NAME_PTR_CNS,        0x00017000 + 0x00000024,         0x00000003,      2,    0x2000         }
            ,{DUMMY_NAME_PTR_CNS,        0x00017000 + 0x000000b4,         0x00008000,      2,    0x2000         }
            ,{DUMMY_NAME_PTR_CNS,        0x00017000 + 0x00000804,         0x00004220,      2,    0x2000         }
            ,{DUMMY_NAME_PTR_CNS,        0x00017000 + 0x00000808,         0x00002000,      2,    0x2000         }
            ,{DUMMY_NAME_PTR_CNS,        0x00017000 + 0x0000080c,         0x00000009,      2,    0x2000         }
            ,{DUMMY_NAME_PTR_CNS,        0x00017000 + 0x0000081c,         0x00000008,      2,    0x2000         }
            ,{DUMMY_NAME_PTR_CNS,        0x00017000 + 0x00000820,         0x00004a9a,      2,    0x2000         }
            ,{DUMMY_NAME_PTR_CNS,        0x00017000 + 0x00000824,         0x00000026,      2,    0x2000         }

            ,{DUMMY_NAME_PTR_CNS,        0x00011000 + 0x00000004,         0x0000000a,      2,    0x1000         }
            ,{DUMMY_NAME_PTR_CNS,        0x00011000 + 0x0000001c,         0x00000033,      2,    0x1000         }
            ,{DUMMY_NAME_PTR_CNS,        0x00011000 + 0x00000024,         0x00000002,      2,    0x1000         }
            ,{DUMMY_NAME_PTR_CNS,        0x00011000 + 0x00000044,         0x00000002,      2,    0x1000         }
            ,{DUMMY_NAME_PTR_CNS,        0x00011000 + 0x00000064,         0x00000002,      2,    0x1000         }
            ,{DUMMY_NAME_PTR_CNS,        0x00011000 + 0x00000084,         0x0000000a,      2,    0x1000         }
            ,{DUMMY_NAME_PTR_CNS,        0x00011000 + 0x000000a4,         0x00000002,      2,    0x1000         }
            ,{DUMMY_NAME_PTR_CNS,        0x00011000 + 0x000000c4,         0x00000002,      2,    0x1000         }
            ,{DUMMY_NAME_PTR_CNS,        0x00011000 + 0x000000e4,         0x00000002,      2,    0x1000         }
            ,{DUMMY_NAME_PTR_CNS,        0x00011000 + 0x00000100,         0x00002000,      2,    0x1000         }
            ,{DUMMY_NAME_PTR_CNS,        0x00011000 + 0x00000104,         0x000015b8,      2,    0x1000         }
            ,{DUMMY_NAME_PTR_CNS,        0x00011000 + 0x00000108,         0x0000023d,      2,    0x1000         }
            ,{DUMMY_NAME_PTR_CNS,        0x00011000 + 0x00000180,         0x00007101,      2,    0x1000         }
            ,{DUMMY_NAME_PTR_CNS,        0x00011000 + 0x00000184,         0x000000f3,      2,    0x1000         }
            ,{DUMMY_NAME_PTR_CNS,        0x00011000 + 0x00000188,         0x0000de5a,      2,    0x1000         }
            ,{DUMMY_NAME_PTR_CNS,        0x00011000 + 0x0000018c,         0x0000007e,      2,    0x1000         }
            ,{DUMMY_NAME_PTR_CNS,        0x00011000 + 0x00000190,         0x0000f33e,      2,    0x1000         }
            ,{DUMMY_NAME_PTR_CNS,        0x00011000 + 0x00000194,         0x00000056,      2,    0x1000         }
            ,{DUMMY_NAME_PTR_CNS,        0x00011000 + 0x00000198,         0x00008086,      2,    0x1000         }
            ,{DUMMY_NAME_PTR_CNS,        0x00011000 + 0x0000019c,         0x000000d0,      2,    0x1000         }
            ,{DUMMY_NAME_PTR_CNS,        0x00011000 + 0x000001a0,         0x0000512a,      2,    0x1000         }
            ,{DUMMY_NAME_PTR_CNS,        0x00011000 + 0x000001a4,         0x000000f2,      2,    0x1000         }
            ,{DUMMY_NAME_PTR_CNS,        0x00011000 + 0x000001a8,         0x00004f12,      2,    0x1000         }
            ,{DUMMY_NAME_PTR_CNS,        0x00011000 + 0x000001ac,         0x000000d1,      2,    0x1000         }
            ,{DUMMY_NAME_PTR_CNS,        0x00011000 + 0x000001b0,         0x00009c42,      2,    0x1000         }
            ,{DUMMY_NAME_PTR_CNS,        0x00011000 + 0x000001b4,         0x000000a1,      2,    0x1000         }
            ,{DUMMY_NAME_PTR_CNS,        0x00011000 + 0x000001b8,         0x000076d6,      2,    0x1000         }
            ,{DUMMY_NAME_PTR_CNS,        0x00011000 + 0x000001bc,         0x0000005b,      2,    0x1000         }
            ,{DUMMY_NAME_PTR_CNS,        0x00011000 + 0x000001c0,         0x000073e1,      2,    0x1000         }
            ,{DUMMY_NAME_PTR_CNS,        0x00011000 + 0x000001c4,         0x00000075,      2,    0x1000         }
            ,{DUMMY_NAME_PTR_CNS,        0x00011000 + 0x000001c8,         0x0000c471,      2,    0x1000         }
            ,{DUMMY_NAME_PTR_CNS,        0x00011000 + 0x000001cc,         0x0000003c,      2,    0x1000         }
            ,{DUMMY_NAME_PTR_CNS,        0x00011000 + 0x000001d0,         0x0000eb95,      2,    0x1000         }
            ,{DUMMY_NAME_PTR_CNS,        0x00011000 + 0x000001d4,         0x000000d8,      2,    0x1000         }
            ,{DUMMY_NAME_PTR_CNS,        0x00011000 + 0x000001d8,         0x00006622,      2,    0x1000         }
            ,{DUMMY_NAME_PTR_CNS,        0x00011000 + 0x000001dc,         0x00000038,      2,    0x1000         }
            ,{DUMMY_NAME_PTR_CNS,        0x00011000 + 0x000001e0,         0x0000f6a2,      2,    0x1000         }
            ,{DUMMY_NAME_PTR_CNS,        0x00011000 + 0x000001e4,         0x00000095,      2,    0x1000         }
            ,{DUMMY_NAME_PTR_CNS,        0x00011000 + 0x000001e8,         0x00009731,      2,    0x1000         }
            ,{DUMMY_NAME_PTR_CNS,        0x00011000 + 0x000001ec,         0x000000c3,      2,    0x1000         }
            ,{DUMMY_NAME_PTR_CNS,        0x00011000 + 0x000001f0,         0x0000fbca,      2,    0x1000         }
            ,{DUMMY_NAME_PTR_CNS,        0x00011000 + 0x000001f4,         0x000000a6,      2,    0x1000         }
            ,{DUMMY_NAME_PTR_CNS,        0x00011000 + 0x000001f8,         0x0000baa6,      2,    0x1000         }
            ,{DUMMY_NAME_PTR_CNS,        0x00011000 + 0x000001fc,         0x00000079,      2,    0x1000         }
            ,{DUMMY_NAME_PTR_CNS,        0x00011000 + 0x0000028c,         0x00000140,      2,    0x1000         }
            ,{DUMMY_NAME_PTR_CNS,        0x00011000 + 0x000002c0,         0x000018ec,      2,    0x1000         }
            ,{DUMMY_NAME_PTR_CNS,        0x00011000 + 0x000002c8,         0x000018ec,      2,    0x1000         }
            ,{DUMMY_NAME_PTR_CNS,        0x00011000 + 0x000002d0,         0x000018ec,      2,    0x1000         }
            ,{DUMMY_NAME_PTR_CNS,        0x00011000 + 0x000002d8,         0x000018ec,      2,    0x1000         }
            ,{DUMMY_NAME_PTR_CNS,        0x00011000 + 0x000002e0,         0x000018ec,      2,    0x1000         }
            ,{DUMMY_NAME_PTR_CNS,        0x00011000 + 0x000002e8,         0x000018ec,      2,    0x1000         }
            ,{DUMMY_NAME_PTR_CNS,        0x00011000 + 0x000002f0,         0x000018ec,      2,    0x1000         }
            ,{DUMMY_NAME_PTR_CNS,        0x00011000 + 0x000002f8,         0x000018ec,      2,    0x1000         }


            ,{NULL,            0,         0x00000000,      0,    0x0      }
        };
        static SMEM_LINK_LIST_REGISTER_DEFAULT_VALUE_STC list = {myUnit_registersDefaultValueArr,NULL};
        unitPtr->unitDefaultRegistersPtr = &list;
    }
}

/**
* @internal smemAasUnitAnp function
* @endinternal
*
* @brief   Allocate address type specific memories - for the ANP
*/
static void smemAasUnitAnp
(
    IN SKERNEL_DEVICE_OBJECT *devObjPtr,
    IN SMEM_UNIT_CHUNKS_STC  *unitPtr
)
{
    {
        START_BIND_UNIT_ACTIVE_MEM_MAC(devObjPtr,unitPtr)
#if 0
            {ANP_OFFSET + 0x00000100 + 0x2a4*0, SMEM_FULL_MASK_CNS, smemChtActiveReadIntrCauseReg, 0, smemChtActiveWriteIntrCauseReg, 0},
            {ANP_OFFSET + 0x00000104 + 0x2a4*0, SMEM_FULL_MASK_CNS, NULL, 0, smemFalconActiveWritePortInterruptsMaskReg, 0},

            {ANP_OFFSET + 0x00000100 + 0x2a4*1, SMEM_FULL_MASK_CNS, smemChtActiveReadIntrCauseReg, 0, smemChtActiveWriteIntrCauseReg, 0},
            {ANP_OFFSET + 0x00000104 + 0x2a4*1, SMEM_FULL_MASK_CNS, NULL, 0, smemFalconActiveWritePortInterruptsMaskReg, 0},

            {ANP_OFFSET + 0x00000100 + 0x2a4*2, SMEM_FULL_MASK_CNS, smemChtActiveReadIntrCauseReg, 0, smemChtActiveWriteIntrCauseReg, 0},
            {ANP_OFFSET + 0x00000104 + 0x2a4*2, SMEM_FULL_MASK_CNS, NULL, 0, smemFalconActiveWritePortInterruptsMaskReg, 0},

            {ANP_OFFSET + 0x00000100 + 0x2a4*3, SMEM_FULL_MASK_CNS, smemChtActiveReadIntrCauseReg, 0, smemChtActiveWriteIntrCauseReg, 0},
            {ANP_OFFSET + 0x00000104 + 0x2a4*3, SMEM_FULL_MASK_CNS, NULL, 0, smemFalconActiveWritePortInterruptsMaskReg, 0},

            {ANP_OFFSET + 0x00000100 + 0x2a4*4, SMEM_FULL_MASK_CNS, smemChtActiveReadIntrCauseReg, 0, smemChtActiveWriteIntrCauseReg, 0},
            {ANP_OFFSET + 0x00000104 + 0x2a4*4, SMEM_FULL_MASK_CNS, NULL, 0, smemFalconActiveWritePortInterruptsMaskReg, 0},

            {ANP_OFFSET + 0x00000100 + 0x2a4*5, SMEM_FULL_MASK_CNS, smemChtActiveReadIntrCauseReg, 0, smemChtActiveWriteIntrCauseReg, 0},
            {ANP_OFFSET + 0x00000104 + 0x2a4*5, SMEM_FULL_MASK_CNS, NULL, 0, smemFalconActiveWritePortInterruptsMaskReg, 0},

            {ANP_OFFSET + 0x00000100 + 0x2a4*6, SMEM_FULL_MASK_CNS, smemChtActiveReadIntrCauseReg, 0, smemChtActiveWriteIntrCauseReg, 0},
            {ANP_OFFSET + 0x00000104 + 0x2a4*6, SMEM_FULL_MASK_CNS, NULL, 0, smemFalconActiveWritePortInterruptsMaskReg, 0},

            {ANP_OFFSET + 0x00000100 + 0x2a4*7, SMEM_FULL_MASK_CNS, smemChtActiveReadIntrCauseReg, 0, smemChtActiveWriteIntrCauseReg, 0},
            {ANP_OFFSET + 0x00000104 + 0x2a4*7, SMEM_FULL_MASK_CNS, NULL, 0, smemFalconActiveWritePortInterruptsMaskReg, 0},
#endif
        END_BIND_UNIT_ACTIVE_MEM_MAC(devObjPtr,unitPtr)
    }


    {
        SMEM_CHUNK_EXTENDED_STC  chunksMem[]=
        {
            /* ANP - start */
             {{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000000, 0x00000068)}}
            ,{{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000070, 0x00000104)}}
           ,{{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001000, 0x0000134C)} , FORMULA_SINGLE_PARAMETER(NUM_PORTS_PER_UNIT, 0x1000)}
             /* ANP - end */

            /* AN - start */
           ,{{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (AN_OFFSET + 0x00000000, AN_OFFSET + 0x0000000c)}, FORMULA_SINGLE_PARAMETER(NUM_PORTS_PER_UNIT, AN_STEP_PORT_OFFSET)}
           ,{{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (AN_OFFSET + 0x00000014, AN_OFFSET + 0x00000018)}, FORMULA_SINGLE_PARAMETER(NUM_PORTS_PER_UNIT, AN_STEP_PORT_OFFSET)}
           ,{{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (AN_OFFSET + 0x00000038, AN_OFFSET + 0x0000006c)}, FORMULA_SINGLE_PARAMETER(NUM_PORTS_PER_UNIT, AN_STEP_PORT_OFFSET)}
           ,{{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (AN_OFFSET + 0x000000c0, AN_OFFSET + 0x000000c4)}, FORMULA_SINGLE_PARAMETER(NUM_PORTS_PER_UNIT, AN_STEP_PORT_OFFSET)}
           ,{{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (AN_OFFSET + 0x00000800, AN_OFFSET + 0x0000086c)}, FORMULA_SINGLE_PARAMETER(NUM_PORTS_PER_UNIT, AN_STEP_PORT_OFFSET)}
           ,{{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (AN_OFFSET + 0x00000880, AN_OFFSET + 0x000008AC)}, FORMULA_SINGLE_PARAMETER(NUM_PORTS_PER_UNIT, AN_STEP_PORT_OFFSET)}
           ,{{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (AN_OFFSET + 0x000008C0, AN_OFFSET + 0x000008F0)}, FORMULA_SINGLE_PARAMETER(NUM_PORTS_PER_UNIT, AN_STEP_PORT_OFFSET)}
            /* AN - end */
        };
        GT_U32  numOfChunks = sizeof(chunksMem)/sizeof(SMEM_CHUNK_EXTENDED_STC);

        smemInitMemChunkExt(devObjPtr,chunksMem, numOfChunks, unitPtr);
    }

    {
        static SMEM_REGISTER_DEFAULT_VALUE_STC myUnit_registersDefaultValueArr[] =
        {
             {DUMMY_NAME_PTR_CNS,        ANP_OFFSET     + 0x00000000,         0xFD02AA46,      1,    0x0            }

            ,{DUMMY_NAME_PTR_CNS,        ANP_OFFSET     + 0x00000004,         0x10814288,      1,    0x0            }
            ,{DUMMY_NAME_PTR_CNS,        ANP_OFFSET     + 0x00000008,         0x10410516,      1,    0x0            }
            ,{DUMMY_NAME_PTR_CNS,        ANP_OFFSET     + 0x0000000c,         0x70000100,      1,    0x0            }
            ,{DUMMY_NAME_PTR_CNS,        ANP_OFFSET     + 0x00000010,         0x00000423,      1,    0x0            }
            ,{DUMMY_NAME_PTR_CNS,        ANP_OFFSET     + 0x00000014,         0x00000003,      1,    0x0            }

            ,{DUMMY_NAME_PTR_CNS,        ANP_OFFSET     + 0x000010d8,         0x0F00C000,      8,    0x1000         }

            ,{NULL,                      0,                                   0x00000000,      0,    0x0            }
        };
        static SMEM_LINK_LIST_REGISTER_DEFAULT_VALUE_STC list = {myUnit_registersDefaultValueArr,NULL};
        unitPtr->unitDefaultRegistersPtr = &list;
    }

}


/**
* @internal smemAasUnitMacCpuWrap function
* @endinternal
*
* @brief   Allocate address type specific memories -- for the MAC CPU unit wrapper
*/
static void smemAasUnitMacCpuWrap
(
    IN SKERNEL_DEVICE_OBJECT *devObjPtr,
    IN SMEM_UNIT_CHUNKS_STC  *unitPtr
)
{
    START_BIND_UNIT_ACTIVE_MEM_MAC(devObjPtr,unitPtr)

        /* MIB - start */

        /* Statistic counters - active memory read */
        /* SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->sip6_MTI_cpu_port[1].cpu_MTI_STATS.counterCapture[ii] */
        /* ii = 0..55 : address 0x20-0xfc

          lets brake it down:
                            addr        mask
          0x20 - 0x3c :     0x20      (~0x1F)
          0x40 - 0x7c :     0x40      (~0x3F)
          0x80 - 0xfc :     0x80      (~0x7F)
        */
        {CPU_MAC_MIB_OFFSET + 0x00000020, 0xFFFFFFE0, smemFalconActiveReadMtiStatisticCounters, 0, NULL , 0},
        {CPU_MAC_MIB_OFFSET + 0x00000040, 0xFFFFFFC0, smemFalconActiveReadMtiStatisticCounters, 0, NULL , 0},
        {CPU_MAC_MIB_OFFSET + 0x00000080, 0xFFFFFF80, smemFalconActiveReadMtiStatisticCounters, 0, NULL , 0},
        /* Statistic counters - active memory write control */
        /* SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->sip6_MTI_cpu_port[1].cpu_MTI_STATS.control */
        {CPU_MAC_MIB_OFFSET + 0x0000000C, SMEM_FULL_MASK_CNS, NULL, 0, smemFalconActiveWriteMtiStatisticControl, 0},

        /* MIB - END */

        /* SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->sip6_MTI_cpu_port[1].MTI_EXT_PORT.portInterruptCause */
        {CPU_MAC_EXT_BASE_OFFSET + 0x0000000c, SMEM_FULL_MASK_CNS, smemChtActiveReadIntrCauseReg, 0, smemChtActiveWriteIntrCauseReg, 0},

        /* SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->sip6_MTI_cpu_port[1].MTI_EXT_PORT.portInterruptMask */
        {CPU_MAC_EXT_BASE_OFFSET + 0x00000010, SMEM_FULL_MASK_CNS, NULL, 0, smemFalconActiveWriteCpuPortInterruptsMaskReg, 0},

    END_BIND_UNIT_ACTIVE_MEM_MAC(devObjPtr,unitPtr)

    /* MIB - start */
    {
        SMEM_CHUNK_BASIC_STC  chunksMem[]=
        {
             {SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (CPU_MAC_MIB_OFFSET + 0x00000000, CPU_MAC_MIB_OFFSET + 0x00000014)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (CPU_MAC_MIB_OFFSET + 0x0000001C, CPU_MAC_MIB_OFFSET + 0x00000A9C)}
        };

        GT_U32  numOfChunks = sizeof(chunksMem)/sizeof(SMEM_CHUNK_BASIC_STC);
        smemInitMemChunk(devObjPtr,chunksMem, numOfChunks, unitPtr);
    }
    /* MIB - END */

    /* MAC CPU - start */
    {
        SMEM_CHUNK_EXTENDED_STC  chunksMem[]=
        {
            /* per MAC */
             {{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (CPU_MAC_PORT_OFFSET + 0x00000000, CPU_MAC_PORT_OFFSET + 0x00000014)}}
            ,{{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (CPU_MAC_PORT_OFFSET + 0x0000001C, CPU_MAC_PORT_OFFSET + 0x00000020)}}
            ,{{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (CPU_MAC_PORT_OFFSET + 0x00000030, CPU_MAC_PORT_OFFSET + 0x00000048)}}
            ,{{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (CPU_MAC_PORT_OFFSET + 0x00000054, CPU_MAC_PORT_OFFSET + 0x00000074)}}
            ,{{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (CPU_MAC_PORT_OFFSET + 0x0000007C, CPU_MAC_PORT_OFFSET + 0x000000A0)}}
        };
        GT_U32  numOfChunks = sizeof(chunksMem)/sizeof(SMEM_CHUNK_EXTENDED_STC);
        SMEM_UNIT_CHUNKS_STC    tmpUnitChunk;

        smemInitMemChunkExt(devObjPtr,chunksMem, numOfChunks, &tmpUnitChunk);
        /*add the tmp unit chunks to the main unit */
        smemInitMemCombineUnitChunks(devObjPtr,unitPtr,&tmpUnitChunk);
    }
    /* MAC CPU - end */

    /* MAC CPU EXT - start */
    {
        SMEM_CHUNK_BASIC_STC  chunksMem[]=
        {
            /* per MAC */
            {SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (CPU_MAC_EXT_BASE_OFFSET + 0x00000000, CPU_MAC_EXT_BASE_OFFSET + 0x00000060)}
        };
        GT_U32  numOfChunks = sizeof(chunksMem)/sizeof(SMEM_CHUNK_BASIC_STC);
        SMEM_UNIT_CHUNKS_STC    tmpUnitChunk;

        smemInitMemChunk(devObjPtr,chunksMem, numOfChunks, &tmpUnitChunk);
        /*add the tmp unit chunks to the main unit */
        smemInitMemCombineUnitChunks(devObjPtr,unitPtr,&tmpUnitChunk);
    }
    /* MAC CPU EXT - end */

   {
        static SMEM_REGISTER_DEFAULT_VALUE_STC myUnit_registersDefaultValueArr[] =
        {
            /* MAC CPU EXT - start */
             {DUMMY_NAME_PTR_CNS,            CPU_MAC_EXT_BASE_OFFSET+0x00000000,         0x083CFE00,      1,    0x0}
            /* MAC CPU EXT - end */

            /* MAC CPU - start */
            ,{DUMMY_NAME_PTR_CNS,            CPU_MAC_PORT_OFFSET+0x00000000,         0x00010200,      1,    0x0}
            ,{DUMMY_NAME_PTR_CNS,            CPU_MAC_PORT_OFFSET+0x00000008,         0x00000800,      1,    0x0}
            ,{DUMMY_NAME_PTR_CNS,            CPU_MAC_PORT_OFFSET+0x00000014,         0x00000600,      1,    0x0}
            ,{DUMMY_NAME_PTR_CNS,            CPU_MAC_PORT_OFFSET+0x0000001c,         0x00000008,      2,    0x4}
            ,{DUMMY_NAME_PTR_CNS,            CPU_MAC_PORT_OFFSET+0x00000030,         0x00001440,      1,    0x0}
            ,{DUMMY_NAME_PTR_CNS,            CPU_MAC_PORT_OFFSET+0x00000044,         0x0000000c,      1,    0x0}
            ,{DUMMY_NAME_PTR_CNS,            CPU_MAC_PORT_OFFSET+0x00000080,         0x00000100,      1,    0x0}
            /* MAC CPU - end */

            ,{NULL,            0,         0x00000000,      0,    0x0      }
        };
        static SMEM_LINK_LIST_REGISTER_DEFAULT_VALUE_STC list = {myUnit_registersDefaultValueArr,NULL};
        unitPtr->unitDefaultRegistersPtr = &list;
   }

}

/**
* @internal smemAasUnitPcsCpu function
* @endinternal
*
* @brief   Allocate address type specific memories -- for the PCS CPU unit wrapper
*/
static void smemAasUnitPcsCpu
(
    IN SKERNEL_DEVICE_OBJECT *devObjPtr,
    IN SMEM_UNIT_CHUNKS_STC  *unitPtr
)
{

    START_BIND_UNIT_ACTIVE_MEM_MAC(devObjPtr,unitPtr)

        /* PCS : CPU_PORT : MTIP IP CPU PCS WRAPPER {Current}/<MTIP CPU PCS>MTIP CPU PCS/<MTIP CPU PCS> PCS/PCS Units/PORT_CONTROL1 */
        {CPU_PCS_PORT_OFFSET + 0x00000000, SMEM_FULL_MASK_CNS, NULL, 0, smemFalconActiveWritePcsControl1 , 0},

    END_BIND_UNIT_ACTIVE_MEM_MAC(devObjPtr,unitPtr)


    {
        SMEM_CHUNK_BASIC_STC  chunksMem[]=
        {
            /* PCS-CPU - start */
             {SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (CPU_PCS_PORT_OFFSET+0x00000000, CPU_PCS_PORT_OFFSET+0x00000020)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (CPU_PCS_PORT_OFFSET+0x00000038, CPU_PCS_PORT_OFFSET+0x0000003c)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (CPU_PCS_PORT_OFFSET+0x00000080, CPU_PCS_PORT_OFFSET+0x000000b4)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (CPU_PCS_PORT_OFFSET+0x000000c8, CPU_PCS_PORT_OFFSET+0x000000c8)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (CPU_PCS_PORT_OFFSET+0x000000d0, CPU_PCS_PORT_OFFSET+0x000000d0)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (CPU_PCS_PORT_OFFSET+0x00000800, CPU_PCS_PORT_OFFSET+0x0000080c)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (CPU_PCS_PORT_OFFSET+0x00000820, CPU_PCS_PORT_OFFSET+0x0000082c)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (CPU_PCS_PORT_OFFSET+0x00000830, CPU_PCS_PORT_OFFSET+0x0000083c)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (CPU_PCS_PORT_OFFSET+0x00000840, CPU_PCS_PORT_OFFSET+0x00000848)}
            /* PCS-CPU - end */

            /* rsfec-CPU - start */
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (CPU_PCS_RS_FEC_OFFSET+0x00000000, CPU_PCS_RS_FEC_OFFSET+0x00000014)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (CPU_PCS_RS_FEC_OFFSET+0x00000028, CPU_PCS_RS_FEC_OFFSET+0x0000004c)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (CPU_PCS_RS_FEC_OFFSET+0x00000200, CPU_PCS_RS_FEC_OFFSET+0x0000020C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (CPU_PCS_RS_FEC_OFFSET+0x00000300, CPU_PCS_RS_FEC_OFFSET+0x00000314)}
            /* rsfec-CPU - end */

            /* lpcs-CPU - start */
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (CPU_PCS_LPCS_OFFSET+0x00000000, CPU_PCS_LPCS_OFFSET+0x00000020)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (CPU_PCS_LPCS_OFFSET+0x00000040, CPU_PCS_LPCS_OFFSET+0x0000005C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (CPU_PCS_LPCS_OFFSET+0x00000080, CPU_PCS_LPCS_OFFSET+0x000000A0)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (CPU_PCS_LPCS_OFFSET+0x000000C0, CPU_PCS_LPCS_OFFSET+0x000000DC)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (CPU_PCS_LPCS_OFFSET+0x00000100, CPU_PCS_LPCS_OFFSET+0x00000120)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (CPU_PCS_LPCS_OFFSET+0x00000140, CPU_PCS_LPCS_OFFSET+0x0000015C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (CPU_PCS_LPCS_OFFSET+0x00000180, CPU_PCS_LPCS_OFFSET+0x000001A0)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (CPU_PCS_LPCS_OFFSET+0x000001C0, CPU_PCS_LPCS_OFFSET+0x000001DC)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (CPU_PCS_LPCS_OFFSET+0x00000200, CPU_PCS_LPCS_OFFSET+0x00000220)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (CPU_PCS_LPCS_OFFSET+0x00000240, CPU_PCS_LPCS_OFFSET+0x0000025C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (CPU_PCS_LPCS_OFFSET+0x00000280, CPU_PCS_LPCS_OFFSET+0x000002A0)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (CPU_PCS_LPCS_OFFSET+0x000002C0, CPU_PCS_LPCS_OFFSET+0x000002DC)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (CPU_PCS_LPCS_OFFSET+0x00000300, CPU_PCS_LPCS_OFFSET+0x00000320)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (CPU_PCS_LPCS_OFFSET+0x00000340, CPU_PCS_LPCS_OFFSET+0x0000035C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (CPU_PCS_LPCS_OFFSET+0x00000380, CPU_PCS_LPCS_OFFSET+0x000003A0)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (CPU_PCS_LPCS_OFFSET+0x000003C0, CPU_PCS_LPCS_OFFSET+0x000003F4)}
            /* lpcs-CPU - end */
        };
        GT_U32  numOfChunks = sizeof(chunksMem)/sizeof(SMEM_CHUNK_BASIC_STC);

        smemInitMemChunk(devObjPtr,chunksMem, numOfChunks, unitPtr);
    }

   {
        static SMEM_REGISTER_DEFAULT_VALUE_STC myUnit_registersDefaultValueArr[] =
        {
            /* PCS-CPU - start */
             {DUMMY_NAME_PTR_CNS,            CPU_PCS_PORT_OFFSET+0x00000000,         0x00002040,      1,    0x0     }
            ,{DUMMY_NAME_PTR_CNS,            CPU_PCS_PORT_OFFSET+0x00000010,         0x00000011,      1,    0x0     }
            ,{DUMMY_NAME_PTR_CNS,            CPU_PCS_PORT_OFFSET+0x00000014,         0x00000008,      1,    0x0     }
            ,{DUMMY_NAME_PTR_CNS,            CPU_PCS_PORT_OFFSET+0x00000020,         0x00008081,      1,    0x0     }
            ,{DUMMY_NAME_PTR_CNS,            CPU_PCS_PORT_OFFSET+0x00000088,         0x0000804f,      1,    0x0     }
            ,{DUMMY_NAME_PTR_CNS,            CPU_PCS_PORT_OFFSET+0x0000008c,         0x0000cab6,      1,    0x0     }
            ,{DUMMY_NAME_PTR_CNS,            CPU_PCS_PORT_OFFSET+0x00000090,         0x0000b44d,      1,    0x0     }
            ,{DUMMY_NAME_PTR_CNS,            CPU_PCS_PORT_OFFSET+0x00000094,         0x000003c8,      1,    0x0     }
            ,{DUMMY_NAME_PTR_CNS,            CPU_PCS_PORT_OFFSET+0x00000098,         0x00008884,      1,    0x0     }
            ,{DUMMY_NAME_PTR_CNS,            CPU_PCS_PORT_OFFSET+0x0000009c,         0x000085a3,      1,    0x0     }
            ,{DUMMY_NAME_PTR_CNS,            CPU_PCS_PORT_OFFSET+0x000000a0,         0x000006bb,      1,    0x0     }
            ,{DUMMY_NAME_PTR_CNS,            CPU_PCS_PORT_OFFSET+0x000000a4,         0x00000349,      1,    0x0     }
            ,{DUMMY_NAME_PTR_CNS,            CPU_PCS_PORT_OFFSET+0x000000b4,         0x00008000,      1,    0x0     }
            ,{DUMMY_NAME_PTR_CNS,            CPU_PCS_PORT_OFFSET+0x00000808,         0x00004fff,      1,    0x0     }
            ,{DUMMY_NAME_PTR_CNS,            CPU_PCS_PORT_OFFSET+0x0000080c,         0x00000007,      1,    0x0     }
            ,{DUMMY_NAME_PTR_CNS,            CPU_PCS_PORT_OFFSET+0x00000820,         0x000068c1,      1,    0x0     }
            ,{DUMMY_NAME_PTR_CNS,            CPU_PCS_PORT_OFFSET+0x00000824,         0x00000021,      1,    0x0     }
            ,{DUMMY_NAME_PTR_CNS,            CPU_PCS_PORT_OFFSET+0x00000828,         0x0000c4f0,      1,    0x0     }
            ,{DUMMY_NAME_PTR_CNS,            CPU_PCS_PORT_OFFSET+0x0000082c,         0x000000e6,      1,    0x0     }
            ,{DUMMY_NAME_PTR_CNS,            CPU_PCS_PORT_OFFSET+0x00000830,         0x000065c5,      1,    0x0     }
            ,{DUMMY_NAME_PTR_CNS,            CPU_PCS_PORT_OFFSET+0x00000834,         0x0000009b,      1,    0x0     }
            ,{DUMMY_NAME_PTR_CNS,            CPU_PCS_PORT_OFFSET+0x00000838,         0x000079a2,      1,    0x0     }
            ,{DUMMY_NAME_PTR_CNS,            CPU_PCS_PORT_OFFSET+0x0000083c,         0x0000003d,      1,    0x0     }
            ,{DUMMY_NAME_PTR_CNS,            CPU_PCS_PORT_OFFSET+0x00000840,         0x00000303,      1,    0x0     }
            /* PCS-CPU - end */

            /* rsfec-CPU - start */
            ,{DUMMY_NAME_PTR_CNS,            CPU_PCS_RS_FEC_OFFSET+0x0000020c,       0x00000022,      1,    0x0     }
            /* rsfec-CPU - end */

            /* lpcs-CPU - start */
            ,{DUMMY_NAME_PTR_CNS,            CPU_PCS_LPCS_OFFSET+0x00000004,         0x00000009,      8,    0x80    }
            ,{DUMMY_NAME_PTR_CNS,            CPU_PCS_LPCS_OFFSET+0x00000008,         0x00004950,      8,    0x80    }
            ,{DUMMY_NAME_PTR_CNS,            CPU_PCS_LPCS_OFFSET+0x0000000c,         0x00004d54,      8,    0x80    }
            ,{DUMMY_NAME_PTR_CNS,            CPU_PCS_LPCS_OFFSET+0x00000010,         0x000001a0,      8,    0x80    }
            ,{DUMMY_NAME_PTR_CNS,            CPU_PCS_LPCS_OFFSET+0x00000018,         0x00000004,      8,    0x80    }
            ,{DUMMY_NAME_PTR_CNS,            CPU_PCS_LPCS_OFFSET+0x00000044,         0x00000001,      8,    0x80    }
            ,{DUMMY_NAME_PTR_CNS,            CPU_PCS_LPCS_OFFSET+0x00000048,         0x000012d0,      8,    0x80    }
            ,{DUMMY_NAME_PTR_CNS,            CPU_PCS_LPCS_OFFSET+0x0000004c,         0x00000013,      8,    0x80    }
            ,{DUMMY_NAME_PTR_CNS,            CPU_PCS_LPCS_OFFSET+0x0000005c,         0x0000000c,      8,    0x80    }
            /* lpcs-CPU - end */

            ,{NULL,            0,         0x00000000,      0,    0x0      }
        };
        static SMEM_LINK_LIST_REGISTER_DEFAULT_VALUE_STC list = {myUnit_registersDefaultValueArr,NULL};
        unitPtr->unitDefaultRegistersPtr = &list;
   }
}

/**
* @internal smemAasUnitLed function
* @endinternal
*
* @brief   Allocate address type specific memories -- for the LED
*/
static void smemAasUnitLed
(
    IN SKERNEL_DEVICE_OBJECT *devObjPtr,
    IN SMEM_UNIT_CHUNKS_STC  *unitPtr
)
{
    SMEM_CHUNK_BASIC_STC  chunksMem[]=
    {
         {SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000000, 0x000000A8)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000120, 0x00000160)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000200, 0x00000348)}
    };

    GT_U32  numOfChunks = sizeof(chunksMem)/sizeof(SMEM_CHUNK_BASIC_STC);
    smemInitMemChunk(devObjPtr,chunksMem, numOfChunks, unitPtr);
}


/**
* @internal smemAasSpecificDeviceUnitAlloc_DP_units function
* @endinternal
*
* @brief   specific initialization units allocation that called before alloc units
*         of any device.
*         DP units -- (non sip units)
* @param[in] devObjPtr                - pointer to device object.
*                                       Pointer to object for specific subunit
*/
void smemAasSpecificDeviceUnitAlloc_DP_units
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr
)
{
    SMEM_DEVICE_UNIT_ALLOCATION_STC allocUnitsArr[] = {
    {
        STR(UNIT_RX_DMA)                       ,smemAasUnitRxDma            }
        ,{STR(UNIT_TX_DMA)                     ,smemAasUnitTxDma            }
        ,{STR(UNIT_TX_FIFO)                    ,smemAasUnitTxFifo           }
        ,{STR(UNIT_PB_COUNTER_BLK)             ,smemAasUnitPacketBuffer_pbCounter       }
        ,{STR(UNIT_PB_SMB_WRITE_ARBITER_0)     ,smemAasUnitPacketBuffer_smbWriteArbiter }
        ,{STR(UNIT_PB_GPC_GRP_PACKET_WRITE_0)  ,smemAasUnitPacketBuffer_packetWrite     }
        ,{STR(UNIT_PB_GPC_GRP_PACKET_READ_0)   ,smemAasUnitPacketBuffer_packetRead      }
        ,{STR(UNIT_PB_GPC_GRP_CELL_READ_0)     ,smemAasUnitPacketBuffer_cellRead        }
        ,{STR(UNIT_PB_NEXT_POINTER_MEMO_0)     ,smemAasUnitPacketBuffer_npmMc           }
        ,{STR(UNIT_PB_SHARED_MEMO_BUF_0_0)     ,smemAasUnitPacketBuffer_sbmMc           }
        ,{STR(UNIT_PCA_PZ_ARBITER_0)           ,smemAasUnitPcaArbiter        }
        ,{STR(UNIT_PCA_SFF_0)                  ,smemAasUnitPcaSff            }
        ,{STR(UNIT_PCA_MACSEC_EXT_I_163_0)     ,smemAasUnitPcaMacsecExt      }
        ,{STR(UNIT_PCA_BRG_SHM_RX_0)           ,smemAasUnitPcaBrgShmIngr     }
        ,{STR(UNIT_PCA_BRG_SHM_TX_0)           ,smemAasUnitPcaBrgShmEgr      }
        ,{STR(UNIT_PCA_BRG_UNPACK_TX_0)        ,smemAasUnitPcaBrgUnpackTx    }
        ,{STR(UNIT_PCA_BRG_PACK_RX_0)          ,smemAasUnitPcaBrgPackRx      }
        ,{STR(UNIT_PCA_BRG_EDGE_RX_0)          ,smemAasUnitDummy_64KB        }
        ,{STR(UNIT_PCA_BRG_EDGE_TX_0)          ,smemAasUnitDummy_64KB        }
        ,{STR(UNIT_MIF_0)                      ,smemAasUnitMif               }
        ,{STR(UNIT_ANP_0)                      ,smemAasUnitAnp               }
                                                     /* use dummy as MAC_400G_OFFSET changed */
        ,{STR(UNIT_MAC_400G_0)                 ,smemAasUnitMac400GWrap /*smemAasUnitMac400GWrap*/      }
        ,{STR(UNIT_PCS_400G_0)                 ,smemAasUnitPcs400G          }

        ,{STR(UNIT_MAC_CPU)                    ,smemAasUnitMacCpuWrap       }
        ,{STR(UNIT_PCS_CPU)                    ,smemAasUnitPcsCpu           }

        ,{STR(UNIT_SERDES_0_0)                 ,smemAasUnitDummy_512KB            }

        ,{STR(UNIT_LED_0)                      ,smemAasUnitLed              }

        /* must be last */
        ,{NULL,NULL}
    };

    smemGenericUnitAlloc(devObjPtr, allocUnitsArr);
    smemPhoenixSpecificDeviceUnitAllocDerived_DP_units(devObjPtr, allocUnitsArr);
}


/**
* @internal smemAasUnitFlexeShim function
* @endinternal
*
* @brief   Allocate address type specific memories -- for FlexE Shim
*/
static void smemAasUnitFlexeShim
(
    IN SKERNEL_DEVICE_OBJECT *devObjPtr,
    IN SMEM_UNIT_CHUNKS_STC  *unitPtr
)
{
    SMEM_CHUNK_EXTENDED_STC  chunksMem[]=
    {
         {{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000000, 0x0000002C)}}
         /* Instance <0-7> */
        ,{{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001000, 0x00001040)}, FORMULA_SINGLE_PARAMETER(8,0x3000)}
        ,{{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001100, 0x00001160)}, FORMULA_SINGLE_PARAMETER(8,0x3000)}
        ,{{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001200, 0x000013E4)}, FORMULA_SINGLE_PARAMETER(8,0x3000)}
        ,{{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001600, 0x000017E4)}, FORMULA_SINGLE_PARAMETER(8,0x3000)}
        ,{{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00002000, 0x000021E4)}, FORMULA_SINGLE_PARAMETER(8,0x3000)}
        ,{{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00002400, 0x000025E4)}, FORMULA_SINGLE_PARAMETER(8,0x3000)}
        ,{{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00003800, 0x00003FFC)}, FORMULA_SINGLE_PARAMETER(8,0x3000)}
        ,{{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00004800, 0x00004FFC)}, FORMULA_SINGLE_PARAMETER(8,0x3000)}

        ,{{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000028000, 0x000283C0)}}
        ,{{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000028600, 0x000289C0)}}
        ,{{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000029000, 0x000293C0)}}
        ,{{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000029600, 0x000299C0)}}
        ,{{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000030000, 0x00030098)}}

        /*OH*/
        ,{{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000031000, 0x00031024)}}
        ,{{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000032000, 0x0003203C)}}
        ,{{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000032200, 0x00032DFC)}}
    };

    GT_U32  numOfChunks = sizeof(chunksMem)/sizeof(SMEM_CHUNK_EXTENDED_STC);
    SMEM_UNIT_CHUNKS_STC    tmpUnitChunk;

    smemInitMemChunkExt(devObjPtr,chunksMem, numOfChunks, &tmpUnitChunk);
    /*add the tmp unit chunks to the main unit */
    smemInitMemCombineUnitChunks(devObjPtr,unitPtr,&tmpUnitChunk);
}

/**
* @internal smemAasUnitFlexeXc function
* @endinternal
*
* @brief   Allocate address type specific memories -- for FlexE Cross Connect
*/
static void smemAasUnitFlexeXc
(
    IN SKERNEL_DEVICE_OBJECT *devObjPtr,
    IN SMEM_UNIT_CHUNKS_STC  *unitPtr
)
{
    SMEM_CHUNK_BASIC_STC  chunksMem[]=
    {
        {SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000000, 0x0000014C)}
       ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001000, 0x000016E4)}
       ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00002000, 0x000022E4)}
       ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00003000, 0x0000319C)}
       ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00008000, 0x00008020)}
       ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00008100, 0x000085FC)}
       ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00009000, 0x00025FCC)}
       ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00028000, 0x00028014)}
       ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00028100, 0x000285FC)}
       ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00029000, 0x00045FCC)}
       ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00048000, 0x00048D3C)}
    };

    GT_U32  numOfChunks = sizeof(chunksMem)/sizeof(SMEM_CHUNK_BASIC_STC);
    smemInitMemChunk(devObjPtr,chunksMem, numOfChunks, unitPtr);
}

/**
* @internal smemAasUnitFlexeCoders function
* @endinternal
*
* @brief   Allocate address type specific memories -- for FlexE Coders
*/
static void smemAasUnitFlexeCoders
(
    IN SKERNEL_DEVICE_OBJECT *devObjPtr,
    IN SMEM_UNIT_CHUNKS_STC  *unitPtr
)
{
    SMEM_CHUNK_BASIC_STC  chunksMem[]=
    {
         {SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000000, 0x000000A8)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000120, 0x00000160)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000200, 0x00000348)}
    };

    GT_U32  numOfChunks = sizeof(chunksMem)/sizeof(SMEM_CHUNK_BASIC_STC);
    smemInitMemChunk(devObjPtr,chunksMem, numOfChunks, unitPtr);
}

/**
* @internal smemAasSpecificDeviceUnitAlloc_Flexe_units function
* @endinternal
*
* @brief   specific initialization units allocation that called before alloc units
*         of any device.
*         SIP units
* @param[in] devObjPtr                - pointer to device object.
*                                       Pointer to object for specific subunit
*/
static void smemAasSpecificDeviceUnitAlloc_Flexe_units
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr
)
{
    SMEM_DEVICE_UNIT_ALLOCATION_STC allocUnitsArr []=
    {
        {STR(UNIT_FLEXE_XC0)       ,smemAasUnitFlexeXc}
       ,{STR(UNIT_FLEXE_XC0_TAI)   ,smemAasUnitDummy_64KB}
       ,{STR(UNIT_FLEXE_XC1)       ,smemAasUnitFlexeXc}
       ,{STR(UNIT_FLEXE_XC1_TAI)   ,smemAasUnitDummy_64KB}
       ,{STR(UNIT_FLEXE_CODERS)    ,smemAasUnitFlexeCoders}
       ,{STR(UNIT_FLEXE_SHIM0)     ,smemAasUnitFlexeShim}
       ,{STR(UNIT_FLEXE_SHIM0_TAI) ,smemAasUnitDummy_64KB}
       ,{STR(UNIT_FLEXE_SHIM1)     ,smemAasUnitFlexeShim}
       ,{STR(UNIT_FLEXE_SHIM1_TAI) ,smemAasUnitDummy_64KB}

        /* must be last */
        ,{NULL,NULL}
    };

    smemGenericUnitAlloc(devObjPtr,allocUnitsArr);
}


/**
* @internal aasGetGdmaIdFromAddr function
* @endinternal
*
* @brief   convert address from GDMA unit to GDMA unit Id.
*
* @param[in] devObjPtr                - device object PTR.
* @param[in] address                  - Address with in some GDMA unit
*
* @return the GDMA unit Id
*/
GT_U32  aasGetGdmaIdFromAddr
(
    IN         SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN         GT_U32   address
)
{
    GT_U32 ii;
    GT_U32 unitBase = address & ~(GDMA_UNIT_SIZE - 1);

    for(ii = 0 ; ii < devObjPtr->numOfGdmaUnits; ii++)
    {
        if(devObjPtr->memUnitBaseAddrInfo.sip_7_GDMA[ii] == unitBase)
        {
            return ii;
        }
    }

    skernelFatalError("aasGetGdmaIdFromAddr : cant convert address [0x%8.8x] to GDMA unit Id \n",
        address);
    return 0;
}

/**
* @internal smemAasGdmaCheckNeedToTriggerQueue function
* @endinternal
*
* @brief check if the active memory should triiger actions on the queue
*
* @param[in] devObjPtr                - device object PTR.
* @param[in] address                  - Address for ASIC memory.
* @param[in] memPtr                   - Pointer to the register's memory in the simulation.
* @param[in] param                    - Registers' specific parameter.
* @param[in] inMemPtr                 - Pointer to the memory to get register's content.
*/
void smemAasGdmaCheckNeedToTriggerQueue
(
    IN         SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN GT_U32                  gdma_id,
    IN GT_U32                  ringId
)
{
    DECLARE_FUNC_NAME(smemAasGdmaCheckNeedToTriggerQueue);

    GT_U32  regAddress;
    GT_U32  q_type,ringEnable,fldValue;

    regAddress = SMEM_SIP7_GDMA_QUEUE_EN_REG(devObjPtr,gdma_id,ringId);
    smemRegFldGet(devObjPtr,regAddress, 0,1,&ringEnable);
    if(ringEnable == 0)
    {
        /* the queue is disabled so no need to trigger the queue */
        __LOG(("the queue is disabled so no need to trigger the queue \n"));
        return;
    }

    regAddress = SMEM_SIP7_GDMA_QUEUE_CONTROL_REG(devObjPtr,gdma_id, ringId);
    smemRegGet(devObjPtr,regAddress, &fldValue);
    q_type = SMEM_U32_GET_FIELD(fldValue, 0, 4);

    if(FROM_CPU_RING_TYPE == q_type)
    {
        /* the FROM_CPU queue need triggering */
        __LOG(("the FROM_CPU queue need triggering \n"));
        /* NOTE : the function will send 'message' to snetAasGdmaFromCpuProcess(...)
           to process the queue */
        snetAasGdmaFromCpuTrigger(devObjPtr,gdma_id,ringId);
    }
    else
    if(FROM_CPU_PKT_GEN_RING_TYPE == q_type)
    {
        __LOG(("PktGen(%u:%d) task triggering on enable\n", gdma_id, ringId));
        snetAasGdmaFromCpuTriggerPktGen(devObjPtr, gdma_id, ringId);
    }
    else
    {
        __LOG(("Queue [%u:%d] q_type=%d ignored\n", gdma_id, ringId, q_type));
    }
}

/**
* @internal smemAasActiveWriteCnmGdmaAddGdmaSgdOwn function
* @endinternal
*
* @brief   write to indirect mechanism to update the number of SGDs in the ring
*       active memory on : SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->CNM.GDMA[0].sgdAxiControlRegs[q].addGDMASGDOwn : 0x810 + 0x20*n : n=0..31
*       to update the : CNM.GDMA[0].queueStatusAndControlRegs[q].freeSGDsStatusRegister
*       SMEM_SIP7_GDMA_FREE_SGDS_STATUS_REG()
*           with the number of added descriptors to the ring
*
* @param[in] devObjPtr                - device object PTR.
* @param[in] address                  - Address for ASIC memory.
* @param[in] memPtr                   - Pointer to the register's memory in the simulation.
* @param[in] param                    - Registers' specific parameter.
* @param[in] inMemPtr                 - Pointer to the memory to get register's content.
*/
void smemAasActiveWriteCnmGdmaAddGdmaSgdOwn (
    IN         SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN         GT_U32   address,
    IN         GT_U32   memSize,
    IN         GT_U32 * memPtr,
    IN         GT_UINTPTR   param,
    IN         GT_U32 * inMemPtr
)
{
    DECLARE_FUNC_NAME(smemAasActiveWriteCnmGdmaAddGdmaSgdOwn);

    GT_U32  counterOffset;
    GT_U32  counterAddr;
    GT_U32  counterValue;
    GT_U32  add_gdma_sgd_own;
    GT_U32  gdma_id,ringId;
    GT_U32  queueStep;
    GT_U32  free_sgd_num,old_free_sgd_num;

    gdma_id = aasGetGdmaIdFromAddr(devObjPtr,address);

    /* Update the register value */
    *memPtr = *inMemPtr;
    add_gdma_sgd_own = (*memPtr) & 0xFF;
    if(add_gdma_sgd_own == 0)
    {
        add_gdma_sgd_own = 256;
    }

    queueStep = SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->CNM.GDMA[0].sgdAxiControlRegs[1].addGDMASGDOwn -
                SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->CNM.GDMA[0].sgdAxiControlRegs[0].addGDMASGDOwn;

    ringId = ((GDMA_UNIT_SIZE-1) & (address - SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->CNM.GDMA[0].sgdAxiControlRegs[0].addGDMASGDOwn))
            / queueStep ;

    counterOffset =
        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->CNM.GDMA[0].queueStatusAndControlRegs[ringId].freeSGDsStatusRegister -
        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->CNM.GDMA[0].sgdAxiControlRegs[ringId].addGDMASGDOwn;

    counterAddr = counterOffset + address;

    /* increment the value of the counter */
    smemRegFldGet(devObjPtr, counterAddr, 0,16, &counterValue);
    old_free_sgd_num = counterValue;

    counterValue += add_gdma_sgd_own;
    smemRegFldSet(devObjPtr, counterAddr, 0,16, counterValue);

    __LOG_PARAM(add_gdma_sgd_own);
    free_sgd_num = counterValue;
    __LOG_PARAM(free_sgd_num);

    if(counterValue > 0xFFFF)
    {
        __LOG(("smemAasActiveWriteCnmGdmaAddGdmaSgdOwn : CONFIG ERROR : wraparound of value [0x%5.5x] , cut down to : [0x%4.4x] (16 bits) \n",
            counterValue,
            (counterValue & 0xFFFF)));
    }

    if(old_free_sgd_num == 0)
    {
        /* value was 0 , and added more SDGs , so check if need to be trigger
           the queue */
        __LOG(("gdma_id[%d] ringId[%d] free_sgd_num was Zero , but added with [%d] SGDs , check if need to trigger the queue \n",
            gdma_id,ringId,counterValue));
        smemAasGdmaCheckNeedToTriggerQueue(devObjPtr,gdma_id,ringId);
    }
}


/**
* @internal smemAasActiveWriteCnmGdmaQueueEnable function
* @endinternal
*
* @brief write to 'queue enable' register.
*        CNM.GDMA[0].queueStatusAndControlRegs[q].queueEnable
*
* @param[in] devObjPtr                - device object PTR.
* @param[in] address                  - Address for ASIC memory.
* @param[in] memPtr                   - Pointer to the register's memory in the simulation.
* @param[in] param                    - Registers' specific parameter.
* @param[in] inMemPtr                 - Pointer to the memory to get register's content.
*/
void smemAasActiveWriteCnmGdmaQueueEnable (
    IN         SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN         GT_U32   address,
    IN         GT_U32   memSize,
    IN         GT_U32 * memPtr,
    IN         GT_UINTPTR   param,
    IN         GT_U32 * inMemPtr
)
{
    DECLARE_FUNC_NAME(smemAasActiveWriteCnmGdmaQueueEnable);
    GT_U32  gdma_id,ringId;
    GT_U32  queueStep;
    GT_U32  old_queueEnable;
    GT_U32  new_queueEnable;
    GT_U32  old_idle;
    #define IDLE_BIT_MASK    0x2

    gdma_id = aasGetGdmaIdFromAddr(devObjPtr,address);

    old_idle        = (*memPtr)   & IDLE_BIT_MASK;
    old_queueEnable = (*memPtr)   & 0x1;
    new_queueEnable = (*inMemPtr) & 0x1;

    if(old_idle)
    {
        /* <ring idle> : keep bit 1 set */
        /* Update the register value */
        *memPtr = *inMemPtr | IDLE_BIT_MASK;
    }
    else
    {
        /* <ring idle> : keep bit 1 cleared */
        *memPtr = *inMemPtr & ~(IDLE_BIT_MASK);
    }

    queueStep = SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->CNM.GDMA[0].queueStatusAndControlRegs[1].queueEnable -
                SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->CNM.GDMA[0].queueStatusAndControlRegs[0].queueEnable;

    ringId = ((GDMA_UNIT_SIZE-1) & (address - SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->CNM.GDMA[0].queueStatusAndControlRegs[0].queueEnable))
            / queueStep ;

    if(old_queueEnable == 0 && new_queueEnable == 1)
    {
        __LOG(("gdma_id[%d] ringId[%d] is enabled (was disabled) , check if need to trigger the queue \n",
            gdma_id,ringId));
        /* the queue was enabled , check if need to trigger it */
        smemAasGdmaCheckNeedToTriggerQueue(devObjPtr,gdma_id,ringId);
    }
    else
    if(old_queueEnable == 1 && new_queueEnable == 0)
    {
        __LOG(("gdma_id[%d] ringId[%d] is SET TO BE disabled (was enabled) \n",
            gdma_id,ringId));
    }
}
/*******************************************************************************
*  SMEM_EXT_ACTIVE_MEM_ADDRESS_FIND_FUN
*
* DESCRIPTION:
*      Function finds memory active address in register DB.
*
* INPUTS:
*       deviceObjPtr    - device object PTR.
*       address         - address to find in register's DB
*       param           - specific parameter
*
* OUTPUTS:
*       None
*
* RETURNS:
*       GT_TRUE     - the address found in register DB
*       GT_FALSE    - the address not found in register DB
*
* COMMENTS:
*
*******************************************************************************/
static GT_BOOL smemAasUnitCnmGdma_ActiveMem_ForSteps_0x30
(
    IN        SKERNEL_DEVICE_OBJECT * deviceObjPtr,
    IN        GT_U32 address,
    IN        GT_UINTPTR param
)
{
    SMEM_ACTIVE_MEM_ENTRY_STC  * activeMemoryPtr = (SMEM_ACTIVE_MEM_ENTRY_STC *)param;
    GT_U32  activeAddress   = activeMemoryPtr->address & (GDMA_UNIT_SIZE-1);
    GT_U32  relativeAddress = address                  & (GDMA_UNIT_SIZE-1);
    GT_U32  diffAddr;
    GT_U32  steps;

    if(relativeAddress < activeAddress)
    {
        /* the address is below the address to match */
        return GT_FALSE;
    }

    diffAddr = relativeAddress - activeAddress;

    steps = diffAddr / 0x30;

    if(steps >= 32)
    {
        /* the address is above the address to match with 32 steps 0f 0x30 */
        return GT_FALSE;
    }

    if(diffAddr == (steps * 0x30))
    {
        /* the address is in the range , and match the step */
        return GT_TRUE;
    }

    /* the address is in the range , but not relevant to this active memory */
    return GT_FALSE;
}

/**
* @internal smemAasUnitCnmGdma function
* @endinternal
*
* @brief   Allocate address type specific memories -- for the Cnm GDMA
*/
static void smemAasUnitCnmGdma
(
    IN SKERNEL_DEVICE_OBJECT *devObjPtr,
    IN SMEM_UNIT_CHUNKS_STC  *unitPtr
)
{

#define GDMA_MASK_FOR_32_RINGS_0x20_STEP \
    (SMEM_FULL_MASK_CNS & ~(0x1F/*mask for 32 registers*/ << 5/*0x20 step*/))
#define GDMA_MASK_FOR_32_RINGS_0x4_STEP \
    (SMEM_FULL_MASK_CNS & ~(0x1F/*mask for 32 registers*/ << 2/*0x4 step*/))

    START_BIND_UNIT_ACTIVE_MEM_MAC(devObjPtr,unitPtr)

    /* SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->CNM.GDMA[0].sgdAxiControlRegs[q].addGDMASGDOwn : 0x00000810 + 0x20*q : q=0..31*/
    {0x00000810 , GDMA_MASK_FOR_32_RINGS_0x20_STEP, NULL, 0, smemAasActiveWriteCnmGdmaAddGdmaSgdOwn, 0},

    {0x00004300, GDMA_MASK_FOR_32_RINGS_0x4_STEP, smemChtActiveReadIntrCauseReg, 0, smemChtActiveWriteIntrCauseReg, 0},
    {0x00004380, GDMA_MASK_FOR_32_RINGS_0x4_STEP, NULL, 0, smemChtActiveGenericWriteInterruptsMaskReg, 0},

    /* active memory for 32 registers in steps of 0x30 */
    /*SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->CNM.GDMA[0].queueStatusAndControlRegs[q].queueEnable           = 0x00001000 + q*0x30;*/
    {0x00001000 , SMEM_FULL_MASK_CNS              , NULL, 0, smemAasActiveWriteCnmGdmaQueueEnable, 0 , smemAasUnitCnmGdma_ActiveMem_ForSteps_0x30},
    /*SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->CNM.GDMA[0].queueStatusAndControlRegs[q].freeSGDsStatusRegister= 0x00001014 + q*0x30;*/
    {0x00001014 , SMEM_FULL_MASK_CNS              , NULL, 0, smemChtActiveWriteToReadOnlyReg, 0 , smemAasUnitCnmGdma_ActiveMem_ForSteps_0x30},

     /* 64 bit counter (take 2 registers) */
     /*SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->CNM.GDMA[0].queueStatusAndControlRegs[q].stat_counter[0]    = 0x00001020 + q*0x30;*/
     /*SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->CNM.GDMA[0].queueStatusAndControlRegs[q].stat_counter[1]    = 0x00001024 + q*0x30;*/
     {0x00001020 , SMEM_FULL_MASK_CNS  , smemChtActiveReadCntrs64Bit, 1, NULL,0, smemAasUnitCnmGdma_ActiveMem_ForSteps_0x30},
     {0x00001024 , SMEM_FULL_MASK_CNS  , smemChtActiveReadCntrs64Bit, 1, NULL,0, smemAasUnitCnmGdma_ActiveMem_ForSteps_0x30},

     /*SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->CNM.GDMA[0].queueStatusAndControlRegs[q].stat_byte_counter[0]    = 0x00001028 + q*0x30;*/
     /*SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->CNM.GDMA[0].queueStatusAndControlRegs[q].stat_byte_counter[1]    = 0x0000102c + q*0x30;*/
     {0x00001028 , SMEM_FULL_MASK_CNS  , smemChtActiveReadCntrs64Bit, 1, NULL,0, smemAasUnitCnmGdma_ActiveMem_ForSteps_0x30},
     {0x0000102c , SMEM_FULL_MASK_CNS  , smemChtActiveReadCntrs64Bit, 1, NULL,0, smemAasUnitCnmGdma_ActiveMem_ForSteps_0x30},

     /*SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->CNM.GDMA[0].queueStatusAndControlRegs[q].RX_Drop_counter[0]    = 0x00001018 + q*0x30;*/
     /*SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->CNM.GDMA[0].queueStatusAndControlRegs[q].RX_Drop_counter[1]    = 0x0000101c + q*0x30;*/
     {0x00001018 , SMEM_FULL_MASK_CNS  , smemChtActiveReadCntrs64Bit, 1, NULL,0, smemAasUnitCnmGdma_ActiveMem_ForSteps_0x30},
     {0x0000101c , SMEM_FULL_MASK_CNS  , smemChtActiveReadCntrs64Bit, 1, NULL,0, smemAasUnitCnmGdma_ActiveMem_ForSteps_0x30},

    END_BIND_UNIT_ACTIVE_MEM_MAC(devObjPtr,unitPtr)


    {
        SMEM_CHUNK_BASIC_STC  chunksMem[]=
        {
             {SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000000, 0x00000008)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000010, 0x0000001C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000200, 0x00000210)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00000400, 128)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00002800, 0x00002800)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00004000, 0x00004030)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00004040, 0x00004048)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00004300, 0x000043FC)}

        };

        GT_U32  numOfChunks = sizeof(chunksMem)/sizeof(SMEM_CHUNK_BASIC_STC);
        smemInitMemChunk(devObjPtr,chunksMem, numOfChunks, unitPtr);
    }

    {
        SMEM_CHUNK_EXTENDED_STC  chunksMem[]=
        {
            /* SGD and AXI control : 8 registers * 32 occurrences  */
             {{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000800, 0x0000081c)} , FORMULA_SINGLE_PARAMETER(32 , 0x20)}
            /* GDMA TIMER : 2 registers * 31 occurrences  */
            ,{{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000C00, 0x00000C04)} , FORMULA_SINGLE_PARAMETER(32 , 0x10)}
            /* Ring Status and Control : 2 registers * 32 occurrences  */
            ,{{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001000, 0x00001004)} , FORMULA_SINGLE_PARAMETER(32 , 0x30)}
            /* Ring Status and Control : 9 registers * 32 occurrences  */
            ,{{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x0000100c, 0x0000102c)} , FORMULA_SINGLE_PARAMETER(32 , 0x30)}
            /* Multicast Profile : 2 registers * 16 occurrences  */
            ,{{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001800, 0x00001804)} , FORMULA_SINGLE_PARAMETER(16 , 0x8)}
            /* PDI Slave : 2 registers * 8 occurrences  */
            ,{{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00002000, 0x00002004)} , FORMULA_SINGLE_PARAMETER(8 , 0x40)}
            /* PDI2PDI Ring Profile : (1+8) registers * 4 occurrences  */
            ,{{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00003400, 0x00003420)} , FORMULA_SINGLE_PARAMETER(4 , 0x40)}
        };
        GT_U32  numOfChunks = sizeof(chunksMem)/sizeof(SMEM_CHUNK_EXTENDED_STC);
        SMEM_UNIT_CHUNKS_STC    tmpUnitChunk;

        smemInitMemChunkExt(devObjPtr,chunksMem, numOfChunks, &tmpUnitChunk);
        /*add the tmp unit chunks to the main unit */
        smemInitMemCombineUnitChunks(devObjPtr,unitPtr,&tmpUnitChunk);
    }

    {
        static SMEM_REGISTER_DEFAULT_VALUE_STC myUnit_registersDefaultValueArr[] =
        {
             {DUMMY_NAME_PTR_CNS,    0x00000000,         0x02200140,      1,    0x4  }
            ,{DUMMY_NAME_PTR_CNS,    0x00000014,         0x00000004,      1,    0x4  }
            ,{DUMMY_NAME_PTR_CNS,    0x00000018,         0x00001116,      1,    0x4  }
            ,{DUMMY_NAME_PTR_CNS,    0x0000001c,         0x00000003,      1,    0x4  }
            ,{DUMMY_NAME_PTR_CNS,    0x00000808,         0x00002014,     32,    0x20 }
            ,{DUMMY_NAME_PTR_CNS,    0x00000814,         0x000f13c0,     32,    0x20 }
            ,{DUMMY_NAME_PTR_CNS,    0x00001000,         0x00000002,     32,    0x30 }
            ,{DUMMY_NAME_PTR_CNS,    0x0000100c,         0x00100000,     32,    0x30 }
            ,{DUMMY_NAME_PTR_CNS,    0x00002004,         0x00000001,      8,    0x40 }
            ,{DUMMY_NAME_PTR_CNS,    0x00003400,         0x00000008,      4,    0x40 }
            ,{DUMMY_NAME_PTR_CNS,    0x00004000,         0xffff0000,      1,    0x4  }

            ,{NULL,                           0,         0x00000000,      0,    0x0  }
        };
        static SMEM_LINK_LIST_REGISTER_DEFAULT_VALUE_STC list = {myUnit_registersDefaultValueArr,NULL};
        unitPtr->unitDefaultRegistersPtr = &list;
    }

    {/* start of unit gdma_regs */

        {/* start of unit general regs*/
            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->CNM.GDMA[0].generalRegs.gdmaBuffersSize            = 0x00000000;
            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->CNM.GDMA[0].generalRegs.gdmaMiscConfig             = 0x00000004;
            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->CNM.GDMA[0].generalRegs.axiTotalOutstandingControlReg = 0x00000008;
            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->CNM.GDMA[0].generalRegs.gdmaSWResetReg             = 0x00000010;
            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->CNM.GDMA[0].generalRegs.gdmaPayloadBufferThreshold = 0x00000018;
        }
        {/* start of unit sys counter regs*/
            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->CNM.GDMA[0].sysCounterRegs.sc_cr       = 0x00000200;
            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->CNM.GDMA[0].sysCounterRegs.sc_cvlr     = 0x00000204;
            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->CNM.GDMA[0].sysCounterRegs.sc_cvhr     = 0x00000208;
            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->CNM.GDMA[0].sysCounterRegs.sc_cvlr_st  = 0x0000020C;
            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->CNM.GDMA[0].sysCounterRegs.sc_cvhr_st  = 0x00000210;
        }
        {/* start of unit SGD and AXI Control regs*/
            GT_U32 q;
            for (q = 0; (q < 32); q++)
            {
                SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->CNM.GDMA[0].sgdAxiControlRegs[q].sgdChainBaseAddressLow    = 0x00000800 + 0x20*q;
                SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->CNM.GDMA[0].sgdAxiControlRegs[q].sgdChainBaseAddressHigh   = 0x00000804 + 0x20*q;
                SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->CNM.GDMA[0].sgdAxiControlRegs[q].sgdBufferAllocationControl= 0x00000808 + 0x20*q;
                SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->CNM.GDMA[0].sgdAxiControlRegs[q].payloadBufferAddressHigh  = 0x0000080C + 0x20*q;
                SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->CNM.GDMA[0].sgdAxiControlRegs[q].addGDMASGDOwn             = 0x00000810 + 0x20*q;
                SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->CNM.GDMA[0].sgdAxiControlRegs[q].axiMaxAttrTable           = 0x00000814 + 0x20*q;
                SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->CNM.GDMA[0].sgdAxiControlRegs[q].axiSGDAttributes          = 0x00000818 + 0x20*q;
                SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->CNM.GDMA[0].sgdAxiControlRegs[q].sgdChainSize              = 0x0000081C + 0x20*q;
            }
        }
        {/* start of unit GDMA timer regs*/
            GT_U32 q;
            for (q = 0; (q < 32); q++)
            {
                SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->CNM.GDMA[0].gdmaTimerRegs[q].timerValue     = 0x00000C00 + 0x10*q;
                SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->CNM.GDMA[0].gdmaTimerRegs[q].timerJitterCfg = 0x00000C04 + 0x10*q;
            }
        }
        {/* start of unit Queue Status and Control regs*/
            GT_U32 q;
            for (q = 0; (q < 32); q++)
            {
                SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->CNM.GDMA[0].queueStatusAndControlRegs[q].queueEnable           = 0x00001000 + q*0x30;
                SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->CNM.GDMA[0].queueStatusAndControlRegs[q].rxBufferByteCount     = 0x00001004 + q*0x30;
                SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->CNM.GDMA[0].queueStatusAndControlRegs[q].queueControl          = 0x0000100C + q*0x30;
                SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->CNM.GDMA[0].queueStatusAndControlRegs[q].wruSGDPointer         = 0x00001010 + q*0x30;
                SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->CNM.GDMA[0].queueStatusAndControlRegs[q].freeSGDsStatusRegister= 0x00001014 + q*0x30;
                SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->CNM.GDMA[0].queueStatusAndControlRegs[q].RX_Drop_counter[0]    = 0x00001018 + q*0x30;
                SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->CNM.GDMA[0].queueStatusAndControlRegs[q].RX_Drop_counter[1]    = 0x0000101c + q*0x30;
                SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->CNM.GDMA[0].queueStatusAndControlRegs[q].stat_counter[0]       = 0x00001020 + q*0x30;
                SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->CNM.GDMA[0].queueStatusAndControlRegs[q].stat_counter[1]       = 0x00001024 + q*0x30;
                SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->CNM.GDMA[0].queueStatusAndControlRegs[q].stat_byte_counter[0]  = 0x00001028 + q*0x30;
                SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->CNM.GDMA[0].queueStatusAndControlRegs[q].stat_byte_counter[1]  = 0x0000102c + q*0x30;
            }
        }
        {/* start of unit Multicast Profile regs*/
            GT_U32 mc_pr;
            for (mc_pr = 0; (mc_pr < 16); mc_pr++)
            {
                SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->CNM.GDMA[0].multicastProfileRegs[mc_pr].multicastInternalOffset = 0x00001800 + mc_pr*0x8;
                SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->CNM.GDMA[0].multicastProfileRegs[mc_pr].multicastExternalOffset = 0x00001804 + mc_pr*0x8;
            }
        }
        {/* start of unit PDI Slave regs*/
            GT_U32 pdi;
            for (pdi = 0; (pdi < 8); pdi++)
            {
                SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->CNM.GDMA[0].pdiSlaveRegs[pdi].pdiSlaveControl          = 0x00002000 + 0x40*pdi;
                SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->CNM.GDMA[0].pdiSlaveRegs[pdi].pdiSlaveArbiterControl   = 0x00002004 + 0x40*pdi;
            }
        }
        {/* start of unit PDI Master regs*/
            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->CNM.GDMA[0].pdiMasterRegs.pdiMasterControl = 0x00002800;
        }
        {/* start of unit PDI to PDI Queue profile regs*/
            GT_U32 p;
            GT_U32 h;
            for (p = 0; (p < 4); p++)
            {
                SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->CNM.GDMA[0].pdiToPdiQueueProfileRegs[p].qProfileControlRegister = 0x00003400 + p*0x40;
                for (h = 0; (h < 8); h++)
                {
                    SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->CNM.GDMA[0].pdiToPdiQueueProfileRegs[p].header[h] = 0x00003404 + p * 0x40 + h * 0x4;
                }
            }
        }
        {/* start of unit Interrupts and Debug regs*/
            GT_U32 q;
            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->CNM.GDMA[0].interruptAndDebugRegs.gdmaRFMetalFixRegister   = 0x00004000;
            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->CNM.GDMA[0].interruptAndDebugRegs.gdmaMiscInterruptCause   = 0x00004004;
            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->CNM.GDMA[0].interruptAndDebugRegs.gdmaMiscInterruptMask    = 0x00004008;
            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->CNM.GDMA[0].interruptAndDebugRegs.badAddrLatchReg          = 0x0000400C;
            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->CNM.GDMA[0].interruptAndDebugRegs.payloadBufferMaxFillLevel= 0x00004010;
            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->CNM.GDMA[0].interruptAndDebugRegs.gdmaQueueStatusRegister  = 0x00004014;
            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->CNM.GDMA[0].interruptAndDebugRegs.gdmaStatusRegister       = 0x00004018;
            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->CNM.GDMA[0].interruptAndDebugRegs.currentSGD0              = 0x00004020;
            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->CNM.GDMA[0].interruptAndDebugRegs.currentSGD1              = 0x00004024;
            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->CNM.GDMA[0].interruptAndDebugRegs.currentSGD2              = 0x00004028;
            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->CNM.GDMA[0].interruptAndDebugRegs.currentSGD3              = 0x0000402C;
            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->CNM.GDMA[0].interruptAndDebugRegs.debugControlRegister     = 0x00004030;
            for (q = 0; (q < 32); q++)
            {
                SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->CNM.GDMA[0].interruptAndDebugRegs.gdmaQInterruptCause[q]   = 0x00004300 + 0x4*q;
                SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->CNM.GDMA[0].interruptAndDebugRegs.gdmaQInterruptMask[q]    = 0x00004380 + 0x4*q;
            }
        }
    }

}

/**
* @internal smemAasUnitCnmGdmaDispatcher function
* @endinternal
*
* @brief   Allocate address type specific memories -- for the Cnm GDMA Dispatcher
*/
static void smemAasUnitCnmGdmaDispatcher
(
    IN SKERNEL_DEVICE_OBJECT *devObjPtr,
    IN SMEM_UNIT_CHUNKS_STC  *unitPtr
)
{
    {
        SMEM_CHUNK_BASIC_STC  chunksMem[]=
        {
             {SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000000, 0x00000000)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000008, 0x0000001C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00003000, 1024) ,SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(7,4),SMEM_BIND_TABLE_MAC(gdmaDispatcherCpuCodeToGdmaQ)}
        };

        GT_U32  numOfChunks = sizeof(chunksMem)/sizeof(SMEM_CHUNK_BASIC_STC);
        smemInitMemChunk(devObjPtr,chunksMem, numOfChunks, unitPtr);
    }

    {
        static SMEM_REGISTER_DEFAULT_VALUE_STC myUnit_registersDefaultValueArr[] =
        {
             {DUMMY_NAME_PTR_CNS,    0x00000000,         0x0000001e,      1,    0x4  }
            ,{DUMMY_NAME_PTR_CNS,    0x00000008,         0x0000026c,      1,    0x4  }
            ,{DUMMY_NAME_PTR_CNS,    0x0000000c,         0x55555555,      1,    0x4  }
            ,{DUMMY_NAME_PTR_CNS,    0x0000001c,         0x00000001,      1,    0x4  }

            ,{NULL,                           0,         0x00000000,      0,    0x0  }
        };
        static SMEM_LINK_LIST_REGISTER_DEFAULT_VALUE_STC list = {myUnit_registersDefaultValueArr,NULL};
        unitPtr->unitDefaultRegistersPtr = &list;
    }

    {
        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->CNM.GDMA_Dispatcher.gdmaDispatcherControl          = 0x00000000;
        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->CNM.GDMA_Dispatcher.dsaFieldOffsets                = 0x00000008;
        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->CNM.GDMA_Dispatcher.packetDebugSuffix              = 0x0000000c;
        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->CNM.GDMA_Dispatcher.gdmaDispatcherInterruptCause   = 0x00000010;
        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->CNM.GDMA_Dispatcher.gdmaDispatcherInterruptMask    = 0x00000014;
        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->CNM.GDMA_Dispatcher.badAddrLatchReg                = 0x00000018;
        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->CNM.GDMA_Dispatcher.dispatcherStatusReg            = 0x0000001c;
    }


}

/**
* @internal smemAasUnitCnmInterrupts function
* @endinternal
*
* @brief   Allocate address type specific memories -- for the Cnm Interrupts
*/
static void smemAasUnitCnmInterrupts
(
    IN SKERNEL_DEVICE_OBJECT *devObjPtr,
    IN SMEM_UNIT_CHUNKS_STC  *unitPtr
)
{
    {
        SMEM_CHUNK_EXTENDED_STC  chunksMem[]=
        {
              /* per tree configurations */
              {{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC(0x00000010, 0x00000014)} , FORMULA_SINGLE_PARAMETER(CNM_MAX_INT_TREES , 0x8)}
              /* per tree interrupts */
             ,{{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC(0x00000100, 0x000001F4)} , FORMULA_SINGLE_PARAMETER(CNM_MAX_INT_TREES , 0x100)}
        };

        GT_U32  numOfChunks = sizeof(chunksMem)/sizeof(SMEM_CHUNK_EXTENDED_STC);
        SMEM_UNIT_CHUNKS_STC    tmpUnitChunk;

        smemInitMemChunkExt(devObjPtr,chunksMem, numOfChunks, &tmpUnitChunk);
        /*add the tmp unit chunks to the main unit */
        smemInitMemCombineUnitChunks(devObjPtr,unitPtr,&tmpUnitChunk);
    }

    {/* start of unit Interrupts regs */
        GT_U32 ii, tree;

        for (tree = 0; (tree < CNM_MAX_INT_TREES); tree++)
        {
            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->CNM.Interrupts.Trees[tree].globalInterruptCause          = 0x00000100 + 0x100*tree;
            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->CNM.Interrupts.Trees[tree].globalInterruptMask           = 0x00000104 + 0x100*tree;

            for (ii = 0; (ii < 4); ii++)
            {
                SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->CNM.Interrupts.Trees[tree].cnmInterruptCause[ii]     = 0x00000108 + 0x100*tree + 0x8*ii;
                SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->CNM.Interrupts.Trees[tree].cnmInterruptMask[ii]      = 0x0000010c + 0x100*tree + 0x8*ii;
            }

            for (ii = 0; (ii < 15); ii++)
            {
                SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->CNM.Interrupts.Trees[tree].unitsInterruptCause[ii]   = 0x00000128 + 0x100*tree + 0x8*ii;
                SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->CNM.Interrupts.Trees[tree].unitsInterruptMask[ii]    = 0x0000012c + 0x100*tree + 0x8*ii;
            }

            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->CNM.Interrupts.Trees[tree].cnmAggregationInterruptCause  = 0x000001a0 + 0x100*tree;
            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->CNM.Interrupts.Trees[tree].cnmAggregationInterruptMask   = 0x000001a4 + 0x100*tree;

            for (ii = 0; (ii < 2); ii++)
            {
                SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->CNM.Interrupts.Trees[tree].highPriorityCoalescingBypassInterruptCause[ii]   = 0x000001a8 + 0x100*tree + 0x8*ii;
                SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->CNM.Interrupts.Trees[tree].highPriorityCoalescingBypassInterruptMask[ii]    = 0x000001ac + 0x100*tree + 0x8*ii;
            }

            for (ii = 0; (ii < 8); ii++)
            {
                SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->CNM.Interrupts.Trees[tree].gdmaInterruptCause[ii]    = 0x000001b8 + 0x100*tree + 0x8*ii;
                SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->CNM.Interrupts.Trees[tree].gdmaInterruptMask[ii]     = 0x000001bc + 0x100*tree + 0x8*ii;
            }
        }
    }
}

/**
* @internal smemAasUnitCnmRfu function
* @endinternal
*
* @brief   Allocate address type specific memories -- for the CNM RFU unit
* @param[in] devObjPtr                - pointer to device memory.
* @param[in,out] unitPtr                  - pointer to the unit chunk
*/
static void smemAasUnitCnmRfu
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    INOUT SMEM_UNIT_CHUNKS_STC  * unitPtr
)
{
    /* Active access bind */
    START_BIND_UNIT_ACTIVE_MEM_MAC(devObjPtr,unitPtr)

        /* /Phoenix/<CNM_IP>CNM_IP/<CNM_IP> <CnM_RFU> CnM_RFU/Units/CNM_Misc/System Soft Reset */
        {0x00000014, SMEM_FULL_MASK_CNS, NULL, 0 , smemFalconActiveWriteCnmRfuSystemSoftResetReg, 0},
        /*device_id -- should reflect same value as in the DFX SERVER */
        {0x00000024, SMEM_FULL_MASK_CNS, NULL, 0, smemChtActiveWriteToReadOnlyReg, 0},
        /*device_number -- should reflect same value as in the DFX SERVER */
        {0x0000002c, SMEM_FULL_MASK_CNS, NULL, 0, smemChtActiveWriteToReadOnlyReg, 0},

    END_BIND_UNIT_ACTIVE_MEM_MAC(devObjPtr,unitPtr)
    {
        SMEM_CHUNK_BASIC_STC  chunksMem[]=
        {
             {SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000000, 0x0000000C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000014, 0x0000001C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000024, 0x00000038)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000040, 0x0000004C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000060, 0x00000070)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00002008, 0x00002008)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x0000201C, 0x0000202C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00003020, 0x00003028)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00003100, 0x00003108)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00004100, 0x00004104)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00004110, 0x00004110)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00004118, 0x0000411C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00004124, 0x0000412C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00004204, 0x00004204)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x0000420C, 0x00004230)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00004300, 0x00004300)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00004310, 0x00004310)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00004400, 0x00004400)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00004600, 0x00004600)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00004800, 0x00004800)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00004900, 0x00004900)}
        };
        GT_U32  numOfChunks = sizeof(chunksMem)/sizeof(SMEM_CHUNK_BASIC_STC);

        smemInitMemChunk(devObjPtr,chunksMem,numOfChunks,unitPtr);
    }

    /* default values */
    {
        static SMEM_REGISTER_DEFAULT_VALUE_STC myUnit_registersDefaultValueArr[]  =
        {
               {DUMMY_NAME_PTR_CNS,            0x0000000c,         0xffff0000,      1,    0x4   }
              ,{DUMMY_NAME_PTR_CNS,            0x00000024,         0x00000400,      1,    0x4   }
              ,{DUMMY_NAME_PTR_CNS,            0x00000038,         0x0000007f,      1,    0x4   }
              ,{DUMMY_NAME_PTR_CNS,            0x00000044,         0x76543210,      1,    0x4   }
              ,{DUMMY_NAME_PTR_CNS,            0x0000201c,         0x00000002,      1,    0x4   }
              ,{DUMMY_NAME_PTR_CNS,            0x00002024,         0x0000000e,      1,    0x4   }
              ,{DUMMY_NAME_PTR_CNS,            0x00003020,         0x0000000b,      2,    0xe0  }
              ,{DUMMY_NAME_PTR_CNS,            0x00003024,         0x00000006,      2,    0xe0  }
              ,{DUMMY_NAME_PTR_CNS,            0x00004210,         0x00000001,      1,    0x4   }
              ,{DUMMY_NAME_PTR_CNS,            0x00004228,         0x000008ff,      1,    0x4   }
              ,{DUMMY_NAME_PTR_CNS,            0x00004230,         0x00000081,      1,    0x4   }
              ,{DUMMY_NAME_PTR_CNS,            0x00004300,         0x0000007f,      1,    0x4   }
              ,{DUMMY_NAME_PTR_CNS,            0x00004310,         0x0000001f,      1,    0x4   }
              ,{DUMMY_NAME_PTR_CNS,            0x00004600,         0x00000030,      1,    0x4   }
              ,{DUMMY_NAME_PTR_CNS,            0x00004800,         0x000000aa,      1,    0x4   }
              ,{DUMMY_NAME_PTR_CNS,            0x00004900,         0x000000ff,      1,    0x4   }

             ,{NULL,    0, 0x00000000,       0,    0x0 }
        };
        static SMEM_LINK_LIST_REGISTER_DEFAULT_VALUE_STC list = {myUnit_registersDefaultValueArr,NULL};
        unitPtr->unitDefaultRegistersPtr = &list;
    }

    {
        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->CNM.RFU.Misc.deviceID     = 0x00000028;
    }
}

/**
* @internal smemAasUnitCnmAddrDecoderUnit function
* @endinternal
*
* @brief   Allocate address type specific memories -- for the CnM Addr decoder unit
* @param[in] devObjPtr                - pointer to device memory.
* @param[in,out] unitPtr                  - pointer to the unit chunk
*/
static void smemAasUnitCnmAddrDecoderUnit
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    INOUT SMEM_UNIT_CHUNKS_STC  * unitPtr
)
{
    {
        SMEM_CHUNK_BASIC_STC  chunksMem[]=
        {
             {SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000000, 0x00000010)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000100, 0x0000027C)}
        };

        GT_U32  numOfChunks = sizeof(chunksMem)/sizeof(SMEM_CHUNK_BASIC_STC);

        smemInitMemChunk(devObjPtr,chunksMem,numOfChunks,unitPtr);

    }
}


/**
* @internal smemAasActiveWriteXSmii function
* @endinternal
*
* @brief   Handler for write to the 10G SMII control register - phy configuration.
*
* @param[in] devObjPtr                - device object PTR.
* @param[in] address                  - Address for ASIC memory.
* @param[in] memPtr                   - Pointer to the register's memory in the simulation.
* @param[in] param                    - Registers' specific parameter.
* @param[in] inMemPtr                 - Pointer to the memory to get register's content.
*/
void smemAasActiveWriteXSmii (
    IN         SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN         GT_U32   address,
    IN         GT_U32   memSize,
    IN         GT_U32 * memPtr,
    IN         GT_UINTPTR   param,
    IN         GT_U32 * inMemPtr
)
{
    GT_U32                operCode;  /* SMII Operation code */

    /* Update the register value */
    *memPtr = *inMemPtr;

    operCode = ((*inMemPtr) >> 26) & 0x7;

    /* clear ReadValid bit */
    SMEM_U32_SET_FIELD((*memPtr),29,1,0);

    switch (operCode)
    {
        case 0x5 :  /* Address then write     */
        case 0x1 :  /* writing a phy register */
            break;

        case 0x2: /* A Post-Read-Inc-Addr transaction */
            break;

        case 0x3 : /* reading a phy register */
        case 0x7 : /* read only              */
        case 0x6 : /* address then increment address read */
            /* read data ready , read-valid */
            *memPtr |= (1 << 29);
            break;

      default: skernelFatalError("smemChtActiveWriteXSmii: wrong opCode %d",
                                    operCode);
    }

    /* clear busy bit */
    SMEM_U32_SET_FIELD((*memPtr),30,1,0);
}

/**
* @internal smemAasUnitCnmXsmi function
* @endinternal
*
* @brief   Allocate address type specific memories -- for the Cnm XSMI
*/
static void smemAasUnitCnmXsmi
(
    IN SKERNEL_DEVICE_OBJECT *devObjPtr,
    IN SMEM_UNIT_CHUNKS_STC  *unitPtr
)
{

    {
        START_BIND_UNIT_ACTIVE_MEM_MAC(devObjPtr,unitPtr)

        /* XSMI Management Register */
        {0x00000000, SMEM_FULL_MASK_CNS, NULL, 0 , smemAasActiveWriteXSmii, 0},

        END_BIND_UNIT_ACTIVE_MEM_MAC(devObjPtr,unitPtr)
    }

    {
        SMEM_CHUNK_BASIC_STC  chunksMem[]=
        {
             {SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000000, 0x00000018)}
        };

        GT_U32  numOfChunks = sizeof(chunksMem)/sizeof(SMEM_CHUNK_BASIC_STC);

        smemInitMemChunk(devObjPtr,chunksMem,numOfChunks,unitPtr);

    }
}


/**
* @internal smemAasUnitWmIpc function
* @endinternal
*
* @brief   Allocate address type specific memories -- for the WM IPC unit
* @param[in] devObjPtr                - pointer to device memory.
* @param[in,out] unitPtr                  - pointer to the unit chunk
*/
static void smemAasUnitWmIpc
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    INOUT SMEM_UNIT_CHUNKS_STC  * unitPtr
)
{
    /* Active access bind */
    START_BIND_UNIT_ACTIVE_MEM_MAC(devObjPtr,unitPtr)

        {0x000000FC, SMEM_FULL_MASK_CNS, NULL, 0, smemChtActiveWriteIpcCpssToWm, 0},

    END_BIND_UNIT_ACTIVE_MEM_MAC(devObjPtr,unitPtr)

    smemAasUnitDummy(devObjPtr,unitPtr,1*_1K);
}


/**
* @internal smemAasSpecificDeviceUnitAlloc_Cnm_units function
* @endinternal
*
* @brief   specific initialization units allocation that called before alloc units
*         of any device.
*         CnM units
* @param[in] devObjPtr                - pointer to device object.
*                                       Pointer to object for specific subunit
*/
static void smemAasSpecificDeviceUnitAlloc_Cnm_units
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr
)
{
    SMEM_DEVICE_UNIT_ALLOCATION_STC allocUnitsArr []=
    {
         {STR(UNIT_CNM_GDMA)            ,smemAasUnitCnmGdma}
        ,{STR(UNIT_CNM_GDMA_DISPATCHER) ,smemAasUnitCnmGdmaDispatcher}
        ,{STR(UNIT_CNM_INTERRUPTS)      ,smemAasUnitCnmInterrupts}
        ,{STR(UNIT_CNM_RFU)             ,smemAasUnitCnmRfu}
        ,{STR(UNIT_ADDR_CNM_Address_Decoder_iNIC),smemAasUnitCnmAddrDecoderUnit}
        ,{STR(UNIT_CNM_XSMI_0)          ,smemAasUnitCnmXsmi}

        ,{STR(UNIT_WM_IPC)              ,smemAasUnitWmIpc}

        /* must be last */
        ,{NULL,NULL}
    };

    smemGenericUnitAlloc(devObjPtr,allocUnitsArr);
}


/**
* @internal smemAasSpecificDeviceUnitAlloc function
* @endinternal
*
* @brief   specific initialization units allocation that called before alloc units
*         of any device
* @param[in] devObjPtr                - pointer to device object.
*                                       Pointer to object for specific subunit
*/
static void smemAasSpecificDeviceUnitAlloc
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr
)
{
    SMEM_CHT_GENERIC_DEV_MEM_INFO *devMemInfoPtr = devObjPtr->deviceMemory;
    SMEM_UNIT_CHUNKS_STC    *currUnitChunkPtr;
    GT_U32  unitIndex;

    currUnitChunkPtr = &devMemInfoPtr->unitMemArr[0];

    for (unitIndex = 0 ; unitIndex < SMEM_CHT_NUM_UNITS_MAX_CNS;
        unitIndex+=1,currUnitChunkPtr += 1)
    {
        currUnitChunkPtr->chunkType = SMEM_UNIT_CHUNK_TYPE_FLEX_BASE_E;
    }

    {
        GT_U32  ii,jj;
        SMEM_GEN_UNIT_INFO_STC   *unitInfoPtr = &aas_units[0];

        for(ii = 0 ; unitInfoPtr->size != SMAIN_NOT_VALID_CNS; ii++,unitInfoPtr++)
        {
            jj = UNIT_INDEX_FROM_ADDR_GET_MAC(devObjPtr,unitInfoPtr->base_addr);

            currUnitChunkPtr = &devMemInfoPtr->unitMemArr[jj];

            if(currUnitChunkPtr->chunkIndex != jj)
            {
                skernelFatalError("smemFalconSpecificDeviceUnitAlloc : not matched index");
            }
            currUnitChunkPtr->numOfUnits = 1;/*unitInfoPtr->size;*/
        }
    }

    /*allocate 'PEX config space' and 'BAR0' -- if not allocated already*/
    smemHarrierPexAndBar0DeviceUnitAlloc(devObjPtr);

    /* some SIP from Aas */
    smemAasSpecificDeviceUnitAlloc_SIP_units(devObjPtr);
    /* some TXQ from Aas */
    smemAasSpecificDeviceUnitAlloc_TXQ_units(devObjPtr);
    /* some TAI from Aas */
    smemAasSpecificDeviceUnitAlloc_TAI_units(devObjPtr);
    /* some CnM from Aas */
    smemAasSpecificDeviceUnitAlloc_Cnm_units(devObjPtr);

    /*CnM from Phoenix*/
    smemPhoenixSpecificDeviceUnitAlloc_Cnm_units(devObjPtr);
    /*DP from Aas*/
    smemAasSpecificDeviceUnitAlloc_DP_units(devObjPtr);
    /*Flexe form Aas */
    smemAasSpecificDeviceUnitAlloc_Flexe_units(devObjPtr);
    /*rest from Harrier*/
    smemHarrierSpecificDeviceUnitAlloc_main(devObjPtr);

}

#define ALIGN_REG_DB_TO_MULTI_INSTANCE_UNIT_IN_PIPE_0_MAC(target_unitName,regDbUnitName, dpIndex) \
    if(SMAIN_NOT_VALID_CNS != UNIT_BASE_ADDR_GET_ALLOW_NON_EXIST_UNIT_MAC(devObjPtr,target_unitName))           \
    {                                                                                                         \
        currUnitChunkPtr = &devMemInfoPtr->unitMemArr[UNIT_INDEX_FROM_ENUM_GET_MAC(devObjPtr,target_unitName)]; \
        smemGenericRegistersArrayAlignToUnit(devObjPtr,                                                       \
            REG_PTR_AND_SIZE_MAC(regAddrDbSip5Ptr->regDbUnitName[dpIndex]),                                   \
            currUnitChunkPtr);                                                                                \
                                                                                                              \
        unitBaseAddress = UNIT_BASE_ADDR_GET_MAC(devObjPtr,target_unitName);                                    \
        SMEM_CHT_SIP5_PP_REGS_UNIT_START_INFO_SET_MAC(devObjPtr,regDbUnitName[dpIndex]           ,unitBaseAddress); \
    }

#define ALIGN_REG_DB_TO_UNIT_MAC(target_unitName,regDbUnitName) \
    if(SMAIN_NOT_VALID_CNS != UNIT_BASE_ADDR_GET_ALLOW_NON_EXIST_UNIT_MAC(devObjPtr,target_unitName))           \
    {                                                                                                         \
        currUnitChunkPtr = &devMemInfoPtr->unitMemArr[UNIT_INDEX_FROM_ENUM_GET_MAC(devObjPtr,target_unitName)]; \
        smemGenericRegistersArrayAlignToUnit(devObjPtr,                                                       \
            REG_PTR_AND_SIZE_MAC(regAddrDbSip5Ptr->regDbUnitName),                                   \
            currUnitChunkPtr);                                                                                \
                                                                                                              \
        unitBaseAddress = UNIT_BASE_ADDR_GET_MAC(devObjPtr,target_unitName);                                    \
        SMEM_CHT_SIP5_PP_REGS_UNIT_START_INFO_SET_MAC(devObjPtr,regDbUnitName,unitBaseAddress); \
    }

/* copy DP unit registers from DP[0] to DP[trgDp] */
#define DUPLICATE_DP_UNIT_ADDR_FROM_DP0_MAC(dpUnit,trgDp)       \
    memcpy(&dpUnit[trgDp].startUnitInfo + 1,                    \
           &dpUnit[0].startUnitInfo + 1,                        \
           sizeof(dpUnit[0]) - sizeof(SMEM_CHT_PP_REGS_UNIT_START_INFO_STC))

#define UNIT_IN_TILE_MAC(orig_unitName,tile) \
    orig_unitName##_TILE_##tile

#define ALIGN_REG_DB_TO_MULTI_INSTANCE_UNIT_IN_TILE_1_MAC(target_unitName,regDbUnitName, dpIndex) \
    if(SMAIN_NOT_VALID_CNS != UNIT_BASE_ADDR_GET_ALLOW_NON_EXIST_UNIT_MAC(devObjPtr,UNIT_IN_TILE_MAC(target_unitName,1/*tile*/)))           \
    {                                                                                                         \
        currUnitChunkPtr = &devMemInfoPtr->unitMemArr[UNIT_INDEX_FROM_ENUM_GET_MAC(devObjPtr,UNIT_IN_TILE_MAC(target_unitName,1/*tile*/))]; \
        smemGenericRegistersArrayAlignToUnit(devObjPtr,                                                       \
            REG_PTR_AND_SIZE_MAC(regAddrDbSip5Ptr->regDbUnitName[dpIndex]),                                   \
            currUnitChunkPtr);                                                                                \
                                                                                                              \
        unitBaseAddress = UNIT_BASE_ADDR_GET_MAC(devObjPtr,UNIT_IN_TILE_MAC(target_unitName,1/*tile*/));      \
        SMEM_CHT_SIP5_PP_REGS_UNIT_START_INFO_SET_MAC(devObjPtr,regDbUnitName[dpIndex]           ,unitBaseAddress); \
    }

#define ALIGN_REG_DB_TO_UNIT_IN_TILE_1_MAC(target_unitName,regDbUnitName) \
    if(SMAIN_NOT_VALID_CNS != UNIT_BASE_ADDR_GET_ALLOW_NON_EXIST_UNIT_MAC(devObjPtr,UNIT_IN_TILE_MAC(target_unitName,1/*tile*/)))     \
    {                                                                                                         \
        currUnitChunkPtr = &devMemInfoPtr->unitMemArr[UNIT_INDEX_FROM_ENUM_GET_MAC(devObjPtr,UNIT_IN_TILE_MAC(target_unitName,1/*tile*/))]; \
        smemGenericRegistersArrayAlignToUnit(devObjPtr,                                                       \
            REG_PTR_AND_SIZE_MAC(regAddrDbSip5Ptr->regDbUnitName),                                            \
            currUnitChunkPtr);                                                                                \
                                                                                                              \
        unitBaseAddress = UNIT_BASE_ADDR_GET_MAC(devObjPtr,UNIT_IN_TILE_MAC(target_unitName,1/*tile*/));      \
        SMEM_CHT_SIP5_PP_REGS_UNIT_START_INFO_SET_MAC(devObjPtr,regDbUnitName,unitBaseAddress); \
    }


typedef enum{
     SHERED_MEM_TYPE_NOT_VALID         = 0
    ,SHERED_MEM_TYPE_NO_SHARE_E              /* the memory is not shared between the 2 tiles */
    ,SHERED_MEM_TYPE_SHARED_BETWEEN_TILES_E  /* the memory is     shared between the 2 tiles */
}SHERED_MEM_TYPE_ENT;
typedef struct{
    GT_BIT        tableOffsetValid;  /* use MACRO SMEM_BIND_TABLE_MAC */
    GT_U32        tableOffsetInBytes;/* use MACRO SMEM_BIND_TABLE_MAC */
    GT_BOOL       forbidDirectWriteToChunk;/* use MACRO SMEM_BIND_TABLE_MAC */
    GT_BOOL isAllocationOfMemoryForbidden;/* use MACRO SMEM_BIND_TABLE_MAC. */
    GT_U32        startAddr;/* init in run time : absolute start address of table (with 8 MSBits) */
    GT_U32        lastAddr; /* init in run time : absolute last  address of table (with 8 MSBits) */
    SHERED_MEM_TYPE_ENT table_unitType_deviceAccess;/* for skernel access   : indication that the table is pipe0/1/shared*/
    SHERED_MEM_TYPE_ENT table_unitType_cpu_access;  /* for SCIB(CPU) access : indication that the table is pipe0/1/shared*/
}SPECIAL_INSTANCE_TABLES_ARR_STC;

/* define memory that access the same one when CPU/PP use pipe 0 or pipe 1 */
#define TABLE_SHARED_2_TILES_MAC(tableName) \
    /*tableOffsetValid,tableOffsetInBytes*/  /*startAddr*/ /*lastAddr*/    /*table_unitType_deviceAccess*/          /*table_unitType_cpu_access*/ \
    /*forbidDirectWriteToChunk*/                                                                                                                  \
    SMEM_BIND_TABLE_MAC(tableName),                 0           ,0          ,SHERED_MEM_TYPE_SHARED_BETWEEN_TILES_E ,SHERED_MEM_TYPE_SHARED_BETWEEN_TILES_E

/**
* @internal smemAasConvertDevAndAddrToNewDevAndAddr function
* @endinternal
*
* @brief   AAS : Convert (dev,address) to new (dev,address).
*         needed for multi-tile device.
* @param[in] devObjPtr                - pointer to device object.
* @param[in] address                  -  of memory(register or table).
* @param[in] accessType               - the access type
*                                       None
*
* @note function MUST be called before calling smemFindMemory()
*
*/
static void smemAasConvertDevAndAddrToNewDevAndAddr
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN GT_U32                  address,
    IN SCIB_MEMORY_ACCESS_TYPE accessType,
    OUT SKERNEL_DEVICE_OBJECT ** newDevObjPtrPtr,
    OUT GT_U32                  *newAddressPtr
)
{
    GT_U32  newAddress;
    GT_U32 currentPipeId;

    *newDevObjPtrPtr = devObjPtr;

    if(IS_DFX_OPERATION_MAC(accessType) &&
        SMEM_CHT_IS_DFX_ON_UNIQUE_MEMORY_SPCAE(devObjPtr))
    {
        /* the DFX is only on 'pipe 0' */
        /* so no address modifications */
        *newAddressPtr = address;
        return;
    }

    if(0 == IS_SKERNEL_OPERATION_MAC(accessType))
    {
        if((devObjPtr->fdbNumOfBanks < 16) &&
           (address >= (AAS_ADDR_FDB) &&
            address <  (AAS_ADDR_FDB + FDB_REG_OFFSET)))
        {
            GT_U32  bankId,lineIndex,byteOffset;

            byteOffset = address & 0x1f;/* 0x1f = FDB_TABLE_ALIGN_IN_BYTES -1 */
                         /* 5 is for '/ FDB_TABLE_ALIGN_IN_BYTES' */
            bankId    = (address >> 5) & (devObjPtr->fdbNumOfBanks == 8 ? 0x7 : 0x3);
                            /* 9 is 5 from above + 4 bits of bankId */
            lineIndex = ((address-AAS_ADDR_FDB) >> 9);

            /* new address is : */
            newAddress = AAS_ADDR_FDB |
                        (lineIndex << (devObjPtr->fdbNumOfBanks == 8 ? 8 : 7)) |
                        (bankId << 5) |
                        byteOffset;
        }
        else
        {
            /* the CPU access 'pipe 0/1' explicitly */
            /* so no address modifications */
            /* but still shared memories that CPU access address at unit x may be 'redirected' to other place */
            /* so need to allow call to falcon_specialSingleInstanceAddressInfoGet(...) */

            newAddress = address;
        }
    }
    else
    {
        if(address >= devObjPtr->tileOffset) /* regardless to the 'current pipe Id' */
        {
            /* explicit access to other than tile 0 , do not modify */
            *newAddressPtr = address;
            return;
        }

        currentPipeId = smemGetCurrentPipeId(devObjPtr);

        if(currentPipeId == 0)
        {
            /* no address update needed for pipe 0 accessing */
            *newAddressPtr = address;
            return;
        }
        newAddress = address + devObjPtr->tileOffset;
    }

    *newAddressPtr = newAddress;

    return;
}

/**
* @internal smemAasInitRegDbDpUnits function
* @endinternal
*
* @brief   Init RegDb for DP units
*/
static void smemAasInitRegDbDpUnits
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr
)
{
    SMEM_CHT_GENERIC_DEV_MEM_INFO *devMemInfoPtr = devObjPtr->deviceMemory;
    SMEM_UNIT_CHUNKS_STC    *currUnitChunkPtr;
    SMEM_SIP5_PP_REGS_ADDR_STC      *regAddrDbSip5Ptr = SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr);
    GT_U32  unitBaseAddress;

    /* support CNC2,3 */
    ALIGN_REG_DB_TO_MULTI_INSTANCE_UNIT_IN_PIPE_0_MAC(UNIT_CNC_2 , CNC ,2);/*CNC[2]*/
    ALIGN_REG_DB_TO_MULTI_INSTANCE_UNIT_IN_PIPE_0_MAC(UNIT_CNC_3 , CNC ,3);/*CNC[3]*/

    /* need to be called before
        ALIGN_REG_DB_TO_UNIT_MAC(UNIT_CNM_GDMA   , CNM.GDMA[0]);
        ALIGN_REG_DB_TO_UNIT_MAC(UNIT_CNM_GDMA_1 , CNM.GDMA[1]);
        ALIGN_REG_DB_TO_UNIT_MAC(UNIT_CNM_GDMA_2 , CNM.GDMA[2]);
        ALIGN_REG_DB_TO_UNIT_MAC(UNIT_CNM_GDMA_3 , CNM.GDMA[3]);
    */
    DUPLICATE_DP_UNIT_ADDR_FROM_DP0_MAC(SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->CNM.GDMA   , 1);
    DUPLICATE_DP_UNIT_ADDR_FROM_DP0_MAC(SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->CNM.GDMA   , 2);
    DUPLICATE_DP_UNIT_ADDR_FROM_DP0_MAC(SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->CNM.GDMA   , 3);

    DUPLICATE_DP_UNIT_ADDR_FROM_DP0_MAC(SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->EXACT_MATCH   , 1);
    DUPLICATE_DP_UNIT_ADDR_FROM_DP0_MAC(SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->EXACT_MATCH   , 2);
    DUPLICATE_DP_UNIT_ADDR_FROM_DP0_MAC(SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->EXACT_MATCH   , 3);
    DUPLICATE_DP_UNIT_ADDR_FROM_DP0_MAC(SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->EXACT_MATCH   , 4);
    DUPLICATE_DP_UNIT_ADDR_FROM_DP0_MAC(SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->EXACT_MATCH   , 5);
    DUPLICATE_DP_UNIT_ADDR_FROM_DP0_MAC(SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->EXACT_MATCH   , 6);
    DUPLICATE_DP_UNIT_ADDR_FROM_DP0_MAC(SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->EXACT_MATCH   , 7);

    ALIGN_REG_DB_TO_MULTI_INSTANCE_UNIT_IN_PIPE_0_MAC(UNIT_TXQ_SDQ0 , SIP6_TXQ_SDQ ,0);/*DP[0]*/
    ALIGN_REG_DB_TO_MULTI_INSTANCE_UNIT_IN_PIPE_0_MAC(UNIT_TXQ_SDQ1 , SIP6_TXQ_SDQ ,1);/*DP[1]*/
    ALIGN_REG_DB_TO_MULTI_INSTANCE_UNIT_IN_PIPE_0_MAC(UNIT_TXQ_SDQ2 , SIP6_TXQ_SDQ ,2);/*DP[2]*/
    ALIGN_REG_DB_TO_MULTI_INSTANCE_UNIT_IN_PIPE_0_MAC(UNIT_TXQ_SDQ3 , SIP6_TXQ_SDQ ,3);/*DP[3]*/

    ALIGN_REG_DB_TO_MULTI_INSTANCE_UNIT_IN_PIPE_0_MAC(UNIT_TXQ_QFC0 , SIP6_TXQ_QFC ,0);/*DP[0]*/
    ALIGN_REG_DB_TO_MULTI_INSTANCE_UNIT_IN_PIPE_0_MAC(UNIT_TXQ_QFC1 , SIP6_TXQ_QFC ,1);/*DP[1]*/
    ALIGN_REG_DB_TO_MULTI_INSTANCE_UNIT_IN_PIPE_0_MAC(UNIT_TXQ_QFC2 , SIP6_TXQ_QFC ,2);/*DP[2]*/
    ALIGN_REG_DB_TO_MULTI_INSTANCE_UNIT_IN_PIPE_0_MAC(UNIT_TXQ_QFC3 , SIP6_TXQ_QFC ,3);/*DP[3]*/

    /* set register addresses for sip6_rxDMA[0..2])*/
    ALIGN_REG_DB_TO_MULTI_INSTANCE_UNIT_IN_PIPE_0_MAC(UNIT_RX_DMA   , sip6_rxDMA ,0);/*DP[0]*/
    ALIGN_REG_DB_TO_MULTI_INSTANCE_UNIT_IN_PIPE_0_MAC(UNIT_RX_DMA_1 , sip6_rxDMA ,1);/*DP[1]*/
    ALIGN_REG_DB_TO_MULTI_INSTANCE_UNIT_IN_PIPE_0_MAC(UNIT_RX_DMA_2 , sip6_rxDMA ,2);/*DP[2]*/
    ALIGN_REG_DB_TO_MULTI_INSTANCE_UNIT_IN_PIPE_0_MAC(UNIT_RX_DMA_3 , sip6_rxDMA ,3);/*DP[3]*/

    /* set register addresses for sip6_txDMA[0..2])*/
    ALIGN_REG_DB_TO_MULTI_INSTANCE_UNIT_IN_PIPE_0_MAC(UNIT_TX_DMA   , sip6_txDMA ,0);/*DP[0]*/
    ALIGN_REG_DB_TO_MULTI_INSTANCE_UNIT_IN_PIPE_0_MAC(UNIT_TX_DMA_1 , sip6_txDMA ,1);/*DP[1]*/
    ALIGN_REG_DB_TO_MULTI_INSTANCE_UNIT_IN_PIPE_0_MAC(UNIT_TX_DMA_2 , sip6_txDMA ,2);/*DP[2]*/
    ALIGN_REG_DB_TO_MULTI_INSTANCE_UNIT_IN_PIPE_0_MAC(UNIT_TX_DMA_3 , sip6_txDMA ,3);/*DP[3]*/

    /* set register addresses for sip6_txFIFO[0..2])*/
    ALIGN_REG_DB_TO_MULTI_INSTANCE_UNIT_IN_PIPE_0_MAC(UNIT_TX_FIFO   , sip6_txFIFO ,0);/*DP[0]*/
    ALIGN_REG_DB_TO_MULTI_INSTANCE_UNIT_IN_PIPE_0_MAC(UNIT_TX_FIFO_1 , sip6_txFIFO ,1);/*DP[1]*/
    ALIGN_REG_DB_TO_MULTI_INSTANCE_UNIT_IN_PIPE_0_MAC(UNIT_TX_FIFO_2 , sip6_txFIFO ,2);/*DP[2]*/
    ALIGN_REG_DB_TO_MULTI_INSTANCE_UNIT_IN_PIPE_0_MAC(UNIT_TX_FIFO_3 , sip6_txFIFO ,3);/*DP[3]*/

    ALIGN_REG_DB_TO_UNIT_MAC(UNIT_TXQ_PDX , SIP6_TXQ_PDX);

    ALIGN_REG_DB_TO_UNIT_MAC(UNIT_PREQ,PREQ);
    ALIGN_REG_DB_TO_UNIT_MAC(UNIT_EREP,EREP);
    ALIGN_REG_DB_TO_UNIT_MAC(UNIT_PHA,PHA);
    ALIGN_REG_DB_TO_UNIT_MAC(UNIT_SHM,SHM);

    ALIGN_REG_DB_TO_UNIT_MAC(UNIT_PPU,PPU);
    ALIGN_REG_DB_TO_UNIT_MAC(UNIT_PPU_FOR_IPE , PPU_FOR_IPE);
    ALIGN_REG_DB_TO_UNIT_MAC(UNIT_CNM_AAC, CNM.AAC);
    ALIGN_REG_DB_TO_UNIT_MAC(UNIT_CNM_MPP_RFU, CNM.MPP_RFU);
    ALIGN_REG_DB_TO_UNIT_MAC(UNIT_CNM_GDMA_DISPATCHER , CNM.GDMA_Dispatcher);
    ALIGN_REG_DB_TO_UNIT_MAC(UNIT_CNM_GDMA   , CNM.GDMA[0]);
    ALIGN_REG_DB_TO_UNIT_MAC(UNIT_CNM_GDMA_1 , CNM.GDMA[1]);
    ALIGN_REG_DB_TO_UNIT_MAC(UNIT_CNM_GDMA_2 , CNM.GDMA[2]);
    ALIGN_REG_DB_TO_UNIT_MAC(UNIT_CNM_GDMA_3 , CNM.GDMA[3]);
    ALIGN_REG_DB_TO_UNIT_MAC(UNIT_CNM_INTERRUPTS , CNM.Interrupts);
    ALIGN_REG_DB_TO_UNIT_MAC(UNIT_CNM_RFU , CNM.RFU);

    ALIGN_REG_DB_TO_UNIT_MAC(UNIT_SMU , SMU);

    ALIGN_REG_DB_TO_UNIT_MAC(UNIT_EMX , EMX);
    ALIGN_REG_DB_TO_UNIT_MAC(UNIT_TTI_LU , TTI_LU);
    ALIGN_REG_DB_TO_UNIT_MAC(UNIT_IPE , IPE);
    ALIGN_REG_DB_TO_UNIT_MAC(UNIT_MPCL, MPCL);
    ALIGN_REG_DB_TO_MULTI_INSTANCE_UNIT_IN_PIPE_0_MAC(UNIT_EM,  EXACT_MATCH, 0);
    ALIGN_REG_DB_TO_MULTI_INSTANCE_UNIT_IN_PIPE_0_MAC(UNIT_EM1, EXACT_MATCH, 1);
    ALIGN_REG_DB_TO_MULTI_INSTANCE_UNIT_IN_PIPE_0_MAC(UNIT_EM2, EXACT_MATCH, 2);
    ALIGN_REG_DB_TO_MULTI_INSTANCE_UNIT_IN_PIPE_0_MAC(UNIT_EM3, EXACT_MATCH, 3);
    ALIGN_REG_DB_TO_MULTI_INSTANCE_UNIT_IN_PIPE_0_MAC(UNIT_EM4, EXACT_MATCH, 4);
    ALIGN_REG_DB_TO_MULTI_INSTANCE_UNIT_IN_PIPE_0_MAC(UNIT_EM5, EXACT_MATCH, 5);
    ALIGN_REG_DB_TO_MULTI_INSTANCE_UNIT_IN_PIPE_0_MAC(UNIT_EM6, EXACT_MATCH, 6);
    ALIGN_REG_DB_TO_MULTI_INSTANCE_UNIT_IN_PIPE_0_MAC(UNIT_EM7, EXACT_MATCH, 7);
    ALIGN_REG_DB_TO_UNIT_MAC(UNIT_REDUCED_EM, REDUCED_EM);

    if(devObjPtr->numOfTiles > 1)
    {
        /* second tile */
        ALIGN_REG_DB_TO_MULTI_INSTANCE_UNIT_IN_TILE_1_MAC(UNIT_TXQ_SDQ0 , SIP6_TXQ_SDQ ,5);/*DP[0]*/
        ALIGN_REG_DB_TO_MULTI_INSTANCE_UNIT_IN_TILE_1_MAC(UNIT_TXQ_SDQ1 , SIP6_TXQ_SDQ ,6);/*DP[1]*/
        ALIGN_REG_DB_TO_MULTI_INSTANCE_UNIT_IN_TILE_1_MAC(UNIT_TXQ_SDQ2 , SIP6_TXQ_SDQ ,7);/*DP[2]*/
        ALIGN_REG_DB_TO_MULTI_INSTANCE_UNIT_IN_TILE_1_MAC(UNIT_TXQ_SDQ3 , SIP6_TXQ_SDQ ,8);/*DP[3]*/

        ALIGN_REG_DB_TO_MULTI_INSTANCE_UNIT_IN_TILE_1_MAC(UNIT_TXQ_QFC0 , SIP6_TXQ_QFC ,4);/*DP[0]*/
        ALIGN_REG_DB_TO_MULTI_INSTANCE_UNIT_IN_TILE_1_MAC(UNIT_TXQ_QFC1 , SIP6_TXQ_QFC ,5);/*DP[1]*/
        ALIGN_REG_DB_TO_MULTI_INSTANCE_UNIT_IN_TILE_1_MAC(UNIT_TXQ_QFC2 , SIP6_TXQ_QFC ,6);/*DP[2]*/
        ALIGN_REG_DB_TO_MULTI_INSTANCE_UNIT_IN_TILE_1_MAC(UNIT_TXQ_QFC3 , SIP6_TXQ_QFC ,7);/*DP[3]*/

        /* set register addresses for sip6_rxDMA[0..2])*/
        ALIGN_REG_DB_TO_MULTI_INSTANCE_UNIT_IN_TILE_1_MAC(UNIT_RX_DMA   , sip6_rxDMA ,4);/*DP[0]*/
        ALIGN_REG_DB_TO_MULTI_INSTANCE_UNIT_IN_TILE_1_MAC(UNIT_RX_DMA_1 , sip6_rxDMA ,5);/*DP[1]*/
        ALIGN_REG_DB_TO_MULTI_INSTANCE_UNIT_IN_TILE_1_MAC(UNIT_RX_DMA_2 , sip6_rxDMA ,6);/*DP[2]*/
        ALIGN_REG_DB_TO_MULTI_INSTANCE_UNIT_IN_TILE_1_MAC(UNIT_RX_DMA_3 , sip6_rxDMA ,7);/*DP[3]*/

        ALIGN_REG_DB_TO_MULTI_INSTANCE_UNIT_IN_TILE_1_MAC(UNIT_RX_DMA    , rxDMA     ,4);/*DP[4]*/
        ALIGN_REG_DB_TO_MULTI_INSTANCE_UNIT_IN_TILE_1_MAC(UNIT_RX_DMA_1  , rxDMA     ,5);/*DP[5]*/
        ALIGN_REG_DB_TO_MULTI_INSTANCE_UNIT_IN_TILE_1_MAC(UNIT_RX_DMA_2  , rxDMA     ,6);/*DP[6]*/
        ALIGN_REG_DB_TO_MULTI_INSTANCE_UNIT_IN_TILE_1_MAC(UNIT_RX_DMA_3  , rxDMA     ,7);/*DP[7]*/

        ALIGN_REG_DB_TO_MULTI_INSTANCE_UNIT_IN_TILE_1_MAC(UNIT_IA        , ingressAggregator ,1);

        /* set register addresses for sip6_txDMA[0..2])*/
        ALIGN_REG_DB_TO_MULTI_INSTANCE_UNIT_IN_TILE_1_MAC(UNIT_TX_DMA   , sip6_txDMA ,4);/*DP[0]*/
        ALIGN_REG_DB_TO_MULTI_INSTANCE_UNIT_IN_TILE_1_MAC(UNIT_TX_DMA_1 , sip6_txDMA ,5);/*DP[1]*/
        ALIGN_REG_DB_TO_MULTI_INSTANCE_UNIT_IN_TILE_1_MAC(UNIT_TX_DMA_2 , sip6_txDMA ,6);/*DP[2]*/
        ALIGN_REG_DB_TO_MULTI_INSTANCE_UNIT_IN_TILE_1_MAC(UNIT_TX_DMA_3 , sip6_txDMA ,7);/*DP[3]*/

        /* set register addresses for sip6_txFIFO[0..2])*/
        ALIGN_REG_DB_TO_MULTI_INSTANCE_UNIT_IN_TILE_1_MAC(UNIT_TX_FIFO   , sip6_txFIFO ,4);/*DP[0]*/
        ALIGN_REG_DB_TO_MULTI_INSTANCE_UNIT_IN_TILE_1_MAC(UNIT_TX_FIFO_1 , sip6_txFIFO ,5);/*DP[1]*/
        ALIGN_REG_DB_TO_MULTI_INSTANCE_UNIT_IN_TILE_1_MAC(UNIT_TX_FIFO_2 , sip6_txFIFO ,6);/*DP[2]*/
        ALIGN_REG_DB_TO_MULTI_INSTANCE_UNIT_IN_TILE_1_MAC(UNIT_TX_FIFO_3 , sip6_txFIFO ,7);/*DP[3]*/

        /* next are 'single' in the DB of registers and therefore not need additional settings
        ALIGN_REG_DB_TO_UNIT_IN_TILE_1_MAC(UNIT_TXQ_PDX , SIP6_TXQ_PDX);

        ALIGN_REG_DB_TO_UNIT_IN_TILE_1_MAC(UNIT_PREQ,PREQ);
        ALIGN_REG_DB_TO_UNIT_IN_TILE_1_MAC(UNIT_EREP,EREP);
        ALIGN_REG_DB_TO_UNIT_IN_TILE_1_MAC(UNIT_EM,EXACT_MATCH);
        ALIGN_REG_DB_TO_UNIT_IN_TILE_1_MAC(UNIT_PHA,PHA);
        ALIGN_REG_DB_TO_UNIT_IN_TILE_1_MAC(UNIT_SHM,SHM);

        ALIGN_REG_DB_TO_UNIT_IN_TILE_1_MAC(UNIT_PPU,PPU);

        ALIGN_REG_DB_TO_UNIT_IN_TILE_1_MAC(UNIT_CNM_AAC, CNM.AAC);
        ALIGN_REG_DB_TO_UNIT_IN_TILE_1_MAC(UNIT_CNM_MPP_RFU, CNM.MPP_RFU);

        ALIGN_REG_DB_TO_UNIT_IN_TILE_1_MAC(UNIT_SMU , SMU);
        */
    }

    {
        SMEM_CHT_DEV_COMMON_MEM_INFO  * commonDevMemInfoPtr;

        /* point pipe1 to look directly to pipe 0 memory */
        /* NOTE: the function smemFalconConvertDevAndAddrToNewDevAndAddr will help
           any memory access via pipe1 to access proper unit in the 'pipe 0 device' */
        commonDevMemInfoPtr = devObjPtr->deviceMemory;
        commonDevMemInfoPtr->smemConvertDevAndAddrToNewDevAndAddrFunc =
            smemAasConvertDevAndAddrToNewDevAndAddr;
    }
}

/**
* @internal internal_InterruptTreeInit function
* @endinternal
*
* @brief   Init interrupt tree for specific device.
*
* @param[in] devObjPtr                - (pointer to) device object.
*                                      currDbPtrPtr - (pointer ti) pointer to device interrupt tree to be initialized.
*/
static GT_VOID  internal_InterruptTreeInit
(
     IN SKERNEL_DEVICE_OBJECT *devObjPtr,
     INOUT SKERNEL_INTERRUPT_REG_INFO_STC ** currDbPtrPtr
)
{
    smemAasInterruptTreeInit(devObjPtr);
}

static void regAddr_anp
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN GT_U32 unitIndex
)
{
    GT_U32  unitOffset;
    SMEM_CHT_PORT_ANP_UNIT_REG_STC  *unitDbPtr;

    unitDbPtr = &SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->sip_6_10_ANP[unitIndex].ANP;
    unitOffset = devObjPtr->memUnitBaseAddrInfo.anp[unitIndex];

#if 0
    unitDbPtr->portInterruptCause[0] = unitOffset + 0x100; /*0x00000100*/
    unitDbPtr->portInterruptMask[0] = unitOffset + 0x104; /*0x00000104*/
#endif
    unitDbPtr->interruptSummaryCause = unitOffset + 0xb0; /*0x00000094*/
    unitDbPtr->interruptSummaryMask = unitOffset + 0xb4; /*0x00000098*/
}

/**
* @internal regAddr_mif function
* @endinternal
*
* @brief   initialize the register DB - MIF
*
* @param[in] devObjPtr - pointer to device object.
*            unitIndex - unit index
*
*/
static void regAddr_mif
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN GT_U32 portNum,      /* global port in the device */
    IN GT_U32 sip6_MTI_EXTERNAL_representativePortIndex,
    IN GT_U32 portIndex,    /* local  port in the unit */
    IN GT_U32 unitIndex     /* the unit index 0..6 */
)
{
    GT_U32  unitOffset = devObjPtr->memUnitBaseAddrInfo.mif[unitIndex];
    GT_U32  isCpuPort = 0;
    GT_U32  isHighSpeedPort = 0;

    SMEM_CHT_PORT_MTI_PORT_MIF_REG_STC  *portDbPtr;
    ENHANCED_PORT_INFO_STC portInfo;

    if(unitOffset == 0)
    {
        skernelFatalError("regAddr_mif : non-valid unit[%d]",unitIndex);
        return;
    }

    if(GT_OK == smemAasPortInfoGet(devObjPtr,SMEM_UNIT_TYPE_MTI_MAC_CPU_E,portNum,&portInfo))
    {
        isCpuPort = 1;
    }

    if(devObjPtr->portsArr[portNum].state == SKERNEL_PORT_STATE_MTI_400_E)
    {
        isHighSpeedPort = 1;
    }

    if(isCpuPort)
    {
        portDbPtr = &SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->sip6_MTI_cpu_port[sip6_MTI_EXTERNAL_representativePortIndex/*0*/].MIF_CPU;
    }
    else
    {

        portDbPtr = &SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->sip6_MTI[portNum].MIF;
    }

    portDbPtr->mif_channel_mapping_register[0] = unitOffset +  0x00000A00 + portIndex*0x4;
    portDbPtr->mif_link_fsm_control_register[0] = unitOffset +  0x00000C00 + portIndex*0x4;

    /*portDbPtr->preemption.mif_link_fsm_control_register[0] = unitOffset +  0x00000C00 + portIndex*0x4;*/

    if(isHighSpeedPort && portIndex == 0)  /* 'fake' mifType */
    {
        portIndex = 8;
        /* use 'channel 8' and mif type = 1 , to hold the mif info for this mac when is 400G/800G */
        portDbPtr->mif_channel_mapping_register[1] = unitOffset +  0x00000A00 + portIndex*0x4;
        portDbPtr->mif_link_fsm_control_register[1] = unitOffset +  0x00000C00 + portIndex*0x4;
    }
}

/**
* @internal regAddr_lmu function
* @endinternal
*
* @brief   initialize the register DB - LMU
*
* @param[in] devObjPtr - pointer to device object.
*            unitIndex - unit index (0..31 or 0..63)
*
*/
static void regAddr_lmu
(
    IN SKERNEL_DEVICE_OBJECT *devObjPtr,
    IN GT_U32                unitIndex
)
{
    GT_U32 unitOffset;
    GT_U32    k;

    unitOffset = devObjPtr->memUnitBaseAddrInfo.lmu[unitIndex];

    SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->LMU[unitIndex].averageCoefficient           = 0x00008020 + unitOffset;
    SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->LMU[unitIndex].profileStatisticsReadData[0] = 0x00008030 + unitOffset;
    SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->LMU[unitIndex].profileStatisticsReadData[1] = 0x00008034 + unitOffset;
    SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->LMU[unitIndex].profileStatisticsReadData[2] = 0x00008038 + unitOffset;
    SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->LMU[unitIndex].profileStatisticsReadData[3] = 0x0000803C + unitOffset;
    SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->LMU[unitIndex].profileStatisticsReadData[4] = 0x00008040 + unitOffset;
    SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->LMU[unitIndex].profileStatisticsReadData[5] = 0x00008044 + unitOffset;
    SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->LMU[unitIndex].summary_cause                = 0x00008230 + unitOffset;
    SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->LMU[unitIndex].summary_mask                 = 0x00008234 + unitOffset;
    for(k = 0; k < 17; k++)
    {
        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->LMU[unitIndex].latencyOverThreshold_cause[k] = 0x00008100 + 0x4 * k + unitOffset;
        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->LMU[unitIndex].latencyOverThreshold_mask[k]  = 0x00008180 + 0x4 * k + unitOffset;
    }
    SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->LMU[unitIndex].channelEnable = 0x00008000 + unitOffset;
}

/**
* @internal regAddr_tsu function
* @endinternal
*
* @brief   initialize the register DB - PTP/TSU
*
* @param[in] devObjPtr - pointer to device object.
*            portNum   - port number
*
*/
static void regAddr_tsu
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN GT_U32 portNum,      /* global port in the device */
    IN GT_U32 portIndex,    /* local  port in the unit */
    IN GT_U32 unitIndex     /* the unit index 0..3 */
)
{
    /* aligned to /Cider/EBU-IP/PCA/CTSU IP/CTSU 1.0/CTSU {1.0.6} */
    GT_U32  unitOffset = devObjPtr->memUnitBaseAddrInfo.tsu[unitIndex];

    if(portIndex == 0)/* done by first port in unit */
    {
        GT_U32  index;

        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->GOP_PTP.TSU_GLOBAL[unitIndex].PTPInterruptCause    = 0x00000080 + unitOffset;
        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->GOP_PTP.TSU_GLOBAL[unitIndex].PTPInterruptMask     = 0x00000084 + unitOffset;
        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->GOP_PTP.TSU_GLOBAL[unitIndex].PTPGeneralCtrl       = 0x00000000 + unitOffset;
        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->GOP_PTP.TSU_GLOBAL[unitIndex].totalPTPPktsCntr     = 0x00000008 + unitOffset;
        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->GOP_PTP.TSU_GLOBAL[unitIndex].NTPPTPOffsetLow      = 0x00000004 + unitOffset;

        for(index=0; index<NUM_PORTS_PER_CTSU_UNIT; index++)
        {
            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->GOP_PTP.TSU_GLOBAL[unitIndex].timestampFrameCntrControl[index] = 0x00000500 + 0x4 * index + unitOffset;
            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->GOP_PTP.TSU_GLOBAL[unitIndex].timestampFrameCntr[index]        = 0x00000100 + 0x4 * index + unitOffset;
        }
    }

    {
        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->GOP_PTP.PTP[portNum].timestampingPrecisionControl = 0x00001400 + portIndex * 0x4 + unitOffset;
        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->GOP_PTP.PTP[portNum].PTPTXTimestampQueue0Reg0 = 0x00004000 + portIndex * 0x8 + unitOffset;
        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->GOP_PTP.PTP[portNum].PTPTXTimestampQueue0Reg1 = 0x00004004 + portIndex * 0x8 + unitOffset;
        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->GOP_PTP.PTP[portNum].PTPTXTimestampQueue1Reg0 = 0x00004800 + portIndex * 0x8 + unitOffset;
        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->GOP_PTP.PTP[portNum].PTPTXTimestampQueue1Reg1 = 0x00004804 + portIndex * 0x8 + unitOffset;
    }
}
/**
* @internal regAddr_100GMac function
* @endinternal
*
* @brief   initialize the register DB - 100G MAC
*
* @param[in] devObjPtr - pointer to device object.
*            portNum   - global port number
*            portIndex - local port in the unit
*            unitIndex - the unit index 0..3
*
*/
static void regAddr_100GMac
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN GT_U32 portNum,
    IN GT_U32 portIndex,
    IN GT_U32 unitIndex
)
{
    GT_U32  unitOffset = devObjPtr->memUnitBaseAddrInfo.macWrap[unitIndex] + PORT0_100G_OFFSET;
    GT_U32  portFormula;

    if(devObjPtr->memUnitBaseAddrInfo.macWrap[unitIndex] == 0)
    {
        skernelFatalError("regAddr_100GMac : non-valid unit[%d]",unitIndex);
        return;
    }

    portFormula = (MAC_STEP_PORT_OFFSET * portIndex);

    {
        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->sip6_MTI[portNum].MTI_WRAPPER._802_3_BR.brControl      = 0x000000A8 + portFormula + unitOffset;

        /* WARNING !!! the 'EMAC' is on offset 0x100 from the base ! */
        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->sip6_MTI[portNum].MTI_WRAPPER.MTI64_MAC.commandConfig  = 0x00000008 + EMAC_OFFSET + portFormula + unitOffset;
        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->sip6_MTI[portNum].MTI_WRAPPER.MTI64_MAC.frmLength      = 0x00000014 + EMAC_OFFSET + portFormula + unitOffset;
        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->sip6_MTI[portNum].MTI_WRAPPER.MTI64_MAC.macAddr0       = 0x0000000C + EMAC_OFFSET + portFormula + unitOffset;
        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->sip6_MTI[portNum].MTI_WRAPPER.MTI64_MAC.macAddr1       = 0x00000010 + EMAC_OFFSET + portFormula + unitOffset;
        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->sip6_MTI[portNum].MTI_WRAPPER.MTI64_MAC.status         = 0x00000040 +               portFormula + unitOffset; /*shared with MTI_PREEMPTION_MAC */

        /* WARNING !!! the 'PMAC' is on offset 0x000 from the base ... meaning on 'legacy addresses' !!! */
        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->sip6_MTI[portNum].MTI_WRAPPER.MTI_PREEMPTION_MAC.commandConfig  = 0x00000008 + portFormula + unitOffset;
        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->sip6_MTI[portNum].MTI_WRAPPER.MTI_PREEMPTION_MAC.frmLength      = 0x00000014 + portFormula + unitOffset;
        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->sip6_MTI[portNum].MTI_WRAPPER.MTI_PREEMPTION_MAC.macAddr0       = 0x0000000C + portFormula + unitOffset;
        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->sip6_MTI[portNum].MTI_WRAPPER.MTI_PREEMPTION_MAC.macAddr1       = 0x00000010 + portFormula + unitOffset;
        /*SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->sip6_MTI[portNum].MTI_WRAPPER.MTI_PREEMPTION_MAC.status         = 0x00000040 + portFormula + unitOffset; shared with MTI64_MAC */


        /*printf("MAC100G[%d]=0x%x\n", portNum, (SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->sip6_MTI[portNum].MTI_WRAPPER.MTI64_MAC.commandConfig));*/

    }

}

/**
* @internal regAddr_400GMac function
* @endinternal
*
* @brief   initialize the register DB - 400G MAC
*
* @param[in] devObjPtr - pointer to device object.
*            portNum   - global port number
*            portIndex - local port in the unit
*            unitIndex - the unit index 0..3
*
*/
static void regAddr_400GMac
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN GT_U32 portNum,
    IN GT_U32 portIndex,
    IN GT_U32 unitIndex
)
{
    GT_U32  portFormula;
    GT_U32  unitOffset = devObjPtr->memUnitBaseAddrInfo.macWrap[unitIndex] + MAC_400G_OFFSET;

    if(devObjPtr->memUnitBaseAddrInfo.macWrap[unitIndex] == 0)
    {
        skernelFatalError("regAddr_400GMac : non-valid unit[%d]",unitIndex);
        return;
    }

    portFormula = (MAC_STEP_PORT_OFFSET * (portIndex / 8));

    SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->sip6_high_speed[portNum].MTI400_MAC.commandConfig  = 0x00000008 + portFormula + unitOffset;
    SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->sip6_high_speed[portNum].MTI400_MAC.frmLength      = 0x00000014 + portFormula + unitOffset;
    SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->sip6_high_speed[portNum].MTI400_MAC.macAddr0       = 0x0000000C + portFormula + unitOffset;
    SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->sip6_high_speed[portNum].MTI400_MAC.macAddr1       = 0x00000010 + portFormula + unitOffset;
    SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->sip6_high_speed[portNum].MTI400_MAC.status         = 0x00000040 + portFormula + unitOffset;

    /*printf("MAC400G[%d]=0x%x\n", portNum, (SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->sip6_high_speed[portNum].MTI400_MAC.commandConfig));*/

}

/**
* @internal regAddr_400G_MTIP_EXT function
* @endinternal
*
* @brief   initialize the register DB - 400G MAC - MTIP_EXT
*
* @param[in] devObjPtr - pointer to device object.
*            portNum   - global port number
*            sip6_MTI_EXTERNAL_representativePortIndex - port represent global registers addresses per all ports in unit
*            portIndex - local port in the unit
*            unitIndex - the unit index 0..3
*
*/
static void regAddr_400G_MTIP_EXT
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN GT_U32 portNum,
    IN GT_U32 sip6_MTI_EXTERNAL_representativePortIndex,
    IN GT_U32 portIndex,
    IN GT_U32 unitIndex
)
{
    GT_U32  portFormula;
    GT_U32  unitOffset = devObjPtr->memUnitBaseAddrInfo.macWrap[unitIndex] + MAC_EXT_BASE_OFFSET;

    if(devObjPtr->memUnitBaseAddrInfo.macWrap[unitIndex] == 0)
    {
        skernelFatalError("regAddr_400G_MTIP_EXT : non-valid unit[%d]",unitIndex);
        return;
    }

    if(portIndex == 0)
    {
        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->sip6_MTI_EXTERNAL[sip6_MTI_EXTERNAL_representativePortIndex].MTI_GLOBAL.globalClockEnable           = 0x00000000 + unitOffset;
        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->sip6_MTI_EXTERNAL[sip6_MTI_EXTERNAL_representativePortIndex].MTI_GLOBAL.globalInterruptSummaryCause = 0x00000010 + unitOffset;
        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->sip6_MTI_EXTERNAL[sip6_MTI_EXTERNAL_representativePortIndex].MTI_GLOBAL.globalInterruptSummaryMask  = 0x00000014 + unitOffset;
    }


    /* Set formula per 50/100 ports*/
    portFormula = (0x100 * portIndex);
    /* start of unit MTI_EXT - per channel/port*/
    SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->sip6_MTI[portNum].MTI_EXT_PORT.portControl         = 0x00000100 + portFormula + unitOffset;
    SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->sip6_MTI[portNum].MTI_EXT_PORT.portStatus          = 0x00000104 + portFormula + unitOffset;
    SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->sip6_MTI[portNum].MTI_EXT_PORT.portInterruptCause  = 0x00000138 + portFormula + unitOffset;
    SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->sip6_MTI[portNum].MTI_EXT_PORT.portInterruptMask   = 0x0000013c + portFormula + unitOffset;
    SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->sip6_MTI[portNum].MTI_EXT_PORT.portPeerDelay       = 0x00000114 + portFormula + unitOffset;

    /*printf("MAC_PORT[%d]=0x%x\n", portNum, (SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->sip6_MTI[portNum].MTI_EXT_PORT.portControl));*/


    if ((portIndex % 8) == 0)
    {
        /* Set formula per 200/400 ports*/
        portFormula = 0x800;
        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->sip6_MTI[portNum].MTI_EXT_PORT.segPortStatus         = 0x00000104 + portFormula + unitOffset;
        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->sip6_MTI[portNum].MTI_EXT_PORT.segPortInterruptCause = 0x00000138 + portFormula + unitOffset;
        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->sip6_MTI[portNum].MTI_EXT_PORT.segPortInterruptMask  = 0x0000013c + portFormula + unitOffset;
        /*printf("MAC_PORT[%d]=0x%x\n", portNum, (SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->sip6_MTI[portNum].MTI_EXT_PORT.segPortStatus));*/

        regAddr_400GMac(devObjPtr, portNum, portIndex, unitIndex);
    }
}

/**
* @internal regAddr_MTIP400GMacWrap function
* @endinternal
*
* @brief   initialize the register DB - MTIP 400G MAC
*
* @param[in] devObjPtr - pointer to device object.
*            portNum   - global port number
*            portIndex - local port in the unit
*            unitIndex - the unit index 0..3
*
*/
static void regAddr_MTIP400GMacWrap
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN GT_U32 portNum,
    IN GT_U32 sip6_MTI_EXTERNAL_representativePortIndex,
    IN GT_U32 portIndex,
    IN GT_U32 unitIndex
)
{
    GT_U32  indexTo_macWrap = unitIndex;

    regAddr_400G_MTIP_EXT(devObjPtr,portNum,sip6_MTI_EXTERNAL_representativePortIndex,portIndex,indexTo_macWrap);
    regAddr_100GMac      (devObjPtr,portNum,portIndex,indexTo_macWrap);
    smemChtGopMtiInitMacMibCounters(devObjPtr,portNum ,portIndex , sip6_MTI_EXTERNAL_representativePortIndex/*channelIndex*/ , 0/*dieIndex*/ , 0 /*globalRaven*/ , 0/*isCpuPort*/);
}

/**
* @internal regAddr_MTIP400GPcs function
* @endinternal
*
* @brief   initialize the register DB - MTIP 400G PCS
*
* @param[in] devObjPtr - pointer to device object.
*            portNum   - global port number
*            portIndex - local port in the unit
*            unitIndex - the unit index 0..3
*
*/
static void regAddr_MTIP400GPcs
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN GT_U32 portNum,
    IN GT_U32 sip6_MTI_EXTERNAL_representativePortIndex,
    IN GT_U32 portIndex,
    IN GT_U32 unitIndex
)
{
    GT_U32  portFormula;
    GT_U32  isPort_200_400;
    GT_U32  indexTo_macPcs = unitIndex;
    GT_U32  unitOffset = devObjPtr->memUnitBaseAddrInfo.macPcs[indexTo_macPcs];
    GT_U32  lpcsUnitOffset = devObjPtr->memUnitBaseAddrInfo.macPcs[indexTo_macPcs];

    if(devObjPtr->memUnitBaseAddrInfo.macPcs[indexTo_macPcs] == 0)
    {
        skernelFatalError("regAddr_MTIP400GPcs : non-valid unit[%d]",unitIndex);
        return;
    }

    if ((portIndex % 4) == 0)
    {
        isPort_200_400 = 1;
    }
    else
    {
        isPort_200_400 = 0;
    }

    portFormula = PCS_EXT_OFFSET + (0x18 * portIndex);
    SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->sip6_MTI[portNum].MTI_PCS_EXT_PORT.portControl = 0x00000094 + portFormula + unitOffset;
    SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->sip6_MTI[portNum].MTI_PCS_EXT_PORT.portStatus  = 0x00000098 + portFormula + unitOffset;
    SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->sip6_MTI[portNum].MTI_PCS_EXT_PORT.portInterruptCause = 0x0000008c + portFormula + unitOffset;
    SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->sip6_MTI[portNum].MTI_PCS_EXT_PORT.portInterruptMask  = 0x00000090 + portFormula + unitOffset;
    /*SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->sip6_MTI[portNum].MTI_PCS_EXT_PORT.portSummaryInterruptCause = 0x00000074 + unitOffset;
    SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->sip6_MTI[portNum].MTI_PCS_EXT_PORT.portSummaryInterruptMask  = 0x00000078 + unitOffset;*/

    /* Set formula per 50/100 ports : portIndex = 0..7 */
    portFormula = PCS_PORT0_100G_OFFSET + (PCS_STEP_PORT_OFFSET * portIndex);
    if (portIndex % 2)
    {
        /* Set formula per odd ports */
        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->sip6_MTI[portNum].MTI_WRAPPER.PCS_10254050.control1 = 0x00000000 + portFormula + unitOffset;
        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->sip6_MTI[portNum].MTI_WRAPPER.PCS_10254050.status1  = 0x00000004 + portFormula + unitOffset;
        /*printf("PCS50[%d]=0x%x\n", portNum, (SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->sip6_MTI[portNum].MTI_WRAPPER.PCS_10254050.control1));*/
    }
    else
    {
        /* Set formula per even ports */
        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->sip6_MTI[portNum].MTI_WRAPPER.PCS_10TO100.control1 = 0x00000000 + portFormula + unitOffset;
        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->sip6_MTI[portNum].MTI_WRAPPER.PCS_10TO100.status1  = 0x00000004 + portFormula + unitOffset;
        /*printf("PCS100[%d]=0x%x\n", portNum, (SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->sip6_MTI[portNum].MTI_WRAPPER.PCS_10TO100.control1));*/
    }

    portFormula = PCS_LPCS_OFFSET + (LPCS_STEP_PORT_OFFSET * (portIndex%8));

    lpcsUnitOffset += (0x1000 * (portIndex/8));

    SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->sip6_MTI[portNum].MTI_WRAPPER.PCS_LPCS.control1 = 0x00000000 + portFormula + lpcsUnitOffset;
    SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->sip6_MTI[portNum].MTI_WRAPPER.PCS_LPCS.status1  = 0x00000004 + portFormula + lpcsUnitOffset;
    SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->sip6_MTI[portNum].MTI_WRAPPER.PCS_LPCS.usxgmii_rep = 0x00000058 + portFormula + lpcsUnitOffset;
    /*printf("LPCS[%d]=0x%x\n", portNum, (SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->sip6_MTI[portNum].MTI_WRAPPER.PCS_LPCS.control1));*/


    if(isPort_200_400)/* portIndex = 0,4 */
    {
        portFormula = ((portIndex % 8) == 0) ? PCS_400G_OFFSET : PCS_200G_OFFSET;
        portFormula += (PCS400_STEP_PORT_OFFSET * (portIndex/8));
        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->sip6_high_speed[portNum].PCS_400G_200G.control1 = 0x00000000 + portFormula + unitOffset;
        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->sip6_high_speed[portNum].PCS_400G_200G.status1  = 0x00000004 + portFormula + unitOffset;
        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->sip6_MTI_EXTERNAL[sip6_MTI_EXTERNAL_representativePortIndex].MTI_GLOBAL.globalChannelControl = 0x0000000c + unitOffset;
        /*printf("PCS_EXT[%d]=0x%x, sip6_MTI_EXTERNAL_representativePortIndex=%d \n", portNum, (SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->sip6_MTI_EXTERNAL[sip6_MTI_EXTERNAL_representativePortIndex].MTI_GLOBAL.globalChannelControl), sip6_MTI_EXTERNAL_representativePortIndex);*/
    }

    if(portIndex%8 == 0)
    {
        GT_U32 LPCS_representativePortIndex = sip6_MTI_EXTERNAL_representativePortIndex*2;

        /*  For AAS PCS GOP cluster it is not enough single 'sip6_MTI_EXTERNAL_representativePortIndex' to describe LPCS common
           registers because we have two 'common' GMODE registers for signle representative index.
            THEREFORE EVERY ACCESS TO GMODE REGISTER SHOULD "EXTEND" INDEX
            For example
                0 for ports 0..7
                1 for ports 8..15
        */

        if(portIndex/8 > 0)
        {
            LPCS_representativePortIndex++;
        }
        unitOffset += (0x1000 * (portIndex/8));

        /* info of PCS that is per representative port */
        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->sip6_MTI_EXTERNAL[LPCS_representativePortIndex].PCS_common.LPCS_common.gmode = 0x000003e0 + PCS_LPCS_OFFSET + unitOffset;

        /*printf("LPCS[%d/%d]=0x%x\n", portNum, LPCS_representativePortIndex, (SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->sip6_MTI_EXTERNAL[LPCS_representativePortIndex].PCS_common.LPCS_common.gmode));*/
    }

}

/**
* @internal regAddr_MTIPCpuMacWrap function
* @endinternal
*
* @brief   initialize the register DB - for CPU port of MTI MAC unit
*
* @param[in] devObjPtr - pointer to device object.
*            portNum   - port number
*
*/
static void regAddr_MTIPCpuMacWrap
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN GT_U32 portNum
)
{
    GT_U32  portFormula;
    GT_U32 sip6_MTI_EXTERNAL_representativePortIndex = 0;
    GT_U32 unitIndex = 0;
    GT_U32  unitFormula = devObjPtr->memUnitBaseAddrInfo.cpuMacWrap[unitIndex];

    if(devObjPtr->memUnitBaseAddrInfo.cpuMacWrap[unitIndex] == 0)
    {
        skernelFatalError("regAddr_MTIPCpuMacWrap : non-valid unit[%d]",unitIndex);
        return;
    }

    portFormula = unitFormula + CPU_MAC_EXT_BASE_OFFSET;

    /* MTIP IP CPU MAC WRAPPER {Current}/<MTIP CPU EXT> MTIP CPU EXT/MTIP CPU EXT Units */
    SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->sip6_MTI_cpu_port[sip6_MTI_EXTERNAL_representativePortIndex].MTI_EXT_PORT.portStatus          = 0x00000008  + portFormula;
    SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->sip6_MTI_cpu_port[sip6_MTI_EXTERNAL_representativePortIndex].MTI_EXT_PORT.portInterruptCause  = 0x0000000C + portFormula;
    SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->sip6_MTI_cpu_port[sip6_MTI_EXTERNAL_representativePortIndex].MTI_EXT_PORT.portInterruptMask   = 0x00000010 + portFormula;
    SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->sip6_MTI_cpu_port[sip6_MTI_EXTERNAL_representativePortIndex].MTI_EXT_PORT.portPeerDelay       = 0x00000030 + portFormula;

    SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->sip6_MTI_cpu_port[sip6_MTI_EXTERNAL_representativePortIndex].MTI_GLOBAL.control               = 0x00000000 + portFormula;
    SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->sip6_MTI_cpu_port[sip6_MTI_EXTERNAL_representativePortIndex].MTI_GLOBAL.globalResetControl    = 0x00000014 + portFormula;

#if 0 /* initialized in smemChtGopMtiInitMacMibCounters */
    portFormula = unitFormula + CPU_MAC_MIB_OFFSET;

    SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->sip6_MTI_cpu_port[unitIndex].cpu_MTI_STATS.config   = 0x00000008 + portFormula;
    SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->sip6_MTI_cpu_port[unitIndex].cpu_MTI_STATS.control  = 0x0000000C + portFormula;
    SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->sip6_MTI_cpu_port[unitIndex].cpu_MTI_STATS.datHiCdc = 0x0000001C + portFormula;
    for (ii = 0; ii < 56; ii++)
    {
        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->sip6_MTI_cpu_port[unitIndex].cpu_MTI_STATS.counterCapture[ii] = 0x00000020 + 0x4 * ii + portFormula;
    }
#endif /*0*/
    portFormula = unitFormula + CPU_MAC_PORT_OFFSET;
    SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->sip6_MTI_cpu_port[unitIndex].MTI_cpuMac.commandConfig = 0x00000008 + portFormula;
    SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->sip6_MTI_cpu_port[unitIndex].MTI_cpuMac.frmLength     = 0x00000014 + portFormula;
    SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->sip6_MTI_cpu_port[unitIndex].MTI_cpuMac.macAddr0      = 0x0000000C + portFormula;
    SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->sip6_MTI_cpu_port[unitIndex].MTI_cpuMac.macAddr1      = 0x00000010 + portFormula;
    SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->sip6_MTI_cpu_port[unitIndex].MTI_cpuMac.status        = 0x00000040 + portFormula;

    /* do mib counters */
    /* channelIndex --> unitIndex --> devObjPtr->memUnitBaseAddrInfo.cpuMacMib[unitIndex] */
    smemChtGopMtiInitMacMibCounters(devObjPtr,portNum ,0/*portIndex*/ , unitIndex/*channelIndex*/ , 0/*dieIndex*/ , 0 /*globalRaven*/ , 1/*isCpuPort*/);
}

/**
* @internal regAddr_MTIPCpuPcs function
* @endinternal
*
* @brief   initialize the register DB - for CPU port of MTI PCS unit
*
* @param[in] devObjPtr - pointer to device object.
*
*/
static void regAddr_MTIPCpuPcs
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr
)
{
    GT_U32 unitIndex = 0;
    GT_U32  portFormula;
    GT_U32  unitFormula = devObjPtr->memUnitBaseAddrInfo.cpuMacPcs[unitIndex];

    if(devObjPtr->memUnitBaseAddrInfo.cpuMacPcs[unitIndex] == 0)
    {
        skernelFatalError("regAddr_MTIPCpuPcs : non-valid unit[%d]",unitIndex);
        return;
    }

    portFormula = unitFormula + CPU_PCS_PORT_OFFSET;
    SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->sip6_MTI_cpu_port[unitIndex].MTI_cpuPcs.control1      = 0x00000000 + portFormula;
    SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->sip6_MTI_cpu_port[unitIndex].MTI_cpuPcs.status1       = 0x00000004 + portFormula;
}
/**
* @internal regAddr_serdes function
* @endinternal
*
* @brief   initialize the register DB - for SDW unit
*
* @param[in] devObjPtr - pointer to device object.
*
*/
static void regAddr_serdes
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN GT_U32 unitIndex
)
{
    GT_U32  unitOffset;
    SMEM_CHT_PORT_SIP_6_10_SERDES_UNIT_REG_STC  *unitDbPtr;

    unitDbPtr = &SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->sip_6_10_SERDES[unitIndex].sip_6_10_SERDES;
    unitOffset = devObjPtr->memUnitBaseAddrInfo.sip_6_10_SERDES[unitIndex];

    unitDbPtr->SDWInterruptCause = unitOffset  + 0x700;
    unitDbPtr->SDWInterruptMask  = unitOffset  + 0x704;

    /*printf("SD[%d]=0x%x\n", unitIndex, (unitDbPtr->SDWInterruptCause));*/
}



/**
* @internal smemAasGopRegDbInit function
* @endinternal
*
* @brief   Init GOP regDB registers for Phoenix.
*
* @param[in] devObjPtr                - pointer to device object.
*/
static void smemAasGopRegDbInit(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr
)
{
    GT_U32  globalPort;
    ENHANCED_PORT_INFO_STC portInfo;

    devObjPtr->portMacOffset = MAC_STEP_PORT_OFFSET;
    devObjPtr->portMacMask   = 0x7F;

    {/* SDW support (SERDESes) */
        GT_U32  sdwId = 0;
        GT_U32  ii;

        devObjPtr->memUnitBaseAddrInfo.sip_6_10_SERDES[sdwId++] =SDW0_BASE_ADDR;
        devObjPtr->memUnitBaseAddrInfo.sip_6_10_SERDES[sdwId++] =SDW1_BASE_ADDR;
        devObjPtr->memUnitBaseAddrInfo.sip_6_10_SERDES[sdwId++] =SDW2_BASE_ADDR;
        devObjPtr->memUnitBaseAddrInfo.sip_6_10_SERDES[sdwId++] =SDW3_BASE_ADDR;
        devObjPtr->memUnitBaseAddrInfo.sip_6_10_SERDES[sdwId++] =SDW4_BASE_ADDR;
        devObjPtr->memUnitBaseAddrInfo.sip_6_10_SERDES[sdwId++] =SDW5_BASE_ADDR;
        devObjPtr->memUnitBaseAddrInfo.sip_6_10_SERDES[sdwId++] =SDW6_BASE_ADDR;
        devObjPtr->memUnitBaseAddrInfo.sip_6_10_SERDES[sdwId++] =SDW7_BASE_ADDR;
        devObjPtr->memUnitBaseAddrInfo.sip_6_10_SERDES[sdwId++] =SDW8_BASE_ADDR;
        devObjPtr->memUnitBaseAddrInfo.sip_6_10_SERDES[sdwId++] =SDW9_BASE_ADDR;
        devObjPtr->memUnitBaseAddrInfo.sip_6_10_SERDES[sdwId++] =SDW10_BASE_ADDR;
        devObjPtr->memUnitBaseAddrInfo.sip_6_10_SERDES[sdwId++] =SDW11_BASE_ADDR;
        devObjPtr->memUnitBaseAddrInfo.sip_6_10_SERDES[sdwId++] =SDW12_BASE_ADDR;
        devObjPtr->memUnitBaseAddrInfo.sip_6_10_SERDES[sdwId++] =SDW13_BASE_ADDR;
        devObjPtr->memUnitBaseAddrInfo.sip_6_10_SERDES[sdwId++] =SDW14_BASE_ADDR;
        devObjPtr->memUnitBaseAddrInfo.sip_6_10_SERDES[sdwId++] =SDW15_BASE_ADDR;
        devObjPtr->memUnitBaseAddrInfo.sip_6_10_SERDES[sdwId++] =SDW16_BASE_ADDR;
        devObjPtr->memUnitBaseAddrInfo.sip_6_10_SERDES[sdwId++] =SDW17_BASE_ADDR;
        devObjPtr->memUnitBaseAddrInfo.sip_6_10_SERDES[sdwId++] =SDW18_BASE_ADDR;
        devObjPtr->memUnitBaseAddrInfo.sip_6_10_SERDES[sdwId++] =SDW19_BASE_ADDR;
        devObjPtr->memUnitBaseAddrInfo.sip_6_10_SERDES[sdwId++] =SDW20_BASE_ADDR;

        devObjPtr->numOfSip6_10_SERDES_units = sdwId;

        if(devObjPtr->numOfTiles > 1)
        {
            GT_U32  ii;
            for(ii = 0 ; ii < sdwId ; ii++)
            {
                devObjPtr->memUnitBaseAddrInfo.sip_6_10_SERDES[ii+sdwId] =
                    devObjPtr->memUnitBaseAddrInfo.sip_6_10_SERDES[ii] +  devObjPtr->tileOffset;
            }

            devObjPtr->numOfSip6_10_SERDES_units = devObjPtr->numOfTiles*sdwId;
        }

        for(ii = 0 ; ii < devObjPtr->numOfSip6_10_SERDES_units; ii++)
        {
            regAddr_serdes(devObjPtr,ii);
        }
    }

    /* Flexe support */
    {
        GT_U32  ii = 0;
        GT_U32  flexeUnits = 0;

        devObjPtr->memUnitBaseAddrInfo.sip7Flexe[flexeUnits++] = FLEXE_XC_0_BASE_ADDR;
        devObjPtr->memUnitBaseAddrInfo.sip7Flexe[flexeUnits++] = FLEXE_XC_TAI_0_BASE_ADDR;
        devObjPtr->memUnitBaseAddrInfo.sip7Flexe[flexeUnits++] = FLEXE_XC_1_BASE_ADDR;
        devObjPtr->memUnitBaseAddrInfo.sip7Flexe[flexeUnits++] = FLEXE_XC_TAI_1_BASE_ADDR;
        devObjPtr->memUnitBaseAddrInfo.sip7Flexe[flexeUnits++] = FLEXE_CODERS_BASE_ADDR;
        devObjPtr->memUnitBaseAddrInfo.sip7Flexe[flexeUnits++] = FLEXE_SHIM_0_BASE_ADDR;
        devObjPtr->memUnitBaseAddrInfo.sip7Flexe[flexeUnits++] = FLEXE_SHIM_TAI_0_BASE_ADDR;
        devObjPtr->memUnitBaseAddrInfo.sip7Flexe[flexeUnits++] = FLEXE_SHIM_1_BASE_ADDR;
        devObjPtr->memUnitBaseAddrInfo.sip7Flexe[flexeUnits++] = FLEXE_SHIM_TAI_1_BASE_ADDR;

        if (devObjPtr->numOfTiles > 1)
        {
            for (ii=0; ii<flexeUnits; ii++)
            {
                devObjPtr->memUnitBaseAddrInfo.sip7Flexe[ii+flexeUnits] =
                    devObjPtr->memUnitBaseAddrInfo.sip7Flexe[ii] + devObjPtr->tileOffset;
            }
        }
    }

    /* ANP support */
    {
        GT_U32  numOfAnps = 0;
        GT_U32  anp;

        devObjPtr->memUnitBaseAddrInfo.anp[numOfAnps++] =  ANP_0_BASE_ADDR;
        devObjPtr->memUnitBaseAddrInfo.anp[numOfAnps++] =  ANP_1_BASE_ADDR;
        devObjPtr->memUnitBaseAddrInfo.anp[numOfAnps++] =  ANP_2_BASE_ADDR;
        devObjPtr->memUnitBaseAddrInfo.anp[numOfAnps++] =  ANP_3_BASE_ADDR;
        devObjPtr->memUnitBaseAddrInfo.anp[numOfAnps++] =  ANP_4_BASE_ADDR;
        devObjPtr->memUnitBaseAddrInfo.anp[numOfAnps++] =  ANP_5_BASE_ADDR;
        devObjPtr->memUnitBaseAddrInfo.anp[numOfAnps++] =  ANP_6_BASE_ADDR;
        devObjPtr->memUnitBaseAddrInfo.anp[numOfAnps++] =  ANP_7_BASE_ADDR;
        devObjPtr->memUnitBaseAddrInfo.anp[numOfAnps++] =  ANP_8_BASE_ADDR;
        devObjPtr->memUnitBaseAddrInfo.anp[numOfAnps++] =  ANP_9_BASE_ADDR;
        devObjPtr->memUnitBaseAddrInfo.anp[numOfAnps++] =  ANP_10_BASE_ADDR;
        devObjPtr->memUnitBaseAddrInfo.anp[numOfAnps++] =  ANP_11_BASE_ADDR;
        devObjPtr->memUnitBaseAddrInfo.anp[numOfAnps++] =  ANP_12_BASE_ADDR;
        devObjPtr->memUnitBaseAddrInfo.anp[numOfAnps++] =  ANP_13_BASE_ADDR;
        devObjPtr->memUnitBaseAddrInfo.anp[numOfAnps++] =  ANP_14_BASE_ADDR;
        devObjPtr->memUnitBaseAddrInfo.anp[numOfAnps++] =  ANP_15_BASE_ADDR;
        devObjPtr->memUnitBaseAddrInfo.anp[numOfAnps++] =  ANP_16_BASE_ADDR;
        devObjPtr->memUnitBaseAddrInfo.anp[numOfAnps++] =  ANP_17_BASE_ADDR;
        devObjPtr->memUnitBaseAddrInfo.anp[numOfAnps++] =  ANP_18_BASE_ADDR;
        devObjPtr->memUnitBaseAddrInfo.anp[numOfAnps++] =  ANP_19_BASE_ADDR;
        devObjPtr->memUnitBaseAddrInfo.anp[numOfAnps++] =  ANP_20_BASE_ADDR;
        devObjPtr->memUnitBaseAddrInfo.anp[numOfAnps++] =  ANP_21_BASE_ADDR;
        devObjPtr->memUnitBaseAddrInfo.anp[numOfAnps++] =  ANP_22_BASE_ADDR;
        devObjPtr->memUnitBaseAddrInfo.anp[numOfAnps++] =  ANP_23_BASE_ADDR;

        devObjPtr->memUnitBaseAddrInfo.anp[numOfAnps++] =  ANP_CPU_BASE_ADDR;


        for(anp = 0 ; anp < numOfAnps ; anp++)
        {
            regAddr_anp(devObjPtr, anp);
        }
    }

    /* MIF support */
    {
        /* MIF support */
        devObjPtr->memUnitBaseAddrInfo.mif[0]  =  MIF_0_BASE_ADDR;
        devObjPtr->memUnitBaseAddrInfo.mif[1]  =  MIF_1_BASE_ADDR;
        devObjPtr->memUnitBaseAddrInfo.mif[2]  =  MIF_2_BASE_ADDR;
        devObjPtr->memUnitBaseAddrInfo.mif[3]  =  MIF_3_BASE_ADDR;
        devObjPtr->memUnitBaseAddrInfo.mif[4]  =  MIF_4_BASE_ADDR;
        devObjPtr->memUnitBaseAddrInfo.mif[5]  =  MIF_5_BASE_ADDR;
        devObjPtr->memUnitBaseAddrInfo.mif[6]  =  MIF_6_BASE_ADDR;
        devObjPtr->memUnitBaseAddrInfo.mif[7]  =  MIF_7_BASE_ADDR;
        devObjPtr->memUnitBaseAddrInfo.mif[8]  =  MIF_8_BASE_ADDR;
        devObjPtr->memUnitBaseAddrInfo.mif[9]  =  MIF_9_BASE_ADDR;
        devObjPtr->memUnitBaseAddrInfo.mif[10] =  MIF_10_BASE_ADDR;
        devObjPtr->memUnitBaseAddrInfo.mif[11] =  MIF_11_BASE_ADDR;
        devObjPtr->memUnitBaseAddrInfo.mif[12] =  MIF_12_BASE_ADDR;
        devObjPtr->memUnitBaseAddrInfo.mif[13] =  MIF_13_BASE_ADDR;
        devObjPtr->memUnitBaseAddrInfo.mif[14] =  MIF_14_BASE_ADDR;
        devObjPtr->memUnitBaseAddrInfo.mif[15] =  MIF_15_BASE_ADDR;
        devObjPtr->memUnitBaseAddrInfo.mif[16] =  MIF_16_BASE_ADDR;

        devObjPtr->numOfMifs = mifUnitsPerTile * devObjPtr->numOfTiles;

        /* second tile */
        if (devObjPtr->numOfTiles > 1)
        {
            GT_U32  ii;
            for(ii = 0; (ii < mifUnitsPerTile); ii++)
            {
                devObjPtr->memUnitBaseAddrInfo.mif[ii+mifUnitsPerTile] =
                    devObjPtr->memUnitBaseAddrInfo.mif[ii] +  devObjPtr->tileOffset;
            }
        }

        for(globalPort = 0 ; globalPort < devObjPtr->portsNumber ; globalPort++)
        {
            if(GT_OK != smemAasPortInfoGet(devObjPtr,SMEM_UNIT_TYPE_EPI_MIF_CHANNEL_E,globalPort,&portInfo))
            {
                continue;
            }

            regAddr_mif(devObjPtr,
                globalPort,/* global port in the device */
                portInfo.sip6_MTI_EXTERNAL_representativePortIndex,/* representative global port in the device (for 'shared' registers) */
                portInfo.simplePortInfo.indexInUnit, /* local  port in the unit */
                portInfo.simplePortInfo.unitIndex);  /* the unit index 0..6 */
        }
    }

    /* LMU support */
    {
        /* 0x00C00000 + GOP*0x1000000 + Instance*0x20000: where GOP(0-3), Inst(0-7) */
        GT_U32  gop, inst, ii, unitIndex;
        GT_U32  numOfLmus = 0;

        unitIndex = 0;
        for(gop = 0 ; gop < 4; gop++)
        {
            for(inst = 0 ; inst < 8; inst++)
            {
                devObjPtr->memUnitBaseAddrInfo.lmu[unitIndex] =
                    AAS_ADDR_GOP0_LMU_0 + gop * 0x1000000 + inst * 0x20000;
                unitIndex++;
            }
        }
        numOfLmus = unitIndex * devObjPtr->numOfTiles;

        /* if(numOfTiles > 1) continue from unitIndex */
        ii = 0;
        for(; unitIndex < numOfLmus; unitIndex++, ii++)
        {
            devObjPtr->memUnitBaseAddrInfo.lmu[unitIndex] =
                devObjPtr->memUnitBaseAddrInfo.lmu[ii] + devObjPtr->tileOffset;
        }

        devObjPtr->numOfLmus = numOfLmus;
        devObjPtr->tablesInfo.lmuStatTable.commonInfo.multiInstanceInfo.numBaseAddresses = numOfLmus;
        devObjPtr->tablesInfo.lmuStatTable.commonInfo.multiInstanceInfo.multiUnitsBaseAddressPtr = &devObjPtr->memUnitBaseAddrInfo.lmu[0];
        devObjPtr->tablesInfo.lmuCfgTable.commonInfo.multiInstanceInfo.numBaseAddresses = numOfLmus;
        devObjPtr->tablesInfo.lmuCfgTable.commonInfo.multiInstanceInfo.multiUnitsBaseAddressPtr = &devObjPtr->memUnitBaseAddrInfo.lmu[0];

        for(unitIndex = 0 ; unitIndex < numOfLmus ; unitIndex++)
        {
            regAddr_lmu(devObjPtr, unitIndex);
        }
    }


    /* TSU/PTP support */
    {
        devObjPtr->memUnitBaseAddrInfo.tsu[0] = TSU_0_BASE_ADDR;
        devObjPtr->memUnitBaseAddrInfo.tsu[1] = TSU_1_BASE_ADDR;
        devObjPtr->memUnitBaseAddrInfo.tsu[2] = TSU_2_BASE_ADDR;
        devObjPtr->memUnitBaseAddrInfo.tsu[3] = TSU_3_BASE_ADDR;

        if(devObjPtr->numOfTiles > 1)
        {
            GT_U32  ii;
            for(ii = 0 ; ii < devObjPtr->multiDataPath.maxDp ; ii++)
            {
                devObjPtr->memUnitBaseAddrInfo.tsu[ii+devObjPtr->multiDataPath.maxDp] =
                    devObjPtr->memUnitBaseAddrInfo.tsu[ii] +  devObjPtr->tileOffset;
            }
        }

        for(globalPort = 0 ; globalPort < devObjPtr->portsNumber ; globalPort++)
        {
            if(GT_OK != smemAasPortInfoGet(devObjPtr,SMEM_UNIT_TYPE_PCA_TSU_CHANNEL_E,globalPort,&portInfo))
            {
                continue;
            }

            regAddr_tsu(devObjPtr,
                globalPort,/* global port in the device */
                portInfo.simplePortInfo.indexInUnit, /* local  port in the unit */
                portInfo.simplePortInfo.unitIndex);/* the unit index 0..3 */
        }
    }

    {
        /* support for the 400G MAC */
        SET_GOP_MAC_UNITS(0,0,0);/* 8 mac ports */
        SET_GOP_MAC_UNITS(1,0,1);/* 8 mac ports */
        SET_GOP_PCS_UNITS( 0);/* 16 pcs ports */

        SET_GOP_MAC_UNITS(2,1,0);/* 8 mac ports */
        SET_GOP_MAC_UNITS(3,1,1);/* 8 mac ports */
        SET_GOP_PCS_UNITS( 1);/* 16 pcs ports */

        SET_GOP_MAC_UNITS(4,2,0);/* 8 mac ports */
        SET_GOP_MAC_UNITS(5,2,1);/* 8 mac ports */
        SET_GOP_PCS_UNITS( 2);/* 16 pcs ports */

        SET_GOP_MAC_UNITS(6,3,0);/* 8 mac ports */
        SET_GOP_MAC_UNITS(7,3,1);/* 8 mac ports */
        SET_GOP_PCS_UNITS( 3);/* 16 pcs ports */

        if(devObjPtr->numOfTiles > 1)
        {
            GT_U32  ii;
            for(ii = 0 ; ii < NUM_MAC_UNITS ; ii++)
            {
                devObjPtr->memUnitBaseAddrInfo.macMib[ii+NUM_MAC_UNITS] =
                    devObjPtr->memUnitBaseAddrInfo.macMib[ii] +  devObjPtr->tileOffset;
                devObjPtr->memUnitBaseAddrInfo.macWrap[ii+NUM_MAC_UNITS] =
                    devObjPtr->memUnitBaseAddrInfo.macWrap[ii] +  devObjPtr->tileOffset;
                devObjPtr->memUnitBaseAddrInfo.macPcs[ii+NUM_MAC_UNITS] =
                    devObjPtr->memUnitBaseAddrInfo.macPcs[ii] +  devObjPtr->tileOffset;
            }
        }

        {
            /* NOTE : the device hold actually single GOP port !!! that is connected to DP[0] in PIPE2 and connected to DP[1] in Aldrin3/Cygnus3 */
            devObjPtr->memUnitBaseAddrInfo.cpuMacMib [0] = CPU_MAC_MTIP_MAC_BASE_ADDR + CPU_MAC_MIB_OFFSET;
            devObjPtr->memUnitBaseAddrInfo.cpuMacWrap[0] = CPU_MAC_MTIP_MAC_BASE_ADDR;
            devObjPtr->memUnitBaseAddrInfo.cpuMacPcs [0] = CPU_MAC_MTIP_MAC_PCS_BASE_ADDR;
        }

        for(globalPort = 0 ; globalPort < devObjPtr->portsNumber ; globalPort++)
        {
            if(GT_OK == smemAasPortInfoGet(devObjPtr,SMEM_UNIT_TYPE_MTI_MAC_50G_E,globalPort,&portInfo))
            {
#if 0
                GT_U32  localPortInDp = (globalPort % 20);
                if(localPortInDp < 4 ||
                   (localPortInDp >= 8 && localPortInDp < 12))/* 8 ports per DP */
                {
                    devObjPtr->portsArr[globalPort].portSupportPreemption = GT_TRUE;
                }
#endif

                /* kalex: TEMP CODE - should be removed later */
                if((globalPort % 20) > 15)
                {
                    continue;
                }

                smemAasPortInfoGet(devObjPtr,SMEM_UNIT_TYPE_MTI_MAC_50G_E,globalPort,&portInfo);

                regAddr_MTIP400GMacWrap(devObjPtr,
                    globalPort,/* global port in the device */
                    portInfo.sip6_MTI_EXTERNAL_representativePortIndex,/* representative global port in the device (for 'shared' registers) */
                    portInfo.simplePortInfo.indexInUnit, /* local  port in the unit */
                    portInfo.simplePortInfo.unitIndex);/* the unit index 0..3 */

                smemAasPortInfoGet(devObjPtr,SMEM_UNIT_TYPE_MTI_PCS_50G_E,globalPort,&portInfo);

                regAddr_MTIP400GPcs(devObjPtr,
                    globalPort,/* global port in the device */
                    portInfo.sip6_MTI_EXTERNAL_representativePortIndex,/* representative global port in the device (for 'shared' registers) */
                    portInfo.simplePortInfo.indexInUnit, /* local  port in the unit */
                    portInfo.simplePortInfo.unitIndex);/* the unit index 0..3 */
            }
            else
            if(GT_OK == smemAasPortInfoGet(devObjPtr,SMEM_UNIT_TYPE_MTI_MAC_CPU_E,globalPort,&portInfo))
            {
                /* CPU MAC,PCS support */
                regAddr_MTIPCpuMacWrap(devObjPtr,globalPort);
                regAddr_MTIPCpuPcs(devObjPtr);
            }

        }
    }
}

/*************cnm addr decoder registers*************/
#define CNM_ADDR_DECODE_WINDOW_ATTRIBUTES_AND_SIZE_HIGH   0x100  /*+ i*0x18: where i (0-15) represents Window number*/
#define CNM_ADDR_DECODE_WINDOW_SIZE_LOW                   0x104  /*+ i*0x18: where i (0-15) represents Window number*/
#define CNM_ADDR_DECODE_WINDOW_BASE_AND_REMAP_HIGH        0x108  /*+ i*0x18: where i (0-15) represents Window number*/
#define CNM_ADDR_DECODE_WINDOW_BASE_LOW                   0x10C  /*+ i*0x18: where i (0-15) represents Window number*/
#define CNM_ADDR_DECODE_WINDOW_REMAP_LOW                  0x110  /*+ i*0x18: where i (0-15) represents Window number*/
#define CNM_ADDR_DECODE_AXI_ATTRIBUTES                    0x114  /*+ i*0x18: where i (0-15) represents Window number*/

#define CNM_ADDR_DECODE_REG_GET(addr,value) \
    smemRegGet(devObjPtr, baseAddrUnit_ADDR_DECODER + (addr) + ((win)*0x18) , &value )

/*******************************************************************************
*   smemAasSdmaCnMConvert
*
* DESCRIPTION:
*       function to do 'address convert' from address of 64bits that the registers of DMA
*       hold to be converted to 'pex addresses' , using the CnM 'address decoding' unit windows.
*
* INPUTS:
*       devObjPtr    - pointer to device object.
*       baseAddrUnit_ADDR_DECODER - base address of the address decoder
*       origPexAddr_lowAddr_Ptr   - (pointer to) the lower  32 bits dma address before the convert
*       origPexAddr_highAddr_Ptr  - (pointer to) the higher 32 bits dma address before the convert
*
* OUTPUTS:
*       newPexAddr_lowAddr_Ptr   - (pointer to) the lower  32 bits dma address after the convert
*       newPexAddr_highAddr_Ptr  - (pointer to) the higher 32 bits dma address after the convert
* RETURNS:
*        None
*
* COMMENTS:
*
*
*******************************************************************************/
static void smemAasSdmaCnMConvert(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN GT_U32                  baseAddrUnit_ADDR_DECODER,
    IN GT_U32                  dma_lowAddr,
    IN GT_U32                  dma_highAddr,
    OUT GT_U32                 *newPexAddr_lowAddr_Ptr,
    OUT GT_U32                 *newPexAddr_highAddr_Ptr
)
{
    GT_U32  win;
    GT_U32  window_attributes_and_size_high,window_base_and_remap_high,window_base_low;
    GT_U32  window_size_low,window_remap_low;
    GT_U32  mgAddr16_47; /*bits 16..47 DMA address before the remap */
    GT_U32  mgAddr48_63; /*bits 48..63 MDA address before the remap */
    GT_U32  remapHighValue,highBaseValue;
    GT_U32  new_addr16_47; /*new DMA address bits 16..47 after the remap */
    GT_U32  new_addr48_63; /*new DMA address bits 48..63 after the remap */

                      /*bits 32:47 */           /*bits 16..31*/
    mgAddr16_47 = (dma_highAddr << 16) | (dma_lowAddr >> 16);
    mgAddr48_63 =  dma_highAddr >> 16;

    /* find the window with the lowest window that match the IN address */
    for(win = 0 ; win < CNM_ADDR_DECODE_WINDOWS_NUM ; win++)
    {
        CNM_ADDR_DECODE_REG_GET(CNM_ADDR_DECODE_WINDOW_ATTRIBUTES_AND_SIZE_HIGH,window_attributes_and_size_high);

        if(0 == (window_attributes_and_size_high & 0x1))
        {
            /* the window is not enabled */
            continue;
        }

        CNM_ADDR_DECODE_REG_GET(CNM_ADDR_DECODE_WINDOW_BASE_AND_REMAP_HIGH,window_base_and_remap_high);
        /*high_base : bits 48:63*/
        highBaseValue = (window_base_and_remap_high & 0xFFFF);

        if(mgAddr48_63 < highBaseValue)
        {
            /* below high prefix */
            continue;
        }

                           /*high_base : bits 48:63*/
        if(mgAddr48_63 > highBaseValue +
                         (window_attributes_and_size_high >> 16)/*high_size*/)
        {
            /* above high prefix + high size */
            continue;
        }

        CNM_ADDR_DECODE_REG_GET(CNM_ADDR_DECODE_WINDOW_BASE_LOW,window_base_low);

        if(mgAddr48_63 == (window_base_and_remap_high & 0xFFFF))
        {
            if(mgAddr16_47 < window_base_low)
            {
                /* below low prefix */
                continue;
            }

            CNM_ADDR_DECODE_REG_GET(CNM_ADDR_DECODE_WINDOW_SIZE_LOW,window_size_low);

            if(mgAddr16_47 > (window_base_low + window_size_low))
            {
                /* below high prefix + high size */
                continue;
            }
        }


        /* found proper 'window' that matched the MG address */

        CNM_ADDR_DECODE_REG_GET(CNM_ADDR_DECODE_WINDOW_REMAP_LOW,window_remap_low);

        remapHighValue = window_base_and_remap_high >> 16;

        new_addr16_47 = (mgAddr16_47 - window_base_low) + window_remap_low;
        new_addr48_63 = (mgAddr48_63 - highBaseValue)   + remapHighValue;

        /* we have a match in the window */
        *newPexAddr_lowAddr_Ptr  = (dma_lowAddr & 0xFFFF)/* bits 0..15*/ |
                                   (new_addr16_47 << 16);/*bits16..31*/
        *newPexAddr_highAddr_Ptr = (new_addr16_47 >> 16)/* bits 32..47*/ |
                                    new_addr48_63 << 16;/* bits 48..63*/


        __LOG_NO_LOCATION_META_DATA__WITH_SCIB_LOCK(("oAtu convert : dma_highAddr[0x%8.8x] dma_lowAddr[0x%8.8x] to cnm_addr_high[0x%8.8x],cnm_addr_low[0x%8.8x] (window[%d])\n",
            dma_highAddr,
            dma_lowAddr,
            *newPexAddr_highAddr_Ptr,
            *newPexAddr_lowAddr_Ptr,
            win));
        return;
    }

    *newPexAddr_lowAddr_Ptr  = SMAIN_NOT_VALID_CNS;
    *newPexAddr_highAddr_Ptr = SMAIN_NOT_VALID_CNS;

    __LOG_NO_LOCATION_META_DATA__WITH_SCIB_LOCK(("ADDR_DECODER ERROR : not matched : dma_highAddr[0x%8.8x] dma_lowAddr[0x%8.8x] in any window \n",
        dma_highAddr,
        dma_lowAddr));

    return;
}

/*************oATU registers*************/
#define oATU_REGION_CTRL_1_REG         0x0
#define oATU_REGION_CTRL_2_REG         0x4
#define oATU_LOWER_BASE_ADDRESS_REG    0x8
#define oATU_UPPER_BASE_ADDRESS_REG    0xC
#define oATU_LIMIT_ADDRESS_REG         0x10
#define oATU_LOWER_TARGET_ADDRESS_REG  0x14
#define oATU_UPPER_TARGET_ADDRESS_REG  0x18

#define oATU_REGISTER_ADDRESS(_iWindow, _register)  \
    (ATU_REGISTERS_OFFSET_IN_BAR0 + (_iWindow)*0x200 + (_register))
/*************end of oATU registers*************/

#define OATU_REG_GET(addr,value) value = *(devMemInfoPtr->common.oAtuWindowsMemPtr[win]+((addr-oATU_REGION_CTRL_1_REG)/4))
/*******************************************************************************
*   smemAasDmaCnMoAtuConvert
*
* DESCRIPTION:
*       function to do 'address completion' from address of 32bits that the registers of DMA
*       hold to be converted to 'pex addresses' , for that using the MG windows and the oATU in the CnM
*
* INPUTS:
*       devObjPtr    - pointer to device object.
*       client       - the client that ask to access the DMA (like: SDMA/CM3)
*       subClientId  - the GDMA unit id or CM7 unit id (relative to the CnM --> not 'global to the device' in multi-tiles)
*       dma_addr_lowAddr_Ptr   - (pointer to) the ORIGINAL lower  32 bits of address that came for the GDMA unit
*       dma_Addr_highAddr_Ptr  - (pointer to) the ORIGINAL higher 32 bits of address that came for the GDMA unit
* OUTPUTS:
*       dma_addr_lowAddr_Ptr   - (pointer to) the lower  32 bits of 'PEX address' that associated with the dma_address
*       dma_Addr_highAddr_Ptr  - (pointer to) the higher 32 bits of 'PEX address' that associated with the dma_address
*
* RETURNS:
*        None
*
* COMMENTS:
*
*
*******************************************************************************/
static void smemAasDmaCnMoAtuConvert(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN SMEM_DMA_CNM_OATU_CLIENT_ENT client,
    IN GT_U32                   subClientId,
    INOUT GT_U32                 *dma_addr_lowAddr_Ptr,
    INOUT GT_U32                 *dma_Addr_highAddr_Ptr
)
{
    DECLARE_FUNC_NAME(smemAasDmaCnMoAtuConvert);

    SMEM_CHT_GENERIC_DEV_MEM_INFO *devMemInfoPtr = devObjPtr->deviceMemory;
    GT_U32  win,regValue;
    GT_U32  atu_baseAddr_low,atu_baseAddr_high;
    GT_U32  lastAddr;
    GT_U32  addrMask;
    GT_U32  cnm_baseAddr_low,cnm_baseAddr_high;/* CnM addresses after CnM windows conversion */
    GT_U32  newBaseAddr_low,newBaseAddr_high;/* final addresses after the oATU conversion */
    GT_U32  clientId,baseAddrUnit_ADDR_DECODER;

    if(client != SMEM_DMA_CNM_OATU_CLIENT_SDMA_E)
    {
        *dma_addr_lowAddr_Ptr  = SMAIN_NOT_VALID_CNS;
        *dma_Addr_highAddr_Ptr = SMAIN_NOT_VALID_CNS;

        __LOG(("smemAasDmaCnMoAtuConvert : not implemented yet for CM7 access to PCIe "));

        return;
    }

    clientId = CNM_Address_Decoder_GDMA0 + subClientId;

    baseAddrUnit_ADDR_DECODER = devObjPtr->memUnitBaseAddrInfo.sip_7_ADDR_DECODER[clientId];

    /* first do CnM ADDR DECODER conversion */
    smemAasSdmaCnMConvert(devObjPtr,
        baseAddrUnit_ADDR_DECODER,
        *dma_addr_lowAddr_Ptr,
        *dma_Addr_highAddr_Ptr,
        dma_addr_lowAddr_Ptr,
        dma_Addr_highAddr_Ptr);

    cnm_baseAddr_low  = *dma_addr_lowAddr_Ptr;
    cnm_baseAddr_high = *dma_Addr_highAddr_Ptr;

    if(SMAIN_NOT_VALID_CNS == cnm_baseAddr_low)
    {
        /* the mapping not gone well */
        return;
    }

    /* the oATU memories are in the 'synopsys PEX' unit */
    for(win = 0 ; win < oATU_WINDOWS_NUM ; win++)
    {
        OATU_REG_GET(oATU_REGION_CTRL_2_REG,regValue);

        if(0 == (regValue & 0x80000000))
        {
            /* the window is not enabled */
            __LOG_NO_LOCATION_META_DATA__WITH_SCIB_LOCK(("oAtu skip window[%d] (window is not enabled) \n",
            win));
            continue;
        }

        OATU_REG_GET(oATU_UPPER_BASE_ADDRESS_REG,atu_baseAddr_high);

        if(cnm_baseAddr_high != atu_baseAddr_high)
        {
            __LOG_NO_LOCATION_META_DATA__WITH_SCIB_LOCK(("oAtu NO matched : cnm_baseAddr_high[0x%8.8x] not match on window[%d] \n",
            cnm_baseAddr_high,
            win));
            continue;
        }

        OATU_REG_GET(oATU_LOWER_BASE_ADDRESS_REG,atu_baseAddr_low);

        if(cnm_baseAddr_low < atu_baseAddr_low)
        {
            __LOG_NO_LOCATION_META_DATA__WITH_SCIB_LOCK(("oAtu NO match : cnm_baseAddr_low[0x%8.8x] below the range in window[%d] \n",
            cnm_baseAddr_low,
            win));
            continue;
        }

        OATU_REG_GET(oATU_LIMIT_ADDRESS_REG,lastAddr);  /* base + size - 1 */

        if(lastAddr & atu_baseAddr_low & 0x80000000)
        {
            /* bit 31 set on both of them , all addresses above atu_baseAddr_low are allowed */
        }
        else
        if(cnm_baseAddr_low > (atu_baseAddr_low + lastAddr))
        {
            __LOG_NO_LOCATION_META_DATA__WITH_SCIB_LOCK(("oAtu NO match : cnm_baseAddr_low[0x%8.8x] over the range in window[%d] \n",
            cnm_baseAddr_low,
            win));
            continue;
        }

        addrMask = (lastAddr - atu_baseAddr_low) - 1;

        OATU_REG_GET(oATU_LOWER_TARGET_ADDRESS_REG,newBaseAddr_low);

        OATU_REG_GET(oATU_UPPER_TARGET_ADDRESS_REG,newBaseAddr_high);

        /* we have a match in the window */
        *dma_addr_lowAddr_Ptr  = (newBaseAddr_low & (~addrMask)) | /* the new base address            */
                                (cnm_baseAddr_low & addrMask);     /* the offset from start of window */
        *dma_Addr_highAddr_Ptr = newBaseAddr_high;

        __LOG_NO_LOCATION_META_DATA__WITH_SCIB_LOCK(("oAtu convert : cnm_baseAddr_high[0x%8.8x] cnm_baseAddr_low[0x%8.8x] to addr_high[0x%8.8x],addr_low[0x%8.8x] (window[%d])\n",
            cnm_baseAddr_high,
            cnm_baseAddr_low,
            *dma_Addr_highAddr_Ptr,
            *dma_addr_lowAddr_Ptr,
            win));
        return;
    }

    __LOG_NO_LOCATION_META_DATA__WITH_SCIB_LOCK(("oAtu ERROR : not matched : cnm_baseAddr_high[0x%8.8x] cnm_baseAddr_low[0x%8.8x] in any window \n",
        cnm_baseAddr_high,
        cnm_baseAddr_low));
    return;
}

/**
* @internal smemAasOATUMemInit function
* @endinternal
*
* @brief   init oAUT and address decoder related parameters.
*          NOTE: the actual memory space should
*          already been done by regular 'unit allocation'
*
* @param[in] devObjPtr                - pointer to device object.
*                                       Pointer to object for specific subunit
*/
static void smemAasOATUMemInit
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr
)
{
    SMEM_CHT_GENERIC_DEV_MEM_INFO *devMemInfoPtr = devObjPtr->deviceMemory;

    devObjPtr->bar0_size = _1M;/* constant not configurable */
    devObjPtr->bar2_size = _4M;/* default value. TBD active memory to update the value to SCIB via scibBindExt */

    SET_IF_ZERO_MAC(devMemInfoPtr->common.dmaCnMoAtuFunc        ,smemAasDmaCnMoAtuConvert );

    devObjPtr->memUnitBaseAddrInfo.sip_7_ADDR_DECODER[CNM_Address_Decoder_iNIC    ] = AAS_ADDR_CNM_Address_Decoder_iNIC    ;
    devObjPtr->memUnitBaseAddrInfo.sip_7_ADDR_DECODER[CNM_Address_Decoder_PCIe    ] = AAS_ADDR_CNM_Address_Decoder_PCIe    ;
    devObjPtr->memUnitBaseAddrInfo.sip_7_ADDR_DECODER[CNM_Address_Decoder_iunit   ] = AAS_ADDR_CNM_Address_Decoder_iunit   ;
    devObjPtr->memUnitBaseAddrInfo.sip_7_ADDR_DECODER[CNM_Address_Decoder_GDMA0   ] = AAS_ADDR_CNM_Address_Decoder_GDMA0   ;
    devObjPtr->memUnitBaseAddrInfo.sip_7_ADDR_DECODER[CNM_Address_Decoder_GDMA1   ] = AAS_ADDR_CNM_Address_Decoder_GDMA1   ;
    devObjPtr->memUnitBaseAddrInfo.sip_7_ADDR_DECODER[CNM_Address_Decoder_GDMA2   ] = AAS_ADDR_CNM_Address_Decoder_GDMA2   ;
    devObjPtr->memUnitBaseAddrInfo.sip_7_ADDR_DECODER[CNM_Address_Decoder_GDMA3   ] = AAS_ADDR_CNM_Address_Decoder_GDMA3   ;
    devObjPtr->memUnitBaseAddrInfo.sip_7_ADDR_DECODER[CNM_Address_Decoder_EHSM_DMA] = AAS_ADDR_CNM_Address_Decoder_EHSM_DMA;
    devObjPtr->memUnitBaseAddrInfo.sip_7_ADDR_DECODER[CNM_Address_Decoder_AAC_0   ] = AAS_ADDR_CNM_Address_Decoder_AAC_0   ;
    devObjPtr->memUnitBaseAddrInfo.sip_7_ADDR_DECODER[CNM_Address_Decoder_AAC_1   ] = AAS_ADDR_CNM_Address_Decoder_AAC_1   ;
    devObjPtr->memUnitBaseAddrInfo.sip_7_ADDR_DECODER[CNM_Address_Decoder_AMB     ] = AAS_ADDR_CNM_Address_Decoder_AMB     ;

    {
        GT_U32  win;
        /* oATU 8 windows */
        for(win = 0 ; win < oATU_WINDOWS_NUM ; win++)
        {
            devMemInfoPtr->common.oAtuWindowsMemPtr[win] =
                smemGenericFindMem(devObjPtr,SKERNEL_MEMORY_READ_BAR0_E,
                    oATU_REGISTER_ADDRESS(win,oATU_REGION_CTRL_1_REG),
                    1,NULL/*no active memory needed*/);
        }
    }

    return;
}

/**
* @internal internal_smemAasInit function
* @endinternal
*
* @brief   Init memory module for a Falcon device.
*/
static void internal_smemAasInit
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr
)
{
    GT_BOOL isAas = GT_FALSE;

    /* state the supported features */
    SMEM_CHT_IS_SIP7_GET(devObjPtr) = 1;

    if(devObjPtr->devMemUnitNameAndIndexPtr == NULL)
    {
        buildDevUnitAddr(devObjPtr);

        isAas = GT_TRUE;
    }

    if(devObjPtr->registersDefaultsPtr == NULL)
    {
        /*devObjPtr->registersDefaultsPtr = &linkListElementsBobcat3_RegistersDefaults;*/
    }

    if(devObjPtr->registersDefaultsPtr_unitsDuplications == NULL)
    {
        devObjPtr->registersDefaultsPtr_unitsDuplications = aas_duplicatedUnits;
        devObjPtr->unitsDuplicationsPtr = aas_duplicatedUnits;
    }

    if (isAas == GT_TRUE)
    {
        devObjPtr->devMemGopRegDbInitFuncPtr = smemAasGopRegDbInit;
        devObjPtr->devIsOwnerMemFunPtr = NULL;
        devObjPtr->devFindMemFunPtr = (void *)smemGenericFindMem;
        devObjPtr->devMemPortInfoGetPtr =  smemAasPortInfoGet;

        devObjPtr->devMemGetMgUnitIndexFromAddressPtr = smemAasGetMgUnitIndexFromAddress;
        devObjPtr->devMemGopPortByAddrGetPtr = smemAasGopPortByAddrGet;
        devObjPtr->devMemMibPortByAddrGetPtr = smemAasGopPortByAddrGet;
        devObjPtr->devMemHsrPrpTimerGetFuncPtr = smemSip6_30FdbHsrPrpTimerGet;

        devObjPtr->multiDataPath.supportMultiDataPath =  1;
        devObjPtr->multiDataPath.maxDp = NUM_DP_UNITS;
        devObjPtr->numOfPipesPerTile = 1;
        devObjPtr->numOfTiles        = devObjPtr->deviceType == SKERNEL_AAS ? 1 :2;
        devObjPtr->tileOffset        = TILE_OFFSET;
        devObjPtr->mirroredTilesBmp  = 0;/* no mirroring of tiles */
        devObjPtr->numOfPipes = devObjPtr->numOfTiles * devObjPtr->numOfPipesPerTile;
        devObjPtr->numOfPortsPerPipe =
            (devObjPtr->multiDataPath.maxDp*NUM_PORTS_PER_DP_UNIT);/*4*20=80*/

        devObjPtr->numOfMgUnits = 0;/* NO MG units */

        /* state 'data path' structure */
        /* !!! there is NO TXQ-dq in Aas (like in Hawk) !!! */
        devObjPtr->multiDataPath.numTxqDq           = 0;
        devObjPtr->multiDataPath.txqDqNumPortsPerDp = 0;

        devObjPtr->multiDataPath.supportRelativePortNum = 1;

        devObjPtr->supportTrafficManager_notAllowed = 1;

        devObjPtr->dmaNumOfCpuPort = devObjPtr->numOfTiles == 1 ? CPU_SDMA : CPU_SDMA_2_TILES;

        /* 'global' port in the egress RXDMA/TXDMA units */

        devObjPtr->txqNumPorts = TXQ_PDX_QUEUE_GROUP_MAP_NUM;/* the limit on the 10 bits in SMEM_LION2_EGF_QAG_TARGET_PORT_MAPPER_TBL_MEM */

        devObjPtr->multiDataPath.maxIa = 1;/* single IA */

        {/* support the multi DP units */
            GT_U32  index;

            for(index = 0 ; index < devObjPtr->multiDataPath.maxDp * devObjPtr->numOfPipes; index++)
            {
                devObjPtr->multiDataPath.info[index].dataPathFirstPort  = NUM_PORTS_FOR_NUMBERRING_DP_UNIT*index;/* without the 'CPU port' */
                devObjPtr->multiDataPath.info[index].dataPathNumOfPorts = NUM_PORTS_FOR_NUMBERRING_DP_UNIT;      /* without the 'CPU port' */
                devObjPtr->multiDataPath.info[index].cpuPortDmaNum      = CPU_SDMA_LOCAL_CHANNEL;                /* the 'CPU port' number  in the DP */
            }
        }

        devObjPtr->memUnitBaseAddrInfo.lpm[0] = UNIT_BASE_ADDR_GET_MAC(devObjPtr,UNIT_LPM);
        if(devObjPtr->numOfTiles == 2)
        {
            devObjPtr->memUnitBaseAddrInfo.lpm[1] = devObjPtr->memUnitBaseAddrInfo.lpm[0]+devObjPtr->tileOffset;
        }

        if(devObjPtr->numOfTiles == 1)
        {
            devObjPtr->dma_specialPortMappingArr         = aas_DMA_specialPortMappingArr;
            devObjPtr->cpuPortSdma_specialPortMappingArr = aas_cpuPortSdma_specialPortMappingArr;
            devObjPtr->gop_specialPortMappingArr         = aas_GOP_specialPortMappingArr;
        }
        else
        {
            devObjPtr->dma_specialPortMappingArr         = aas_2_tiles_DMA_specialPortMappingArr;
            devObjPtr->cpuPortSdma_specialPortMappingArr = aas_2_tiles_cpuPortSdma_specialPortMappingArr;
            devObjPtr->gop_specialPortMappingArr         = aas_2_tiles_GOP_specialPortMappingArr;
        }


        /* the device not supports IPCL 0 (supports only IPCL1,2) */
        devObjPtr->isIpcl0NotValid  = 1;/* like Falcon */
        devObjPtr->tcam_numBanksForHitNumGranularity = 2; /* like BC2 */
        devObjPtr->portMacSecondBase = 0;
        devObjPtr->portMacSecondBaseFirstPort = 0;

        devObjPtr->limitedNumOfParrallelLookups = 0;/*np limit*/

        devObjPtr->support_remotePhysicalPortsTableMode = 0;/*ignore the mode*/

        devObjPtr->flexFieldNumBitsSupport.phyPort = 10;/* 1<<10 = 1K = NUM_PHY_PORTS */
        devObjPtr->flexFieldNumBitsSupport.eVid = 16;/* 64K eVlans  */

        SET_IF_ZERO_MAC(devObjPtr->limitedResources.phyPort,NUM_PHY_PORTS);/*1024 in Falcon , 512 in BC3, 128 in Aldrin2*/
        SET_IF_ZERO_MAC(devObjPtr->defaultEPortNumEntries,NUM_DEF_EPORTS);/*was 1K in prev devices */
        SET_IF_ZERO_MAC(devObjPtr->TTI_myPhysicalPortAttributes_numEntries,NUM_MY_PHYSICAL_PORT);
        SET_IF_ZERO_MAC(devObjPtr->TTI_mac2me_numEntries,256);
        SET_IF_ZERO_MAC(devObjPtr->limitedResources.ePort,NUM_EPORTS);

        SET_IF_ZERO_MAC(devObjPtr->lpmRam.numOfLpmRams , LPM_MAX_NUM_OF_BLOCKS);
        SET_IF_ZERO_MAC(devObjPtr->lpmRam.perRamNumEntries, 128*_1K);/* each 2 blocks share 256K lines. at the moment we set it half for each bank */
        SET_IF_ZERO_MAC(devObjPtr->lpmRam.numOfEntriesBetweenRams, LPM_RAM_TOTAL_BLOCKS_SIZE_INCLUDING_GAP_CNS);

        devObjPtr->cncNumOfUnits = 4;
        devObjPtr->cncBlocksNum  = 16;
        devObjPtr->cncClientInstances = 3;
        devObjPtr->cncUnitSize   = CNC_UNIT_SIZE;
        devObjPtr->cncBlockMaxRangeIndex = 16*_1K;

        devObjPtr->fdbMaxNumEntries      = SMEM_MAC_TABLE_SIZE_256KB;
        /* EM support yet not ready */
        devObjPtr->emMaxNumEntries       = SMEM_MAC_TABLE_SIZE_256KB;
        devObjPtr->emAutoLearnNumEntries = 2731;
        devObjPtr->limitedResources.eVid  = NUM_EVIDS;     /*  8K in Hawk*/
        devObjPtr->limitedResources.stgId = NUM_STGS;           /*  4K in Hawk*/
        devObjPtr->limitedResources.nextHop     =  48*_1K;      /* 16K in Hawk*/

        devObjPtr->policerSupport.iplrTableSize = 128*_1K;      /*  4K in Hawk*/
        devObjPtr->policerSupport.numOfIpfix    = 256*_1K;      /* 64K in Hawk*/
        devObjPtr->tcamNumOfFloors              = 24;  /* 24 *3K = 72K@10B = 36K@20B */
        devObjPtr->limitedResources.mllPairs    = 128*_1K;      /*  8K in Hawk*/
        devObjPtr->limitedResources.l2LttMll    = 96*_1K;       /* 16K in Hawk*/
        devObjPtr->limitedResources.l3LttMll    = 64*_1K;       /*  4K in Hawk (the same)*/
        devObjPtr->limitedResources.l2Ecmp      = 32*_1K;       /*  8K in Hawk (the same)*/
        devObjPtr->limitedResources.trunkEcmp   = NUM_TRUNKS_ECMP;/*  split from L2 ECMP . 8K members */
        devObjPtr->limitedResources.l2LttEcmp   = NUM_EPORTS;       /* like Hawk according to number of eports(8K) */
        devObjPtr->limitedResources.numOfArps   = NUM_ARPS; /*1M*/ /*256K in Hawk*/
        devObjPtr->limitedResources.numOfTs     = NUM_TS;   /*128K*/ /*256K in Hawk*/
        devObjPtr->limitedResources.ipvxEcmp    = 16*_1K;   /* 6K in Hawk : each line 2 entries */
        devObjPtr->limitedResources.preqSrfNum  = 1*_1K;
        devObjPtr->limitedResources.smuIrfNum   = 2*_1K;
        devObjPtr->limitedResources.smuSgcTimeSlotAttributesNum = 14848;
        devObjPtr->limitedResources.portIsolationNum = NUM_PORT_ISOLATION;
        devObjPtr->limitedResources.ipToMeNum = NUM_IP2ME;
        devObjPtr->limitedResources.l2iHportsNum = 10;
        devObjPtr->limitedResources.ipclConfigNum = 6*_1K;
        devObjPtr->egfNumBitsPerPort = 10;
        devObjPtr->eqNumBitsPerEPort = 14;/*16K eports*/

        devObjPtr->numofTcamClients = AAS_TCAM_NUM_OF_GROUPS_CNS;

        devObjPtr->mtiMibCounter.rxCntNum = CHT_INTERNAL_SIMULATION_RX_STATISTIC_PAGE;
        devObjPtr->mtiMibCounter.txCntNum = CHT_INTERNAL_SIMULATION_TX_STATISTIC_PAGE;

        devObjPtr->numofMPclProfileId = 256;

        /* supporting multiple tables in the SHM unit */
        devObjPtr->sharedTablesInfo.isSharedTablesSupported = 1;
        devObjPtr->sharedTablesInfo.isFdbShared = 1;
        devObjPtr->sharedTablesInfo.isEmShared  = 1;
        devObjPtr->sharedTablesInfo.isTsShared  = 1;
        devObjPtr->sharedTablesInfo.isLpmShared = 1;
        devObjPtr->sharedTablesInfo.isArpShared = 1;
        devObjPtr->sharedTablesInfo.isIpe0Shared = 1;
        devObjPtr->sharedTablesInfo.isIpe1Shared = 1;
        devObjPtr->sharedTablesInfo.isPlrMeterShared   = 1;
        devObjPtr->sharedTablesInfo.isPlrCounterShared = 1;
        devObjPtr->sharedTablesInfo.isHf0Shared = 1;
        devObjPtr->sharedTablesInfo.isHf1Shared = 1;
        devObjPtr->sharedTablesInfo.isCncShared = 1;

        devObjPtr->freeRunningTaiInst = 2;

        devObjPtr->supportGdma  = 1;
        devObjPtr->supportGdma_AUQ = 1;
        devObjPtr->supportGdma_FUQ = 1;
        devObjPtr->supportGdma_CNC = 1;

        devObjPtr->numOfGdmaUnits = 4 * devObjPtr->numOfTiles;

        devObjPtr->memUnitBaseAddrInfo.sip_7_GDMA[0] = UNIT_BASE_ADDR_GET_MAC(devObjPtr,UNIT_CNM_GDMA  );
        devObjPtr->memUnitBaseAddrInfo.sip_7_GDMA[1] = UNIT_BASE_ADDR_GET_MAC(devObjPtr,UNIT_CNM_GDMA_1);
        devObjPtr->memUnitBaseAddrInfo.sip_7_GDMA[2] = UNIT_BASE_ADDR_GET_MAC(devObjPtr,UNIT_CNM_GDMA_2);
        devObjPtr->memUnitBaseAddrInfo.sip_7_GDMA[3] = UNIT_BASE_ADDR_GET_MAC(devObjPtr,UNIT_CNM_GDMA_3);
        if(devObjPtr->numOfTiles == 2)
        {
            devObjPtr->memUnitBaseAddrInfo.sip_7_GDMA[4] = devObjPtr->memUnitBaseAddrInfo.sip_7_GDMA[0]+devObjPtr->tileOffset;
            devObjPtr->memUnitBaseAddrInfo.sip_7_GDMA[5] = devObjPtr->memUnitBaseAddrInfo.sip_7_GDMA[1]+devObjPtr->tileOffset;
            devObjPtr->memUnitBaseAddrInfo.sip_7_GDMA[6] = devObjPtr->memUnitBaseAddrInfo.sip_7_GDMA[2]+devObjPtr->tileOffset;
            devObjPtr->memUnitBaseAddrInfo.sip_7_GDMA[7] = devObjPtr->memUnitBaseAddrInfo.sip_7_GDMA[3]+devObjPtr->tileOffset;
        }

        {
            /*GDMA0,GDMA3 not pointed by the gdma Dispatcher ! */
            devObjPtr->gdmaInfo.gdmaDispatcherToUnitmap[0] = 1;/*GDMA1*/
            devObjPtr->gdmaInfo.gdmaDispatcherToUnitmap[1] = 2;/*GDMA2*/
            devObjPtr->gdmaInfo.gdmaDispatcherToUnitmap[2] = SMAIN_NOT_VALID_CNS;
            devObjPtr->gdmaInfo.gdmaDispatcherToUnitmap[3] = SMAIN_NOT_VALID_CNS;

            devObjPtr->gdmaInfo.gdmaUnitForFdbMsg = 0;/*GDMA0*/
            devObjPtr->gdmaInfo.gdmaUnitForCncMsg = 0;/*GDMA0*/
            devObjPtr->gdmaInfo.gdmaUnitForIpeMsg = 0;/*GDMA0*/

            if(devObjPtr->numOfTiles == 1)
            {
                devObjPtr->gdmaInfo.gdmaFromCpuMapTo_ingressRxDmaPortNumber[0] = 81;/*GDMA0 connected to DP[0] for 'FROM_CPU' */
                devObjPtr->gdmaInfo.gdmaFromCpuMapTo_ingressRxDmaPortNumber[1] = SMAIN_NOT_VALID_CNS;/*GDMA1 NO connected to DP[] for 'FROM_CPU' */
                devObjPtr->gdmaInfo.gdmaFromCpuMapTo_ingressRxDmaPortNumber[2] = 82;/*GDMA2 connected to DP[1] for 'FROM_CPU' */
                devObjPtr->gdmaInfo.gdmaFromCpuMapTo_ingressRxDmaPortNumber[3] = 83;/*GDMA3 connected to DP[2] for 'FROM_CPU' */
            }
            else
            {
                devObjPtr->gdmaInfo.gdmaFromCpuMapTo_ingressRxDmaPortNumber[0] = 161;/*GDMA0 connected to DP[0] for 'FROM_CPU' */
                devObjPtr->gdmaInfo.gdmaFromCpuMapTo_ingressRxDmaPortNumber[1] = SMAIN_NOT_VALID_CNS;/*GDMA1 NO connected to DP[] for 'FROM_CPU' */
                devObjPtr->gdmaInfo.gdmaFromCpuMapTo_ingressRxDmaPortNumber[2] = 162;/*GDMA2 connected to DP[1] for 'FROM_CPU' */
                devObjPtr->gdmaInfo.gdmaFromCpuMapTo_ingressRxDmaPortNumber[3] = 163;/*GDMA3 connected to DP[2] for 'FROM_CPU' */
                devObjPtr->gdmaInfo.gdmaFromCpuMapTo_ingressRxDmaPortNumber[4] = 164;/*GDMA0 connected to DP[0] for 'FROM_CPU' */
                devObjPtr->gdmaInfo.gdmaFromCpuMapTo_ingressRxDmaPortNumber[5] = SMAIN_NOT_VALID_CNS;/*GDMA1 NO connected to DP[] for 'FROM_CPU' */
                devObjPtr->gdmaInfo.gdmaFromCpuMapTo_ingressRxDmaPortNumber[6] = 165;/*GDMA2 connected to DP[1] for 'FROM_CPU' */
                devObjPtr->gdmaInfo.gdmaFromCpuMapTo_ingressRxDmaPortNumber[7] = 166;/*GDMA3 connected to DP[2] for 'FROM_CPU' */
            }
        }

    }

    devObjPtr->sip7_numWordsAlignmentInNaMsg = 16;
    devObjPtr->sip7_numOfWordsInNaMsg        = 14;

    devObjPtr->sip7_mllInfo.numMllPairsEntriesInLine = 4;
    devObjPtr->sip7_mllInfo.numMllPairsBitsPerEntry  = 185;

    /* function will be called from inside smemLion2AllocSpecMemory(...) */
    if(devObjPtr->devMemSpecificDeviceUnitAlloc == NULL)
    {
        devObjPtr->devMemSpecificDeviceUnitAlloc = smemAasSpecificDeviceUnitAlloc;
    }

    /* function will be called from inside smemLion3Init(...) */
    if(devObjPtr->devMemSpecificDeviceMemInitPart2 == NULL)
    {
        /* let Falcon set it's function */
        /*devObjPtr->devMemSpecificDeviceMemInitPart2 = smemBobcat3SpecificDeviceMemInitPart2;*/
    }

    if(devObjPtr->devMemInterruptTreeInit == NULL)
    {
        devObjPtr->devMemInterruptTreeInit = internal_InterruptTreeInit;
    }

    if(devObjPtr->registersDfxDefaultsPtr == NULL)
    {
        /* let Falcon set it's logic */
    }

    smemIronmanInit(devObjPtr);

    if (isAas == GT_TRUE)
    {
        /* Init oATU and ADDR_DECODER units info */
        smemAasOATUMemInit(devObjPtr);

        /* Init RegDb for DP units */
        smemAasInitRegDbDpUnits(devObjPtr);

        /* check that no unit exceed the size of it's unit */
        smemGenericUnitSizeCheck(devObjPtr,aas_units);

        /* init the FIRMAWARE */
        simulationAc5pFirmwareInit(devObjPtr);
    }

}

/**
* @internal smemAasInit function
* @endinternal
*
* @brief   Init memory module for a Falcon device.
*/
void smemAasInit
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr
)
{
    internal_smemAasInit(devObjPtr);
}


static GT_U32   smemHawkInit_debug_mru = 0x5F2;/*1522*/
extern void smemHawkEgfLinkUpOnSlanBind
(
    IN SKERNEL_DEVICE_OBJECT        *devObjPtr,
    IN GT_U32                       portNumber,
    IN GT_BOOL                      bindRx,
    IN GT_BOOL                      bindTx
);
void snetHawkMifMacEnableTraffic
(
    IN SKERNEL_DEVICE_OBJECT   *devObjPtr,
    IN GT_U32                  macPort ,
    IN GT_U32                  local_dma_port_number
);
extern GT_U32 smemHawkInit_debug_enable_rx_tx_all_ports_get(void);
extern GT_STATUS smemHawkInit_debug_enable_rx_tx_all_ports_set(IN GT_U32    enable);

/* update a register in all pipes */
static void updateRegisterInAllPipes
(
    IN SKERNEL_DEVICE_OBJECT        *devObjPtr,
    IN GT_U32                       regAddress,
    IN GT_U32                       startBit,
    IN GT_U32                       numBits,
    IN GT_U32                       value
)
{
    GT_U32  pipeId;

    /* need to update the register in all pipes */
    for(pipeId = 0 ; pipeId < devObjPtr->numOfPipes ; pipeId++)
    {
        smemSetCurrentPipeId(devObjPtr,pipeId);
        smemRegFldSet(devObjPtr,regAddress,startBit,numBits,value);
    }

    /* restore pipe 0 */
    smemSetCurrentPipeId(devObjPtr,0);
}
/**
* @internal smemAasInit_debug_allowTraffic function
* @endinternal
*
* @brief   debug function to allow traffic (flooding) in the device.
*         to allow debug before the CPSS know how to configure the device.
*         (without the cpssInitSystem)
* @param[in] devObjPtr                - pointer to device object.
*/
static void smemAasInit_debug_allowTraffic
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr
)
{
    GT_U32  numOfPhysicalPorts = 1<<devObjPtr->flexFieldNumBitsSupport.phyPort;

    if(smemHawkInit_debug_enable_rx_tx_all_ports_get())
    {
        /* EGF link down filter */
        /* set the SLAN ports in link up */
        devObjPtr->devSlanBindPostFuncPtr = smemHawkEgfLinkUpOnSlanBind;
    }

    {
        GT_U32  ii,tileId;
        GT_U32  regAddress;
        GT_U32  value;
        GT_U32  numPortsPerTile = devObjPtr->portsNumber;

        /* port per register */
        for(tileId = 0 ; tileId < devObjPtr->numOfTiles; tileId++)
        {
            smemSetCurrentPipeId(devObjPtr,tileId * devObjPtr->numOfPipesPerTile);

            for(ii = 0 ; ii < numPortsPerTile ; ii++)
            {
                regAddress = SMEM_LION3_RXDMA_SCDMA_CONFIG_1_REG(devObjPtr,ii);

                if(ii>59 || tileId > 0)
                {
                    value = ii + 5;
                }
                else
                {
                    value = ii;
                }

                /*perform RXDMA mapping from local port to 'virual' port on the field of:
                  localDevSrcPort */
                smemRegFldSet(devObjPtr,regAddress,
                    0, 9, value);
            }
        }
        /*restore*/
        smemSetCurrentPipeId(devObjPtr,0);
    }

    {
        GT_U32  ii;
        GT_U32  regAddress = SMEM_BOBCAT2_BMA_PORT_MAPPING_TBL_MEM(devObjPtr,0);
        GT_U32  value;

        /* /Cider/EBU/Bobcat3/Bobcat3 {Current}/Switching Core/BMA_IP/Tables/<BMA_IP> BMA_IP Features/Port Mapping/Port Mapping entry */
        /* set mapping 1:1 */

        /* port per register */
        for(ii = 0 ; ii < numOfPhysicalPorts ; ii++ , regAddress+=4)
        {
            value = ii % 32 ;/* local number*/
            updateRegisterInAllPipes(devObjPtr,regAddress,0,32,value);
        }
    }

    {
        GT_U32  ii;

        for(ii = 0 ; ii < devObjPtr->portsNumber ; ii++)
        {
            if(!IS_CHT_VALID_PORT(devObjPtr,ii))
            {
                continue;
            }

            snetChtPortMacFieldSet(devObjPtr, ii,
                SNET_CHT_PORT_MAC_FIELDS_rx_path_en_E,smemHawkInit_debug_enable_rx_tx_all_ports_get());
            snetChtPortMacFieldSet(devObjPtr, ii,
                SNET_CHT_PORT_MAC_FIELDS_tx_path_en_E,smemHawkInit_debug_enable_rx_tx_all_ports_get());
            snetChtPortMacFieldSet(devObjPtr, ii,
                SNET_CHT_PORT_MAC_FIELDS_mru_E,smemHawkInit_debug_mru);
        }

        /* set MRU for the vlan prifile 0 that default vlan uses */
        updateRegisterInAllPipes(devObjPtr,
            SMEM_CHT2_MRU_PROFILE_REG(devObjPtr, 0/*mruEntryIndex*/),
            0,14,smemHawkInit_debug_mru);
    }

    {
        GT_U32  ii;
        GT_U32  value;
        GT_U32  regAddress;
        for(ii = 0 ; ii < numOfPhysicalPorts ; ii++)
        {
            /* EGF_QAG -  Target Port Mapper table */
            regAddress = SMEM_LION2_EGF_QAG_TARGET_PORT_MAPPER_TBL_MEM(devObjPtr,ii);
            /* currently 1:1 */
            value = ii;

            /*SMEM_SIP7_EGRESS_EGF_QAG_TARGET_PORT_MAPPER_TABLE_FIELDS_QUEUE_GROUP_INDEX_E*/
            /* set only 17 bits , to not harm other defaults */
            updateRegisterInAllPipes(devObjPtr,regAddress,6,17,value);
        }
    }

    {
        GT_U32  value = 0x1;/* 128 ports mode */
        GT_U32  regAddress;

        regAddress = SMEM_LION_TXQ_DISTR_GENERAL_CONF_REG(devObjPtr);
        /*EGF_QAG_TableMode*/
        updateRegisterInAllPipes(devObjPtr,regAddress,15, 3, value);

        regAddress = SMEM_CHT_BRDG_GLB_CONF0_REG(devObjPtr);
        /*l2i_TableMode*/
        updateRegisterInAllPipes(devObjPtr,regAddress,28, 3, value);


        regAddress = SMEM_LION_TXQ_SHT_GLOBAL_CONF_REG(devObjPtr);
        /*EGF_SHT_TableMode*/
        updateRegisterInAllPipes(devObjPtr,regAddress,8, 3, value);
    }

    /* allow vidx 0xfff to hold all ports */
    {
        GT_U32  regAddress,ii;
        GT_U32  vidx = 0xfff;
        GT_U32  value = 0xFFFFFFFF;

        regAddress = SMEM_CHT_MCST_TBL_MEM(devObjPtr, vidx);

        for(ii = 0 ; ii < numOfPhysicalPorts/32 ; ii++)
        {
            updateRegisterInAllPipes(devObjPtr,regAddress + ii*4,0, 32, value);
        }
    }

    {
        GT_U32  ii,jj;
        GT_U32  value;

        for(ii = 0 ; ii < devObjPtr->multiDataPath.maxDp * devObjPtr->numOfPipes; ii++)
        {
            /*enable ports at the SDQ */
            value = 0x1;

           for(jj=0;jj<devObjPtr->multiDataPath.info[ii].dataPathNumOfPorts;jj++)
           {
                smemRegSet(devObjPtr ,
                SMEM_SIP6_TXQ_SDQ_GLOBAL_PORT_ENABLE_REG(devObjPtr,ii,jj) , value);
           }
        }
    }
#define HELP_CPSS_IN_MISSING_CONFIG
#ifdef HELP_CPSS_IN_MISSING_CONFIG
    /* MAP the TXQ-SDQ queue index to local DMA port number (by using ranges of 8 queues per port)*/
    {
        GT_U32  ii,jj;
        GT_U32  value;

        for(ii = 0 ; ii < devObjPtr->multiDataPath.maxDp * devObjPtr->numOfPipes; ii++)
        {
            value = 0; /* values of queue_base */
            for(jj = 0 ; jj < devObjPtr->multiDataPath.info[ii].dataPathNumOfPorts; jj++)
            {
                smemRegSet(devObjPtr ,
                SMEM_SIP6_TXQ_SDQ_PORT_CONFIG_PORT_RANGE_LOW_REG(devObjPtr,ii,jj) , value);

                value += 7;
                smemRegSet(devObjPtr ,
                SMEM_SIP6_TXQ_SDQ_PORT_CONFIG_PORT_RANGE_HIGH_REG(devObjPtr,ii,jj) , value);
                value ++;
            }
        }
    }


    {
        GT_U32  ii;
        GT_U32  value;
        GT_U32  queue_pds_index,queue_base;
        GT_U32  numPorts = devObjPtr->portsNumber;
        GT_U32  portsPerDp=devObjPtr->multiDataPath.info[0].dataPathNumOfPorts;
        GT_U32  tileId;
        GT_U32  offset_for_reserved = 5; /*support the jump over 59..63 */
        GT_U32  first_reserved      = 59;/* reverse logic of portNumber >= 59 from smemHawkEgfLinkUpOnSlanBind */


        numPorts += offset_for_reserved;

        /*for(tileId = 0 ; tileId < devObjPtr->numOfTiles;tileId++)*/
        {
            for(ii = 0 ; ii < numPorts; ii++)
            {
                if(ii == 63)
                {
                    /* we need queue for the CPU */
                    queue_base = portsPerDp * 8;
                    queue_pds_index = 0;/*DP[0]*/
                }
                else
                if(ii >= (first_reserved/*59*/+offset_for_reserved/*5*/)/*64*/)
                {
                    /* physical ports that jump over reserved ports */
                    queue_base = 8 * ((ii-offset_for_reserved/*5*/) %portsPerDp);
                    queue_pds_index = (ii-offset_for_reserved/*5*/) /portsPerDp;
                }
                else
                {
                    /* physical ports mapped 1:1 with global MAC/DMA*/
                    queue_base = 8 * (ii %portsPerDp);
                    queue_pds_index = ii /portsPerDp;
                }

                if(queue_pds_index >= (NUM_DP_UNITS*devObjPtr->numOfPipes))
                {
                    /* over the max ... ignore */
                    continue;
                }

                tileId = (queue_pds_index >= NUM_DP_UNITS) ? 1 : 0;
                queue_pds_index %= NUM_DP_UNITS;/* local PDS in the tile */

                value = 0;

                /* need to match code in snetFalconTxqPdxQueueGroupMap(...) */
                SMEM_U32_SET_FIELD(value,0,12,queue_base);
                SMEM_U32_SET_FIELD(value,12,6,0/*dp_core_local_trg_port -- not care for simulation ... so 0 */);
                SMEM_U32_SET_FIELD(value,18,3,queue_pds_index);
                SMEM_U32_SET_FIELD(value,21,1,tileId/*queue_pdx_index -- tileId*/);

                updateRegisterInAllPipes(devObjPtr ,SMEM_SIP6_TXQ_PDX_QUEUE_GROUP_MAP_TBL_MEM(devObjPtr,
                    ii,0),0,32,value);
            }
        }
    }
#endif /*HELP_CPSS_IN_MISSING_CONFIG*/

    /* set <Flood eVIDX> */
    updateRegisterInAllPipes(devObjPtr,
        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->EGF_sht.global.SHTGlobalConfigs,
        0,32,
        0x1FFF007);

    /* In micro-init profiles the 'create' of port will set it's needed values */
    if(smemHawkInit_debug_enable_rx_tx_all_ports_get())
    {
        GT_U32  ii,localDmaPort;
        /* add here logic for Harrier that differ/override from Hawk */
        for(ii = 0 ; ii < devObjPtr->portsNumber;ii++)
        {
            if(!IS_CHT_VALID_PORT(devObjPtr,ii))
            {
                continue;
            }

            if(devObjPtr->portsArr[ii].state != SKERNEL_PORT_STATE_MTI_50_E  &&
               devObjPtr->portsArr[ii].state != SKERNEL_PORT_STATE_MTI_100_E &&
               devObjPtr->portsArr[ii].state != SKERNEL_PORT_STATE_MTI_200_E &&
               devObjPtr->portsArr[ii].state != SKERNEL_PORT_STATE_MTI_400_E)
            {
                continue;
            }


            localDmaPort = ii % devObjPtr->multiDataPath.info[0].dataPathNumOfPorts;
            snetHawkMifMacEnableTraffic(devObjPtr,ii,localDmaPort);
        }
    }

    {
        /* set vlan#1 with members (ingress,egress) */
        GT_U32  ii;
        GT_U32  address;
        GT_U32  value[32];
        GT_U32  vid = 1;

        memset(value,0xFF,sizeof(value));
        /* set egress vlan members */
        address = SMEM_LION_EGR_VLAN_TBL_MEM_REG(devObjPtr, vid);
        for(ii = 0 ; ii < numOfPhysicalPorts/32; ii++)
        {
            updateRegisterInAllPipes(devObjPtr , address + 4 * ii , 0,32,value[ii]);
        }

        /* set ingress vlan members */
        address = SMEM_LION2_BRIDGE_INGRESS_PORT_MEMBERSHIP_TBL_MEM(devObjPtr, vid);
        for(ii = 0 ; ii < numOfPhysicalPorts/32; ii++)
        {
            updateRegisterInAllPipes(devObjPtr , address + 4 * ii , 0,32,value[ii]);
        }

        /* map egress tag0 = 1 for eVid = 1 */
        smemRegFldSet(devObjPtr,
            SMEM_SIP7_EGF_EFT_EVLAN_TBL_MEM(devObjPtr, vid) ,
            0, 12, vid/*tag0_vid*/);
    }


    /* <DeviceEn> -- enable only after the mapping of DP units are done */
    updateRegisterInAllPipes(devObjPtr, SMEM_LION2_DFX_SERVER_RESET_CONTROL_REG(devObjPtr), 0, 1, 1);
}


/**
* @internal smemAasInit2 function
* @endinternal
*
* @brief   Init memory module for a device - after the load of the default
*         registers file
* @param[in] devObjPtr                - pointer to device object.
*/
void smemAasInit2
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr
)
{
    static int my_dummy = 0;
    GT_U32  ii;
    GT_U32  regAddr;

    smemIronmanInit2(devObjPtr);

    for(ii = 0 ; ii < MAX_EM_UNIT_NUM_CNS ; ii++)
    {
        /* call to : smemAasActiveWriteExactMatchGlobalCfgReg(...)
            to set devObjPtr->emNumEntries[instance] ,
            devObjPtr->emNumOfBanks[instance]
        */
        regAddr = SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->EXACT_MATCH[ii].
            emGlobalConfiguration.emGlobalConfiguration1;
        smemRegUpdateAfterRegFile(devObjPtr,regAddr,1);
    }

    if(devObjPtr->numOfTiles == 2)
    {
        my_dummy = 1;
    }

    if(my_dummy)
    {
        static GT_U32   allowAllPortsRxTx = 1;

        smemHawkInit_debug_enable_rx_tx_all_ports_set(allowAllPortsRxTx);
        smemAasInit_debug_allowTraffic(devObjPtr);
    }
}


/**

* @internal smemAasUnitTxqQfc function
* @endinternal
*
* @brief   Allocate address type specific memories -- for the txq QFC unit
*/
static void smemAasUnitTxqQfc
(
    IN SKERNEL_DEVICE_OBJECT *devObjPtr,
    IN SMEM_UNIT_CHUNKS_STC  *unitPtr
)
{

    START_BIND_UNIT_ACTIVE_MEM_MAC(devObjPtr,unitPtr)

    /* SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->SIP6_TXQ_QFC[0].Counter_Table_1_Indirect_Read_Address */
    {0x0000080C , SMEM_FULL_MASK_CNS, NULL, 0, smemFalconActiveWriteTxqQfcCounterTable1IndirectReadAddress, 28/*bit 28*/},

    END_BIND_UNIT_ACTIVE_MEM_MAC(devObjPtr,unitPtr)
    {
        SMEM_CHUNK_BASIC_STC  chunksMem[]=
        {
         {SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000000, 0x00000064)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000100, 0x0000013C)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000200, 0x00000258)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000400, 0x0000047C)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000510, 0x00000568)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000600, 0x00000644)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000800, 0x00000814)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000A00, 0x00000A58)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000C00, 0x00000C0C)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001000, 0x00001008)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001010, 0x00001018)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001020, 0x00001028)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001030, 0x00001038)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001040, 0x00001048)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001050, 0x00001058)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001060, 0x00001068)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001070, 0x00001078)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001080, 0x00001088)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001090, 0x00001098)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000010A0, 0x000010A8)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000010B0, 0x000010B8)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000010C0, 0x000010C8)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000010D0, 0x000010D8)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000010E0, 0x000010E8)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000010F0, 0x000010F8)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001100, 0x00001108)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001110, 0x00001118)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001120, 0x00001128)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001130, 0x00001138)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001140, 0x00001148)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001150, 0x00001158)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001160, 0x00001168)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001170, 0x00001178)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001180, 0x00001188)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001190, 0x00001198)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000011A0, 0x000011A8)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000011B0, 0x000011B8)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000011C0, 0x000011C8)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000011D0, 0x000011D8)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000011E0, 0x000011E8)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000011F0, 0x000011F8)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001200, 0x00001208)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001210, 0x00001218)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001220, 0x00001228)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001230, 0x00001238)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001240, 0x00001248)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001250, 0x00001258)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001260, 0x00001268)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001270, 0x00001278)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001280, 0x00001288)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001290, 0x00001298)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000012A0, 0x000012A8)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000012B0, 0x000012B8)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000012C0, 0x000012C8)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000012D0, 0x000012D8)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000012E0, 0x000012E8)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000012F0, 0x000012F8)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001300, 0x00001308)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001310, 0x00001318)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001320, 0x00001328)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001330, 0x00001338)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001340, 0x00001348)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001350, 0x00001358)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001360, 0x00001368)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001370, 0x00001378)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001380, 0x00001388)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001390, 0x00001398)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000013A0, 0x000013A8)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000013B0, 0x000013B8)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000013C0, 0x000013C8)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000013D0, 0x000013D8)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000013E0, 0x000013E8)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000013F0, 0x000013F8)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001400, 0x00001408)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001410, 0x00001418)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001420, 0x00001428)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001430, 0x00001438)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001440, 0x00001448)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001450, 0x00001458)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001460, 0x00001468)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001470, 0x00001478)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001480, 0x00001488)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001490, 0x00001498)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000014A0, 0x000014A8)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000014B0, 0x000014B8)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000014C0, 0x000014C8)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000014D0, 0x000014D8)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000014E0, 0x000014E8)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000014F0, 0x000014F8)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001500, 0x00001508)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001510, 0x00001518)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001520, 0x00001528)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001530, 0x00001538)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001540, 0x00001548)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001550, 0x00001558)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001560, 0x00001568)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001570, 0x00001578)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001580, 0x00001588)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001590, 0x00001598)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000015A0, 0x000015A8)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000015B0, 0x000015B8)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000015C0, 0x000015C8)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000015D0, 0x000015D8)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000015E0, 0x000015E8)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000015F0, 0x000015F8)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001600, 0x00001608)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001610, 0x00001618)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001620, 0x00001628)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001630, 0x00001638)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001640, 0x00001648)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001650, 0x00001658)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001660, 0x00001668)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001670, 0x00001678)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001680, 0x00001688)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001690, 0x00001698)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000016A0, 0x000016A8)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000016B0, 0x000016B8)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000016C0, 0x000016C8)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000016D0, 0x000016D8)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000016E0, 0x000016E8)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000016F0, 0x000016F8)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001700, 0x00001708)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001710, 0x00001718)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001720, 0x00001728)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001730, 0x00001738)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001740, 0x00001748)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001750, 0x00001758)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001760, 0x00001768)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001770, 0x00001778)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001780, 0x00001788)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001790, 0x00001798)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000017A0, 0x000017A8)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000017B0, 0x000017B8)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000017C0, 0x000017C8)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000017D0, 0x000017D8)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000017E0, 0x000017E8)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000017F0, 0x000017F8)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00006000, 0x00006060)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00006108, 0x00006110)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00006800, 0x00006ADC)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00007000, 0x000072DC)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00007800, 0x00007858)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00007900, 0x00007958)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00007B00, 0x00007B1C)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00007B80, 0x00007B9C)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00007C00, 0x00007C00)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00007D00, 0x00007D58)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00007E00, 0x00007E1C)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00008000, 32768)}
        };
        GT_U32  numOfChunks = sizeof(chunksMem)/sizeof(SMEM_CHUNK_BASIC_STC);
        smemInitMemChunk(devObjPtr,chunksMem, numOfChunks, unitPtr);
   }

    /*simulation defaults*/
    {
      static SMEM_REGISTER_DEFAULT_VALUE_STC myUnit_registersDefaultValueArr[] =
        {
          {DUMMY_NAME_PTR_CNS,           0x00000000,         0x0000ffff,      1,    0x4    }/*qfc_metal_fix*/
         ,{DUMMY_NAME_PTR_CNS,           0x00000004,         0x00001800,      1,    0x4    }/*Global_PFC_conf*/
         ,{DUMMY_NAME_PTR_CNS,           0x00000608,         0x0000007f,      1,    0x4    }/*Uburst_Event_FIFO_Min_Peak*/
         ,{DUMMY_NAME_PTR_CNS,           0x00006008,         0x0fffffff,      23,    0x4    }/*Port_HR_Counters_Threshold*/
         ,{DUMMY_NAME_PTR_CNS,           0x00006110,         0x0fffffff,      1,    0x4    }/*HR_Counter_Min_Peak*/
         ,{DUMMY_NAME_PTR_CNS,           0x00000800,         0x10000000,      3,    0x8    }/*manual entry in order to get 0 */
         ,{NULL,                         0,                  0x00000000,      0,    0x0  }
        };
      static SMEM_LINK_LIST_REGISTER_DEFAULT_VALUE_STC list = {myUnit_registersDefaultValueArr,NULL};
      unitPtr->unitDefaultRegistersPtr = &list;
    }

    SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->SIP6_TXQ_QFC[0].Counter_Table_1_Indirect_Read_Data    = 0x00000808;
    SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->SIP6_TXQ_QFC[0].Counter_Table_1_Indirect_Read_Address = 0x0000080C;
}

/**

* @internal smemAasUnitTxqPds function
* @endinternal
*
* @brief   Allocate address type specific memories -- for the txq pds unit
*/
static void smemAasUnitTxqPds
(
    IN SKERNEL_DEVICE_OBJECT *devObjPtr,
    IN SMEM_UNIT_CHUNKS_STC  *unitPtr
)
{
    SMEM_CHUNK_BASIC_STC  chunksMem[]=
    {
    {SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00000000, 392832)}
    ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00080000, 253952)}
    ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x000C0000, 63488)}
    ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x000D0000, 47104)}
    ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x000E0000, 8192)}
    ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x000E2000, 8192)}
    ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x000E4000, 8192)}
    ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x000E6000, 8192)}
    ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x000E8000, 8320)}
    ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x000EC000, 8320)}
    ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x000F0000, 32768)}
    ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x000F8000, 32768)}
    ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00100000, 16384)}
    ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00104000, 8320)}
    ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00108000, 8320)}
    ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x0010C000, 8192)}
    ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x0010E000, 8192)}
    ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00110000, 8192)}
    ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00130000, 8192)}
    ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00134000, 16384)}
    ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00140000, 65536)}
    ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00150000, 65536)}
    ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00160000, 65536)}
    ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00170000, 4096)}
    ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00180000, 0x0018006C)}
    ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00180080, 0x00180088)}
    ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00180200, 0x00180218)}
    ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00181000, 0x00181084)}
    ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x0018108C, 0x0018109C)}
    ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00181100, 0x00181144)}
    ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00183300, 0x0018330C)}
    ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00183400, 0x0018340C)}
    ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00183440, 0x0018344C)}
    ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00183480, 0x0018348C)}
    ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x001834C0, 0x001834CC)}
    ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00183500, 0x0018350C)}
    ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00183540, 0x0018354C)}
    ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00194000, 0x0019407C)}
    ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00194100, 0x0019417C)}
    ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00194200, 0x0019427C)}
    ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00194300, 0x0019437C)}
    ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00194400, 0x0019447C)}
    ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00194500, 0x0019457C)}
    ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00194600, 0x0019467C)}
    ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00194700, 0x0019477C)}
    ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00194800, 0x0019487C)}
    ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00194900, 0x0019497C)}
    ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00194A00, 0x00194A7C)}
    ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00196000, 0x00196058)}
    ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00196100, 0x00196158)}
    ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00196200, 0x00196258)}
    ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00196300, 0x00196358)}
    ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00196400, 0x00196458)}
    ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00196500, 0x00196558)}
    ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00196600, 0x00196658)}
    ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00196700, 0x00196758)}
    ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00196800, 0x00196858)}
    ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00196900, 0x00196958)}
    ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00198000, 0x00199BFC)}

    };
    GT_U32  numOfChunks = sizeof(chunksMem)/sizeof(SMEM_CHUNK_BASIC_STC);
    smemInitMemChunk(devObjPtr,chunksMem, numOfChunks, unitPtr);

    /*simulation defaults*/
    {
      static SMEM_REGISTER_DEFAULT_VALUE_STC myUnit_registersDefaultValueArr[] =
        {
         {DUMMY_NAME_PTR_CNS,           0x00180008,         0x00005f77,      1,    0x4    }/*Max_PDS_size_limit_for_pdx*/
        ,{DUMMY_NAME_PTR_CNS,           0x00180000,         0x0000ffff,      1,    0x4    }/*PDS_Metal_Fix*/
        ,{DUMMY_NAME_PTR_CNS,           0x00180004,         0x00000240,      1,    0x4    }/*Global_PDS_CFG*/
        ,{DUMMY_NAME_PTR_CNS,           0x0018002c,         0x00000022,      1,    0x4    }/*FIFOs_Limits*/
        ,{DUMMY_NAME_PTR_CNS,           0x0018000c,         0x00005fc7,      1,    0x4    }/*Max_PDS_size_limit_for_PB*/
        ,{DUMMY_NAME_PTR_CNS,           0x00180010,         0x00000800,      1,    0x4    }/*Max_Num_Of_Long_Queues*/
        ,{DUMMY_NAME_PTR_CNS,           0x00180014,         0x00000013,      1,    0x4    }/*Tail_Size_for_PB_Wr*/
        ,{DUMMY_NAME_PTR_CNS,           0x0018001c,         0x00000019,      1,    0x4    }/*PID_Empty_Limit_for_PDX*/
        ,{DUMMY_NAME_PTR_CNS,           0x00180020,         0x00000019,      1,    0x4    }/*PID_Empty_Limit_for_PB*/
        ,{DUMMY_NAME_PTR_CNS,           0x00180024,         0x00000011,      1,    0x4    }/*NEXT_Empty_Limit_for_PDX*/
        ,{DUMMY_NAME_PTR_CNS,           0x00180028,         0x00000011,      1,    0x4    }/*NEXT_Empty_Limit_for_PB*/
        ,{DUMMY_NAME_PTR_CNS,           0x00180034,         0x00003fef,      1,    0x4    }/*PB_Full_Limit*/
        ,{DUMMY_NAME_PTR_CNS,           0x00180038,         0x0000000c,      1,    0x4    }/*PB_Read_Req_FIFO_Limit*/
        ,{DUMMY_NAME_PTR_CNS,           0x00180044,         0x00000002,      1,    0x4    }/*message_fifo_spare_entries*/
        ,{DUMMY_NAME_PTR_CNS,           0x0018003c,         0x00000006,      1,    0x4    }/*RX_Frag_Attribute_FIFO_Limit*/
        ,{DUMMY_NAME_PTR_CNS,           0x00180084,         0x00000001,      1,    0x4    }/*RxQueue_ID*/
        ,{DUMMY_NAME_PTR_CNS,           0x00180018,         0x00000034,      1,    0x4    }/*Spillover_Frag_Size_Limits*/
        ,{DUMMY_NAME_PTR_CNS,           0x00180048,         0x0000000a,      1,    0x4    }/*Port_BC_FIFO_Size*/
        ,{DUMMY_NAME_PTR_CNS,           0x0018004c,         0x0000000a,      1,    0x4    }/*SDQ_Selection_Delay_Line_Size*/
        ,{DUMMY_NAME_PTR_CNS,           0x00180054,         0x00000008,      1,    0x4    }/*Frag_Target_Size*/
        ,{DUMMY_NAME_PTR_CNS,           0x00180058,         0x00000002,      1,    0x4    }/*Desc_In_Frag_Coefficient*/
        ,{DUMMY_NAME_PTR_CNS,           0x0018005c,         0x00005000,      1,    0x4    }/*PDS_Panic_Spillover*/
        ,{DUMMY_NAME_PTR_CNS,           0x00180040,         0x00000006,      1,    0x4    }/*TX_Frag_Attribute_FIFO_Limit*/
        ,{DUMMY_NAME_PTR_CNS,           0x00180060,         0x00000001,      1,    0x4    }/*Bypass_Enable*/
        ,{DUMMY_NAME_PTR_CNS,           0x00180064,         0x0000000f,      1,    0x4    }/*Bypass_FIFO_Limit*/
        ,{DUMMY_NAME_PTR_CNS,           0x00180068,         0x00000001,      1,    0x4    }/*Renaming_Enable*/
        ,{DUMMY_NAME_PTR_CNS,           0x0018006c,         0x0000000c,      1,    0x4    }/*Free_Queue_Limit*/
        ,{DUMMY_NAME_PTR_CNS,           0x00180204,         0x00000002,      1,    0x4    }/*PDS_Interrupt_Summary_Mask*/
        ,{DUMMY_NAME_PTR_CNS,           0x00181000,         0x0000001f,      1,    0x4    }/*Idle_Register*/
        ,{DUMMY_NAME_PTR_CNS,           0x00181030,         0x00003fff,      1,    0x4    }/*Free_Next_FIFO_Min_Peak*/
        ,{DUMMY_NAME_PTR_CNS,           0x00181038,         0x00007fff,      1,    0x4    }/*Free_PID_FIFO_Min_Peak*/
        ,{DUMMY_NAME_PTR_CNS,           0x0018108c,         0x000003ff,      1,    0x4    }/*FIFO_State_Latency_Min_Peak*/
        ,{DUMMY_NAME_PTR_CNS,           0x00181134,         0x00000fff,      1,    0x4    }/*Free_Queue_FIFO_Min_Peak*/
        ,{DUMMY_NAME_PTR_CNS,           0x00198400,         0x0000002a,      256,    0x4    }/*Profile_Long_Queue_Limit*/
        ,{DUMMY_NAME_PTR_CNS,           0x00198800,         0x00000026,      256,    0x4    }/*Profile_Head_Empty_Limit*/
        ,{DUMMY_NAME_PTR_CNS,           0x00198000,         0x00000001,      256,    0x4    }/*Profile_Long_Queue_Enable*/
        ,{DUMMY_NAME_PTR_CNS,           0x00183300,         0x00000005,      1,    0x4    }/*pds_debug_configurations*/
        ,{DUMMY_NAME_PTR_CNS,           0x00183308,         0xffffffff,      1,    0x4    }/*pds_debug_cycles_to_count_lsb*/
        ,{DUMMY_NAME_PTR_CNS,           0x0018330c,         0xffffffff,      1,    0x4    }/*pds_debug_cycles_to_count_msb*/
        ,{DUMMY_NAME_PTR_CNS,           0x00183508,         0x00000400,      1,    0x4    }/*pds_pb_write_req_count_type_ref*/
        ,{DUMMY_NAME_PTR_CNS,           0x0018350c,         0x00003c00,      1,    0x4    }/*pds_pb_write_req_count_type_mask*/
        ,{DUMMY_NAME_PTR_CNS,           0x00183548,         0x00000400,      1,    0x4    }/*pds_pb_read_req_count_type_ref*/
        ,{DUMMY_NAME_PTR_CNS,           0x0018354c,         0x00003c00,      1,    0x4    }/*pds_pb_read_req_count_type_mask*/
        ,{DUMMY_NAME_PTR_CNS,           0x00194800,         0x00000032,      32,    0x4    }/*Mailbox_Copy_Back_Requests_Limit*/
        ,{DUMMY_NAME_PTR_CNS,           0x00194900,         0x00000026,      32,    0x4    }/*Mailbox_NoDealloc*/
        ,{DUMMY_NAME_PTR_CNS,           0x00196200,         0x00000100,      23,    0x4    }/*Port_Average_BC*/
        ,{DUMMY_NAME_PTR_CNS,           0x00196400,         0x00080000,      23,    0x4    }/*Port_PB_Available_Threshold*/
        ,{DUMMY_NAME_PTR_CNS,           0x00196500,         0x00000008,      23,    0x4    }/*Port_PB_Size_Thresholds*/
        ,{DUMMY_NAME_PTR_CNS,           0x00196600,         0x00006000,      23,    0x4    }/*Port_PDS_Available_Threshold*/
        ,{DUMMY_NAME_PTR_CNS,           0x00196700,         0x00000008,      23,    0x4    }/*Port_PDS_Size_Thresholds*/
        ,{DUMMY_NAME_PTR_CNS,           0x00196800,         0x00000019,      23,    0x4    }/*Port_Frag_Spillover_Threshold*/
        ,{DUMMY_NAME_PTR_CNS,           0x00196900,         0x00000002,      23,    0x4    }/*Port_Head_Max_Factor*/
        ,{DUMMY_NAME_PTR_CNS,           0x00110000,         0x00000010,      2048,    0x4    }/*Desc_In_Frag*/
        ,{NULL,                         0,                  0x00000000,      0,    0x0  }
    };
      static SMEM_LINK_LIST_REGISTER_DEFAULT_VALUE_STC list = {myUnit_registersDefaultValueArr,NULL};
      unitPtr->unitDefaultRegistersPtr = &list;
    }
}

/**
* @internal smemAasUnitTxqSdq function
* @endinternal
*
* @brief   Allocate address type specific memories -- for the txq sdq unit
*/
static void smemAasUnitTxqSdq
(
    IN SKERNEL_DEVICE_OBJECT *devObjPtr,
    IN SMEM_UNIT_CHUNKS_STC  *unitPtr
)
{

    {
        START_BIND_UNIT_ACTIVE_MEM_MAC(devObjPtr,unitPtr)

        /* indirect     Config_Change_Time_Req */
        {0x00051478, SMEM_FULL_MASK_CNS, NULL, 0 , smemAasActiveWriteQbvConfigChangeTimeReq,0},

        END_BIND_UNIT_ACTIVE_MEM_MAC(devObjPtr,unitPtr)
    }
    {
        SMEM_CHUNK_BASIC_STC  chunksMem[]=
        {
          {SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000000, 0x00000004)}
         ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000200, 0x00000214)}
         ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000500, 0x0000055C)}
         ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000700, 0x00000758)}
         ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00040000, 0x00040058)}
         ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00040600, 0x00040658)}
         ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00040800, 0x00040858)}
         ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00050000, 0x00050058)}
         ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00050200, 0x00050258)}
         ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00050400, 0x00050458)}
         ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00050600, 0x00050658)}
         ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00050800, 0x00050858)}
         ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00051000, 0x00051058)}
         ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00051200, 0x00051258)}
         ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00051400, 0x00051404)}
         ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00051420, 0x00051424)}
         ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00051440, 0x00051444)}
         ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00051460, 0x00051478)}
         ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00051600, 0x00051658)}
         ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00051800, 0x00051858)}
         ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00060000, 24576)}
         ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000A0000, 0x000A000C)}
         ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000A0100, 0x000A0114)}
         ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000A0140, 0x000A014C)}
         ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000A0180, 0x000A018C)}
         ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000A01C0, 0x000A01CC)}
         ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x000C0000, 32768)}
         ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x000D0000, 16384)}
         ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x000D8000, 184)}
         ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x000D8200, 92)}
         ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x000D8600, 92)}
         ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000D9000, 0x000D9024)}
         ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000D9030, 0x000D9030)}
         ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000D9100, 0x000D910C)}
         ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00180000, 32768)}
         ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00190000, 0x001927FC)}
         ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00200000,32768),
            SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(40, 8),SMEM_BIND_TABLE_MAC(txqSdqSip7QueueToPortMap)}
       };

      GT_U32  numOfChunks = sizeof(chunksMem)/sizeof(SMEM_CHUNK_BASIC_STC);
      smemInitMemChunk(devObjPtr,chunksMem, numOfChunks, unitPtr);
    }

    {
        /*PortConfig*/
        {
            GT_U32  pt;
            for(pt = 0; pt <= RUNTIME_NUM_PORTS_PER_DP_UNIT; pt++)
            {
                /*0x00004000 + pt*0x4: where pt (0-56) represents PORT*/
                SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->SIP6_TXQ_SDQ[0].PortConfig.PortConfig[pt] =
                    0x00040000+ pt*0x4;


            }

        }
        /*QBV*/
        {
            GT_U32  pt;
            for(pt = 0; pt <= RUNTIME_NUM_PORTS_PER_DP_UNIT; pt++)
            {
                /*0x00005000+ pt*0x4: where pt (0-56) represents PORT*/
                SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->SIP6_TXQ_SDQ[0].QBV.qbvConfig[pt] =
                    0x00050000 + pt*0x4;
                /*0x00005200 + pt*0x4: where pt (0-56) represents PORT */
                SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->SIP6_TXQ_SDQ[0].QBV.portEgressTodOffset[pt] =
                    0x00050200 + pt*0x4;
                /*0x00005400 + pt*0x4: where pt (0-56) represents PORT*/
                SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->SIP6_TXQ_SDQ[0].QBV.portTableSetCycleTime[pt] =
                    0x00050400 + pt*0x4;

                /*0x00006000 + pt*0x4: where pt (0-56) represents PORT*/
                SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->SIP6_TXQ_SDQ[0].QBV.portQbvTableSet[pt] =
                    0x00051000 + pt*0x4;

                /*0x00006200 + pt*0x4: where pt (0-56) represents PORT*/
                SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->SIP6_TXQ_SDQ[0].QBV.portLengthAwrAttr[pt] =
                    0x00051200 + pt*0x4;

            }
            /*TXQ_SDQ/SDQ/QBV Configuration/Config Change Time Egress TOD Offset*/
            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->SIP6_TXQ_SDQ[0].QBV.configChangeTimeEgressTODOffset = 0x00051468;

            /*TXQ/<TXQ_SCN>TXQ_SCN_IP/<TXQ_SCN> TXQ_SDQ/SDQ/QBV Configuration/Config Change Time Cycle Time*/
            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->SIP6_TXQ_SDQ[0].QBV.configChangeTimeCycleTime = 0x00051464;

            for(pt = 0; pt <= RUNTIME_NUM_PORTS_PER_DP_UNIT/2; pt++)
            {
                /*0x00010000+ pt*0x4: where pt (0-28) represents  tableset first entry only*/
                SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->SIP6_TXQ_SDQ[0].QBV.portQbvConfTable[pt] =
                    0x00060000 + (pt*0x8*256);
            }
/*not implemented yet for AAS*/
#if 0
            for(pt = 0; pt <= RUNTIME_NUM_PORTS_PER_DP_UNIT ; pt++)
            {
                /*0x00001000 + q*0x4: where q (0-455) represents QUEUE*/
                SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->SIP6_TXQ_SDQ[0].Queue.queueConfig[pt] =
                    0x00010000 + (pt*0x4);
            }
#endif
        }
    }

    {
    static SMEM_REGISTER_DEFAULT_VALUE_STC myUnit_registersDefaultValueArr[] =
     {
          {DUMMY_NAME_PTR_CNS,           0x00000004,         0x00000046,      1,    0x4    }/*global_config*/
         ,{DUMMY_NAME_PTR_CNS,           0x00000000,         0x0000ffff,      1,    0x4    }/*SDQ_Metal_Fix*/
         ,{DUMMY_NAME_PTR_CNS,           0x00040000,         0x00000007,      23,    0x4    }/*Port_Config*/
         ,{DUMMY_NAME_PTR_CNS,           0x00000500,         0x00000003,      1,    0x4    }/*QCN_Config*/
         ,{DUMMY_NAME_PTR_CNS,           0x000d9000,         0x000003ff,      1,    0x4    }/*Sdq_Idle*/
         ,{DUMMY_NAME_PTR_CNS,           0x000a0000,         0x00000005,      1,    0x4    }/*debug_config*/
         ,{DUMMY_NAME_PTR_CNS,           0x000a0008,         0xffffffff,      1,    0x4    }/*debug_cycles_to_count_lsb*/
         ,{DUMMY_NAME_PTR_CNS,           0x000a000c,         0xffffffff,      1,    0x4    }/*debug_cycles_to_count_msb*/
         ,{DUMMY_NAME_PTR_CNS,           0x00051800,         0x00000007,      23,    0x4    }/*Port_Remain_Per_NS_Resolution*/
         ,{DUMMY_NAME_PTR_CNS,           0x000d0000,         0x00000381,      4096,    0x4    }/*queue_elig_state*/
         ,{NULL,                         0,                  0x00000000,      0,    0x0  }
     };
  static SMEM_LINK_LIST_REGISTER_DEFAULT_VALUE_STC list = {myUnit_registersDefaultValueArr,NULL};
  unitPtr->unitDefaultRegistersPtr = &list;
}

}

static void smemAasUnitTxqPsi
(
    IN SKERNEL_DEVICE_OBJECT *devObjPtr,
    IN SMEM_UNIT_CHUNKS_STC  *unitPtr
)
{
    SMEM_CHUNK_BASIC_STC  chunksMem[]=
    {
         /*PSI_REG*/
         {SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00000000, 524288)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00080000, 0x00080004)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00080180, 0x000801FC)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x0008020C, 0x00080214)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x0008022C, 0x00080230)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00080238, 0x0008023C)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00080400, 0x00080BFC)}


#define AAS_PSI_SCHED_OFFSET         (GT_U32)0x00100000

         /*PDQ*/
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (AAS_PSI_SCHED_OFFSET+0x00000028,AAS_PSI_SCHED_OFFSET+0x0000002C)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (AAS_PSI_SCHED_OFFSET+0x00000038,AAS_PSI_SCHED_OFFSET+0x0000003C)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (AAS_PSI_SCHED_OFFSET+0x00000048,AAS_PSI_SCHED_OFFSET+0x0000004C)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (AAS_PSI_SCHED_OFFSET+0x00000050,AAS_PSI_SCHED_OFFSET+0x00000054)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (AAS_PSI_SCHED_OFFSET+0x00000080,AAS_PSI_SCHED_OFFSET+0x00000084)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (AAS_PSI_SCHED_OFFSET+0x00000100,AAS_PSI_SCHED_OFFSET+0x00000104)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (AAS_PSI_SCHED_OFFSET+0x00000108,AAS_PSI_SCHED_OFFSET+0x0000010C)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (AAS_PSI_SCHED_OFFSET+0x00000110,AAS_PSI_SCHED_OFFSET+0x00000114)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (AAS_PSI_SCHED_OFFSET+0x00000120,AAS_PSI_SCHED_OFFSET+0x00000124)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (AAS_PSI_SCHED_OFFSET+0x00000128,AAS_PSI_SCHED_OFFSET+0x0000012C)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (AAS_PSI_SCHED_OFFSET+0x00000130,AAS_PSI_SCHED_OFFSET+0x00000134)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (AAS_PSI_SCHED_OFFSET+0x00000140,AAS_PSI_SCHED_OFFSET+0x00000144)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (AAS_PSI_SCHED_OFFSET+0x00000148,AAS_PSI_SCHED_OFFSET+0x0000014C)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (AAS_PSI_SCHED_OFFSET+0x00000150,AAS_PSI_SCHED_OFFSET+0x00000154)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (AAS_PSI_SCHED_OFFSET+0x00000160,AAS_PSI_SCHED_OFFSET+0x00000164)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (AAS_PSI_SCHED_OFFSET+0x00000168,AAS_PSI_SCHED_OFFSET+0x0000016C)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (AAS_PSI_SCHED_OFFSET+0x00000170,AAS_PSI_SCHED_OFFSET+0x00000174)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (AAS_PSI_SCHED_OFFSET+0x00000180,AAS_PSI_SCHED_OFFSET+0x00000184)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (AAS_PSI_SCHED_OFFSET+0x00000188,AAS_PSI_SCHED_OFFSET+0x0000018C)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (AAS_PSI_SCHED_OFFSET+0x00000190,AAS_PSI_SCHED_OFFSET+0x00000194)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (AAS_PSI_SCHED_OFFSET+0x00000200,AAS_PSI_SCHED_OFFSET+0x00000204)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (AAS_PSI_SCHED_OFFSET+0x00000208,AAS_PSI_SCHED_OFFSET+0x0000020C)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (AAS_PSI_SCHED_OFFSET+0x00000210,AAS_PSI_SCHED_OFFSET+0x00000214)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (AAS_PSI_SCHED_OFFSET+0x00000218,AAS_PSI_SCHED_OFFSET+0x0000021C)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (AAS_PSI_SCHED_OFFSET+0x00000220,AAS_PSI_SCHED_OFFSET+0x00000224)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (AAS_PSI_SCHED_OFFSET+0x00000320,AAS_PSI_SCHED_OFFSET+0x00000324)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (AAS_PSI_SCHED_OFFSET+0x00000800, 1024)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (AAS_PSI_SCHED_OFFSET+0x00000C00, 1024)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (AAS_PSI_SCHED_OFFSET+0x00001000, 1024)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (AAS_PSI_SCHED_OFFSET+0x00001800, 512)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (AAS_PSI_SCHED_OFFSET+0x00002000, 4096)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (AAS_PSI_SCHED_OFFSET+0x00003000, 4096)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (AAS_PSI_SCHED_OFFSET+0x00004000, 4096)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (AAS_PSI_SCHED_OFFSET+0x00005000, 4096)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (AAS_PSI_SCHED_OFFSET+0x00008000, 32768)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (AAS_PSI_SCHED_OFFSET+0x00010000, 32768)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (AAS_PSI_SCHED_OFFSET+0x00018000, 32768)}

        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (AAS_PSI_SCHED_OFFSET+0x00020000, 8)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (AAS_PSI_SCHED_OFFSET+0x00020400, 8)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (AAS_PSI_SCHED_OFFSET+0x00020800, 8)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (AAS_PSI_SCHED_OFFSET+0x00020840, 16)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (AAS_PSI_SCHED_OFFSET+0x00020880,AAS_PSI_SCHED_OFFSET+0x00020884)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (AAS_PSI_SCHED_OFFSET+0x00020890,AAS_PSI_SCHED_OFFSET+0x00020894)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (AAS_PSI_SCHED_OFFSET+0x00020900, 8)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (AAS_PSI_SCHED_OFFSET+0x00020908, 8)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (AAS_PSI_SCHED_OFFSET+0x00020910, 8)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (AAS_PSI_SCHED_OFFSET+0x00020918, 8)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (AAS_PSI_SCHED_OFFSET+0x00020C00, 8)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (AAS_PSI_SCHED_OFFSET+0x00021000, 8)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (AAS_PSI_SCHED_OFFSET+0x00021400, 8)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (AAS_PSI_SCHED_OFFSET+0x00021408, 8)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (AAS_PSI_SCHED_OFFSET+0x00021410, 8)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (AAS_PSI_SCHED_OFFSET+0x00021480,AAS_PSI_SCHED_OFFSET+0x00021484)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (AAS_PSI_SCHED_OFFSET+0x00021600, 8)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (AAS_PSI_SCHED_OFFSET+0x00021608, 8)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (AAS_PSI_SCHED_OFFSET+0x00021610, 8)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (AAS_PSI_SCHED_OFFSET+0x00021618, 8)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (AAS_PSI_SCHED_OFFSET+0x00021800, 8)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (AAS_PSI_SCHED_OFFSET+0x00022000, 8)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (AAS_PSI_SCHED_OFFSET+0x00022800, 8)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (AAS_PSI_SCHED_OFFSET+0x00022808, 8)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (AAS_PSI_SCHED_OFFSET+0x00022810, 8)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (AAS_PSI_SCHED_OFFSET+0x00022818, 8)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (AAS_PSI_SCHED_OFFSET+0x00022820, 8)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (AAS_PSI_SCHED_OFFSET+0x00022880,AAS_PSI_SCHED_OFFSET+0x00022884)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (AAS_PSI_SCHED_OFFSET+0x00022900, 8)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (AAS_PSI_SCHED_OFFSET+0x00022908, 8)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (AAS_PSI_SCHED_OFFSET+0x00022910, 8)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (AAS_PSI_SCHED_OFFSET+0x00022918, 8)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (AAS_PSI_SCHED_OFFSET+0x00024000, 8)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (AAS_PSI_SCHED_OFFSET+0x00026000, 8)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (AAS_PSI_SCHED_OFFSET+0x00028000, 8)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (AAS_PSI_SCHED_OFFSET+0x00028100, 8)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (AAS_PSI_SCHED_OFFSET+0x00028108, 8)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (AAS_PSI_SCHED_OFFSET+0x00028110, 8)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (AAS_PSI_SCHED_OFFSET+0x00028118, 8)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (AAS_PSI_SCHED_OFFSET+0x00028120, 8)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (AAS_PSI_SCHED_OFFSET+0x00028128, 8)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (AAS_PSI_SCHED_OFFSET+0x00028180,AAS_PSI_SCHED_OFFSET+0x00028184)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (AAS_PSI_SCHED_OFFSET+0x00028200, 8)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (AAS_PSI_SCHED_OFFSET+0x00028208, 8)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (AAS_PSI_SCHED_OFFSET+0x00028210, 8)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (AAS_PSI_SCHED_OFFSET+0x00028218, 8)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (AAS_PSI_SCHED_OFFSET+0x00029000, 8)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (AAS_PSI_SCHED_OFFSET+0x00029200, 8)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (AAS_PSI_SCHED_OFFSET+0x00029208, 8)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (AAS_PSI_SCHED_OFFSET+0x00029210, 8)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (AAS_PSI_SCHED_OFFSET+0x00029218, 8)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (AAS_PSI_SCHED_OFFSET+0x00029220, 8)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (AAS_PSI_SCHED_OFFSET+0x00029228, 8)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (AAS_PSI_SCHED_OFFSET+0x0002A000, 8)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (AAS_PSI_SCHED_OFFSET+0x0002A078, 8)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (AAS_PSI_SCHED_OFFSET+0x0002A080, 8)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (AAS_PSI_SCHED_OFFSET+0x0002A0F8, 8)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (AAS_PSI_SCHED_OFFSET+0x0002A100, 8)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (AAS_PSI_SCHED_OFFSET+0x0002A1F8, 8)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (AAS_PSI_SCHED_OFFSET+0x0002A200, 8)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (AAS_PSI_SCHED_OFFSET+0x0002A3F8, 8)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (AAS_PSI_SCHED_OFFSET+0x0002A400, 8)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (AAS_PSI_SCHED_OFFSET+0x0002A7F8, 8)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (AAS_PSI_SCHED_OFFSET+0x0002C000, 64)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (AAS_PSI_SCHED_OFFSET+0x0002C040,AAS_PSI_SCHED_OFFSET+0x0002C044)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (AAS_PSI_SCHED_OFFSET+0x00030000, 8)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (AAS_PSI_SCHED_OFFSET+0x00040000, 262144)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (AAS_PSI_SCHED_OFFSET+0x00080000, 262144)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (AAS_PSI_SCHED_OFFSET+0x000C0000, 262144)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (AAS_PSI_SCHED_OFFSET+0x00100000, 524288)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (AAS_PSI_SCHED_OFFSET+0x00180000, 524288)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (AAS_PSI_SCHED_OFFSET+0x00200000, 524288)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (AAS_PSI_SCHED_OFFSET+0x00280000, 131072)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (AAS_PSI_SCHED_OFFSET+0x002A0000, 131072)}
        ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (AAS_PSI_SCHED_OFFSET+0x002C0000, 131072)}
     };

     GT_U32  numOfChunks = sizeof(chunksMem)/sizeof(SMEM_CHUNK_BASIC_STC);
     smemInitMemChunk(devObjPtr,chunksMem, numOfChunks, unitPtr);

     {
        static SMEM_REGISTER_DEFAULT_VALUE_STC myUnit_registersDefaultValueArr[] =
        {

         {DUMMY_NAME_PTR_CNS,           0x00080180,         0x00000010,      32,    0x4    }/*Credit_Value*/
        ,{DUMMY_NAME_PTR_CNS,           0x00080004,         0x0000ffff,      1,    0x4    }/*PSI_Metal_Fix_Register*/
        ,{DUMMY_NAME_PTR_CNS,           0x00080000,         0x00000003,      1,    0x4    }/*Psi_Idle*/

        ,{DUMMY_NAME_PTR_CNS,           0x00000320+AAS_PSI_SCHED_OFFSET,         0x00000000,      1,    0x8    }/*Port_Pizza_Last_Slice*/
        ,{DUMMY_NAME_PTR_CNS,           0x00000028+AAS_PSI_SCHED_OFFSET,         0x00001033,      1,    0x8    }/*Identity_Addr*/
        ,{DUMMY_NAME_PTR_CNS,           0x00000038+AAS_PSI_SCHED_OFFSET,         0x04081020,      1,    0x8    }/*ScrubSlots_Addr*/
        /**/,{DUMMY_NAME_PTR_CNS,           0x0000003c+AAS_PSI_SCHED_OFFSET,         0x00000004,      1,    0x8    }/*ScrubSlots_Addr*/
        ,{DUMMY_NAME_PTR_CNS,           0x00000048+AAS_PSI_SCHED_OFFSET,         0x00000001,      1,    0x8    }/*TreeDeqEn_Addr*/
        ,{DUMMY_NAME_PTR_CNS,           0x00000050+AAS_PSI_SCHED_OFFSET,         0x00000000,      1,    0x8    }/*PDWRREnReg*/
        ,{DUMMY_NAME_PTR_CNS,           0x00000180+AAS_PSI_SCHED_OFFSET,         0x00a00000,      1,    0x8    }/*PPerCtlConf_Addr*/
        ,{DUMMY_NAME_PTR_CNS,           0x00000188+AAS_PSI_SCHED_OFFSET,         0x066f0002,      1,    0x8    }/*PPerRateShap_Addr*/
        /**/,{DUMMY_NAME_PTR_CNS,           0x0000018c+AAS_PSI_SCHED_OFFSET,         0x0000016e,      1,    0x8    }/*PPerRateShap_Addr*/
        ,{DUMMY_NAME_PTR_CNS,           0x00000160+AAS_PSI_SCHED_OFFSET,         0x0e390000,      1,    0x8    }/*CPerCtlConf_Addr*/
        ,{DUMMY_NAME_PTR_CNS,           0x00000168+AAS_PSI_SCHED_OFFSET,         0x066f0002,      1,    0x8    }/*CPerRateShap_Addr*/
        /**/,{DUMMY_NAME_PTR_CNS,           0x0000016c+AAS_PSI_SCHED_OFFSET,         0x0000016e,      1,    0x8    }/*CPerRateShap_Addr*/
        ,{DUMMY_NAME_PTR_CNS,           0x00000140+AAS_PSI_SCHED_OFFSET,         0x0e390000,      1,    0x8    }/*BPerCtlConf_Addr*/
        ,{DUMMY_NAME_PTR_CNS,           0x00000148+AAS_PSI_SCHED_OFFSET,         0x066f0002,      1,    0x8    }/*BPerRateShap_Addr*/
        /**/,{DUMMY_NAME_PTR_CNS,           0x0000014c+AAS_PSI_SCHED_OFFSET,         0x0000016e,      1,    0x8    }/*BPerRateShap_Addr*/
        ,{DUMMY_NAME_PTR_CNS,           0x00000120+AAS_PSI_SCHED_OFFSET,         0x0e390000,      1,    0x8    }/*APerCtlConf_Addr*/
        ,{DUMMY_NAME_PTR_CNS,           0x00000128+AAS_PSI_SCHED_OFFSET,         0x066f0002,      1,    0x8    }/*APerRateShap_Addr*/
        /**/,{DUMMY_NAME_PTR_CNS,           0x0000012c+AAS_PSI_SCHED_OFFSET,         0x0000016e,      1,    0x8    }/*APerRateShap_Addr*/
        ,{DUMMY_NAME_PTR_CNS,           0x00000100+AAS_PSI_SCHED_OFFSET,         0x0e390000,      1,    0x8    }/*QPerCtlConf_Addr*/
        ,{DUMMY_NAME_PTR_CNS,           0x00000108+AAS_PSI_SCHED_OFFSET,         0x066f0002,      1,    0x8    }/*QPerRateShap_Addr*/
        /**/,{DUMMY_NAME_PTR_CNS,           0x0000010c+AAS_PSI_SCHED_OFFSET,         0x0000016e,      1,    0x8    }/*QPerRateShap_Addr*/
        ,{DUMMY_NAME_PTR_CNS,           0x00000080+AAS_PSI_SCHED_OFFSET,         0x00000000,      1,    0x8    }/*Global_Cfg*/
        ,{DUMMY_NAME_PTR_CNS,           0x00000190+AAS_PSI_SCHED_OFFSET,         0x00000001,      1,    0x8    }/*PPerRateShapInt_Addr*/
        /**/,{DUMMY_NAME_PTR_CNS,           0x00000194+AAS_PSI_SCHED_OFFSET,         0x00000001,      1,    0x8    }/*PPerRateShapInt_Addr*/
        ,{DUMMY_NAME_PTR_CNS,           0x00000170+AAS_PSI_SCHED_OFFSET,         0x00000001,      1,    0x8    }/*CPerRateShapInt_Addr*/
        /**/,{DUMMY_NAME_PTR_CNS,           0x00000174+AAS_PSI_SCHED_OFFSET,         0x00000001,      1,    0x8    }/*CPerRateShapInt_Addr*/
        ,{DUMMY_NAME_PTR_CNS,           0x00000150+AAS_PSI_SCHED_OFFSET,         0x00000001,      1,    0x8    }/*BPerRateShapInt_Addr*/
        /**/,{DUMMY_NAME_PTR_CNS,           0x00000154+AAS_PSI_SCHED_OFFSET,         0x00000001,      1,    0x8    }/*BPerRateShapInt_Addr*/
        ,{DUMMY_NAME_PTR_CNS,           0x00000130+AAS_PSI_SCHED_OFFSET,         0x00000001,      1,    0x8    }/*APerRateShapInt_Addr*/
        /**/,{DUMMY_NAME_PTR_CNS,           0x00000134+AAS_PSI_SCHED_OFFSET,         0x00000001,      1,    0x8    }/*APerRateShapInt_Addr*/
        ,{DUMMY_NAME_PTR_CNS,           0x00000110+AAS_PSI_SCHED_OFFSET,         0x00000001,      1,    0x8    }/*QPerRateShapInt_Addr*/
        /**/,{DUMMY_NAME_PTR_CNS,           0x00000114+AAS_PSI_SCHED_OFFSET,         0x00000001,      1,    0x8    }/*QPerRateShapInt_Addr*/
        ,{DUMMY_NAME_PTR_CNS,           0x00000200+AAS_PSI_SCHED_OFFSET,         0x00000000,      1,    0x8    }/*ErrorStatus_Addr*/
        ,{DUMMY_NAME_PTR_CNS,           0x00000208+AAS_PSI_SCHED_OFFSET,         0x00000000,      1,    0x8    }/*FirstExcp_Addr*/
        ,{DUMMY_NAME_PTR_CNS,           0x00000210+AAS_PSI_SCHED_OFFSET,         0x00000000,      1,    0x8    }/*ErrCnt_Addr*/
        ,{DUMMY_NAME_PTR_CNS,           0x00000218+AAS_PSI_SCHED_OFFSET,         0x00000000,      1,    0x8    }/*ExcpCnt_Addr*/
        ,{DUMMY_NAME_PTR_CNS,           0x00000220+AAS_PSI_SCHED_OFFSET,         0x00000037,      1,    0x8    }/*ExcpMask_Addr*/
        /**/,{DUMMY_NAME_PTR_CNS,           0x00000224+AAS_PSI_SCHED_OFFSET,         0x0000ffff,      1,    0x8    }/*ExcpMask_Addr*/
        ,{DUMMY_NAME_PTR_CNS,           0x0002c040+AAS_PSI_SCHED_OFFSET,         0x00000000,      1,    0x8    }/*Debug_Read_index*/
        ,{DUMMY_NAME_PTR_CNS,           0x00020880+AAS_PSI_SCHED_OFFSET,         0x0000007f,      1,    0x8    }/*Plast_Addr*/
        ,{DUMMY_NAME_PTR_CNS,           0x00020890+AAS_PSI_SCHED_OFFSET,         0x00000000,      1,    0x8    }/*PPerStatus_Addr*/
        ,{DUMMY_NAME_PTR_CNS,           0x00021480+AAS_PSI_SCHED_OFFSET,         0x00000000,      1,    0x8    }/*CPerStatus_Addr*/
        ,{DUMMY_NAME_PTR_CNS,           0x00022880+AAS_PSI_SCHED_OFFSET,         0x00000000,      1,    0x8    }/*BPerStatus_Addr*/
        ,{DUMMY_NAME_PTR_CNS,           0x00028180+AAS_PSI_SCHED_OFFSET,         0x00000000,      1,    0x8    }/*APerStatus_Addr*/
        ,{DUMMY_NAME_PTR_CNS,           0x00005000+AAS_PSI_SCHED_OFFSET,         0x00200020,      512,    0x8    }/*PortEligPrioFunc_Entry*/
        /**/,{DUMMY_NAME_PTR_CNS,           0x00005004+AAS_PSI_SCHED_OFFSET,         0x00200020,      512,    0x8    }/*PortEligPrioFunc_Entry*/
        ,{DUMMY_NAME_PTR_CNS,           0x00002000+AAS_PSI_SCHED_OFFSET,         0x01000100,      513,    0x8    }/*ClvlEligPrioFunc_Entry*/
        /**/,{DUMMY_NAME_PTR_CNS,           0x00002004+AAS_PSI_SCHED_OFFSET,         0x01000100,      513,    0x8    }/*ClvlEligPrioFunc_Entry*/
        ,{DUMMY_NAME_PTR_CNS,           0x00003000+AAS_PSI_SCHED_OFFSET,         0x01000100,      513,    0x8    }/*BlvlEligPrioFunc_Entry*/
        /**/,{DUMMY_NAME_PTR_CNS,           0x00003004+AAS_PSI_SCHED_OFFSET,         0x01000100,      513,    0x8    }/*BlvlEligPrioFunc_Entry*/
        ,{DUMMY_NAME_PTR_CNS,           0x00004000+AAS_PSI_SCHED_OFFSET,         0x01000100,      513,    0x8    }/*AlvlEligPrioFunc_Entry*/
        /**/,{DUMMY_NAME_PTR_CNS,           0x00004004+AAS_PSI_SCHED_OFFSET,         0x01000100,      513,    0x8    }/*AlvlEligPrioFunc_Entry*/
        ,{DUMMY_NAME_PTR_CNS,           0x00001800+AAS_PSI_SCHED_OFFSET,         0x01000100,      64,    0x8    }/*QueueEligPrioFunc*/
        /**/,{DUMMY_NAME_PTR_CNS,           0x00001804+AAS_PSI_SCHED_OFFSET,         0x01000100,      64,    0x8    }/*QueueEligPrioFunc*/

        ,{DUMMY_NAME_PTR_CNS,           0x00000c00+AAS_PSI_SCHED_OFFSET,         0x00001010,      128,    0x8    }/*PortQuantumsPriosLo*/
        ,{DUMMY_NAME_PTR_CNS,           0x00000800+AAS_PSI_SCHED_OFFSET,         0x00000000,      73,    0x8    }/*PortRangeMap*/
        ,{DUMMY_NAME_PTR_CNS,           0x00001000+AAS_PSI_SCHED_OFFSET,         0x03ffffff,      128,    0x8    }/*PlvlTokenBucketMapping*/
        /**/,{DUMMY_NAME_PTR_CNS,           0x00001004+AAS_PSI_SCHED_OFFSET,         0x3fffffc0,      128,    0x8    }/*PlvlTokenBucketMapping*/
        ,{DUMMY_NAME_PTR_CNS,           0x00100000+AAS_PSI_SCHED_OFFSET,         0x00000000,      65536,    0x8    }/*Queuemapping*/
        ,{DUMMY_NAME_PTR_CNS,           0x00180000+AAS_PSI_SCHED_OFFSET,         0x03ffffff,      65536,    0x8    }/*QueueTokenBucketTokenEnDiv*/
        /**/,{DUMMY_NAME_PTR_CNS,           0x00180004+AAS_PSI_SCHED_OFFSET,         0x3fffffc0,      65536,    0x8    }/*QueueTokenBucketTokenEnDiv*/
        ,{DUMMY_NAME_PTR_CNS,           0x00200000+AAS_PSI_SCHED_OFFSET,         0x00001040,      4096,    0x8    }/*QueueQuantum*/
        ,{DUMMY_NAME_PTR_CNS,           0x00080000+AAS_PSI_SCHED_OFFSET,         0x03ffffff,      32768,    0x8    }/*AlvlTokenBucketMapping*/
        /**/,{DUMMY_NAME_PTR_CNS,           0x00080004+AAS_PSI_SCHED_OFFSET,         0x3fffffc0,      32768,    0x8    }/*AlvlTokenBucketMapping*/
        ,{DUMMY_NAME_PTR_CNS,           0x000c0000+AAS_PSI_SCHED_OFFSET,         0x00001040,      4096,    0x8    }/*AlvlQuantum*/
        ,{DUMMY_NAME_PTR_CNS,           0x00040000+AAS_PSI_SCHED_OFFSET,         0x00000000,      32768,    0x8    }/*ALvltoBlvlAndQueueRangeMap*/
        ,{DUMMY_NAME_PTR_CNS,           0x002a0000+AAS_PSI_SCHED_OFFSET,         0x03ffffff,      32768,    0x8    }/*BlvlTokenBucketMapping*/
        /**/,{DUMMY_NAME_PTR_CNS,           0x002a0004+AAS_PSI_SCHED_OFFSET,         0x3fffffc0,      32768,    0x8    }/*BlvlTokenBucketMapping*/
        ,{DUMMY_NAME_PTR_CNS,           0x002c0000+AAS_PSI_SCHED_OFFSET,         0x00001040,      4096,    0x8    }/*BlvlQuantum*/
        ,{DUMMY_NAME_PTR_CNS,           0x00280000+AAS_PSI_SCHED_OFFSET,         0x00000000,      16384,    0x8    }/*BLvltoClvlAndAlvlRangeMap*/
        ,{DUMMY_NAME_PTR_CNS,           0x00018000+AAS_PSI_SCHED_OFFSET,         0x03ffffff,      4096,    0x8    }/*ClvlTokenBucketMapping*/
        /**/,{DUMMY_NAME_PTR_CNS,           0x00018004+AAS_PSI_SCHED_OFFSET,         0x3fffffc0,      4096,    0x8    }/*ClvlTokenBucketMapping*/
        ,{DUMMY_NAME_PTR_CNS,           0x00010000+AAS_PSI_SCHED_OFFSET,         0x00001040,      4096,    0x8    }/*ClvlQuantum*/
        ,{DUMMY_NAME_PTR_CNS,           0x00008000+AAS_PSI_SCHED_OFFSET,         0x00000000,      4096,    0x8    }/*ClvltoPortAndBlvlRangeMap*/
        ,{DUMMY_NAME_PTR_CNS,           0x0002a078+AAS_PSI_SCHED_OFFSET,         0x003fffff,      1,    0x8    }/*PortShpBucketLvls*/
        /**/,{DUMMY_NAME_PTR_CNS,           0x0002a07c+AAS_PSI_SCHED_OFFSET,         0x003fffff,      1,    0x8    }/*PortShpBucketLvls*/
        ,{DUMMY_NAME_PTR_CNS,           0x0002a000+AAS_PSI_SCHED_OFFSET,         0xffffffff,      1,    0x8    }/*PortShaperBucketNeg*/
        /**/,{DUMMY_NAME_PTR_CNS,           0x0002a004+AAS_PSI_SCHED_OFFSET,         0xffffffff,      1,    0x8    }/*PortShaperBucketNeg*/
        ,{DUMMY_NAME_PTR_CNS,           0x0002a0f8+AAS_PSI_SCHED_OFFSET,         0x003fffff,      1,    0x8    }/*ClvlShpBucketLvls*/
        /**/,{DUMMY_NAME_PTR_CNS,           0x0002a0fc+AAS_PSI_SCHED_OFFSET,         0x003fffff,      1,    0x8    }/*ClvlShpBucketLvls*/
        ,{DUMMY_NAME_PTR_CNS,           0x0002a080+AAS_PSI_SCHED_OFFSET,         0xffffffff,      1,    0x8    }/*CLevelShaperBucketNeg*/
        /**/,{DUMMY_NAME_PTR_CNS,           0x0002a084+AAS_PSI_SCHED_OFFSET,         0xffffffff,      1,    0x8    }/*CLevelShaperBucketNeg*/
        ,{DUMMY_NAME_PTR_CNS,           0x0002a1f8+AAS_PSI_SCHED_OFFSET,         0x003fffff,      1,    0x8    }/*BlvlShpBucketLvls*/
        /**/,{DUMMY_NAME_PTR_CNS,           0x0002a1fc+AAS_PSI_SCHED_OFFSET,         0x003fffff,      1,    0x8    }/*BlvlShpBucketLvls*/
        ,{DUMMY_NAME_PTR_CNS,           0x0002a100+AAS_PSI_SCHED_OFFSET,         0xffffffff,      1,    0x8    }/*BLevelShaperBucketNeg*/
        /**/,{DUMMY_NAME_PTR_CNS,           0x0002a104+AAS_PSI_SCHED_OFFSET,         0xffffffff,      1,    0x8    }/*BLevelShaperBucketNeg*/
        ,{DUMMY_NAME_PTR_CNS,           0x0002a3f8+AAS_PSI_SCHED_OFFSET,         0x003fffff,      1,    0x8    }/*AlvlShpBucketLvls*/
        /**/,{DUMMY_NAME_PTR_CNS,           0x0002a3fc+AAS_PSI_SCHED_OFFSET,         0x003fffff,      1,    0x8    }/*AlvlShpBucketLvls*/
        ,{DUMMY_NAME_PTR_CNS,           0x0002a200+AAS_PSI_SCHED_OFFSET,         0xffffffff,      1,    0x8    }/*ALevelShaperBucketNeg*/
        /**/,{DUMMY_NAME_PTR_CNS,           0x0002a204+AAS_PSI_SCHED_OFFSET,         0xffffffff,      1,    0x8    }/*ALevelShaperBucketNeg*/
        ,{DUMMY_NAME_PTR_CNS,           0x0002a7f8+AAS_PSI_SCHED_OFFSET,         0x003fffff,      1,    0x8    }/*QueueShpBucketLvls*/
        /**/,{DUMMY_NAME_PTR_CNS,           0x0002a7fc+AAS_PSI_SCHED_OFFSET,         0x003fffff,      1,    0x8    }/*QueueShpBucketLvls*/
        ,{DUMMY_NAME_PTR_CNS,           0x0002a400+AAS_PSI_SCHED_OFFSET,         0xffffffff,      1,    0x8    }/*QueueShaperBucketNeg*/
        /**/,{DUMMY_NAME_PTR_CNS,           0x0002a404+AAS_PSI_SCHED_OFFSET,         0xffffffff,      1,    0x8    }/*QueueShaperBucketNeg*/
        ,{DUMMY_NAME_PTR_CNS,           0x00020000+AAS_PSI_SCHED_OFFSET,         0x00000002,      1,    0x8    }/*PortNodeState*/
        ,{DUMMY_NAME_PTR_CNS,           0x00020400+AAS_PSI_SCHED_OFFSET,         0x00000000,      1,    0x8    }/*PortMyQ*/
        ,{DUMMY_NAME_PTR_CNS,           0x00020900+AAS_PSI_SCHED_OFFSET,         0x0000ffff,      1,    0x8    }/*PortRRDWRRStatus01*/
        ,{DUMMY_NAME_PTR_CNS,           0x00020908+AAS_PSI_SCHED_OFFSET,         0x0000ffff,      1,    0x8    }/*PortRRDWRRStatus23*/
        ,{DUMMY_NAME_PTR_CNS,           0x00020910+AAS_PSI_SCHED_OFFSET,         0x0000ffff,      1,    0x8    }/*PortRRDWRRStatus45*/
        ,{DUMMY_NAME_PTR_CNS,           0x00020918+AAS_PSI_SCHED_OFFSET,         0x0000ffff,      1,    0x8    }/*PortRRDWRRStatus67*/
        ,{DUMMY_NAME_PTR_CNS,           0x00020800+AAS_PSI_SCHED_OFFSET,         0x00000000,      1,    0x8    }/*PortWFS*/
        ,{DUMMY_NAME_PTR_CNS,           0x00020840+AAS_PSI_SCHED_OFFSET,         0x00000000,      2,    0x8    }/*PortBPFromQMgr*/
        ,{DUMMY_NAME_PTR_CNS,           0x00030000+AAS_PSI_SCHED_OFFSET,         0x00000002,      1,    0x8    }/*QueueNodeState*/
        ,{DUMMY_NAME_PTR_CNS,           0x00029000+AAS_PSI_SCHED_OFFSET,         0x00000000,      1,    0x8    }/*QueueWFS*/
        ,{DUMMY_NAME_PTR_CNS,           0x00029200+AAS_PSI_SCHED_OFFSET,         0x00040000,      1,    0x8    }/*QueueL0ClusterStateLo*/
        ,{DUMMY_NAME_PTR_CNS,           0x00029208+AAS_PSI_SCHED_OFFSET,         0x00040000,      1,    0x8    }/*QueueL0ClusterStateHi*/
        ,{DUMMY_NAME_PTR_CNS,           0x00029210+AAS_PSI_SCHED_OFFSET,         0x00040000,      1,    0x8    }/*QueueL1ClusterStateLo*/
        ,{DUMMY_NAME_PTR_CNS,           0x00029218+AAS_PSI_SCHED_OFFSET,         0x00040000,      1,    0x8    }/*QueueL1ClusterStateHi*/
        ,{DUMMY_NAME_PTR_CNS,           0x00029220+AAS_PSI_SCHED_OFFSET,         0x00040000,      1,    0x8    }/*QueueL2ClusterStateLo*/
        ,{DUMMY_NAME_PTR_CNS,           0x00029228+AAS_PSI_SCHED_OFFSET,         0x00040000,      1,    0x8    }/*QueueL2ClusterStateHi*/
        ,{DUMMY_NAME_PTR_CNS,           0x0002c000+AAS_PSI_SCHED_OFFSET,         0x00000000,      8,    0x8    }/*QueuePerStatus*/
        ,{DUMMY_NAME_PTR_CNS,           0x00020c00+AAS_PSI_SCHED_OFFSET,         0x00000002,      1,    0x8    }/*ClvlNodeState*/
        ,{DUMMY_NAME_PTR_CNS,           0x00021000+AAS_PSI_SCHED_OFFSET,         0x00000000,      1,    0x8    }/*ClvlMyQ*/
        ,{DUMMY_NAME_PTR_CNS,           0x00021600+AAS_PSI_SCHED_OFFSET,         0x0fffffff,      1,    0x8    }/*ClvlRRDWRRStatus01*/
        ,{DUMMY_NAME_PTR_CNS,           0x00021608+AAS_PSI_SCHED_OFFSET,         0x0fffffff,      1,    0x8    }/*ClvlRRDWRRStatus23*/
        ,{DUMMY_NAME_PTR_CNS,           0x00021610+AAS_PSI_SCHED_OFFSET,         0x0fffffff,      1,    0x8    }/*ClvlRRDWRRStatus45*/
        ,{DUMMY_NAME_PTR_CNS,           0x00021618+AAS_PSI_SCHED_OFFSET,         0x0fffffff,      1,    0x8    }/*ClvlRRDWRRStatus67*/
        ,{DUMMY_NAME_PTR_CNS,           0x00021400+AAS_PSI_SCHED_OFFSET,         0x00000000,      1,    0x8    }/*ClvlWFS*/
        ,{DUMMY_NAME_PTR_CNS,           0x00021408+AAS_PSI_SCHED_OFFSET,         0x00040000,      1,    0x8    }/*ClvlL0ClusterStateLo*/
        ,{DUMMY_NAME_PTR_CNS,           0x00021410+AAS_PSI_SCHED_OFFSET,         0x00040000,      1,    0x8    }/*ClvlL0ClusterStateHi*/
        ,{DUMMY_NAME_PTR_CNS,           0x00021800+AAS_PSI_SCHED_OFFSET,         0x00000002,      1,    0x8    }/*BlvlNodeState*/
        ,{DUMMY_NAME_PTR_CNS,           0x00022000+AAS_PSI_SCHED_OFFSET,         0x00000000,      1,    0x8    }/*BlvlMyQ*/
        ,{DUMMY_NAME_PTR_CNS,           0x00022900+AAS_PSI_SCHED_OFFSET,         0x3fffffff,      1,    0x8    }/*BlvlRRDWRRStatus01*/
        ,{DUMMY_NAME_PTR_CNS,           0x00022908+AAS_PSI_SCHED_OFFSET,         0x3fffffff,      1,    0x8    }/*BlvlRRDWRRStatus23*/
        ,{DUMMY_NAME_PTR_CNS,           0x00022910+AAS_PSI_SCHED_OFFSET,         0x3fffffff,      1,    0x8    }/*BlvlRRDWRRStatus45*/
        ,{DUMMY_NAME_PTR_CNS,           0x00022918+AAS_PSI_SCHED_OFFSET,         0x3fffffff,      1,    0x8    }/*BlvlRRDWRRStatus67*/
        ,{DUMMY_NAME_PTR_CNS,           0x00022800+AAS_PSI_SCHED_OFFSET,         0x00000000,      1,    0x8    }/*BlvlWFS*/
        ,{DUMMY_NAME_PTR_CNS,           0x00022808+AAS_PSI_SCHED_OFFSET,         0x00040000,      1,    0x8    }/*BlvlL0ClusterStateLo*/
        ,{DUMMY_NAME_PTR_CNS,           0x00022810+AAS_PSI_SCHED_OFFSET,         0x00040000,      1,    0x8    }/*BlvlL0ClusterStateHi*/
        ,{DUMMY_NAME_PTR_CNS,           0x00022818+AAS_PSI_SCHED_OFFSET,         0x00040000,      1,    0x8    }/*BlvlL1ClusterStateLo*/
        ,{DUMMY_NAME_PTR_CNS,           0x00022820+AAS_PSI_SCHED_OFFSET,         0x00040000,      1,    0x8    }/*BlvlL1ClusterStateHi*/
        ,{DUMMY_NAME_PTR_CNS,           0x00024000+AAS_PSI_SCHED_OFFSET,         0x00000002,      1,    0x8    }/*AlvlNodeState*/
        ,{DUMMY_NAME_PTR_CNS,           0x00026000+AAS_PSI_SCHED_OFFSET,         0x00000000,      1,    0x8    }/*AlvlMyQ*/
        ,{DUMMY_NAME_PTR_CNS,           0x00028200+AAS_PSI_SCHED_OFFSET,         0xffffffff,      1,    0x8    }/*AlvlRRDWRRStatus01*/
        ,{DUMMY_NAME_PTR_CNS,           0x00028208+AAS_PSI_SCHED_OFFSET,         0xffffffff,      1,    0x8    }/*AlvlRRDWRRStatus23*/
        ,{DUMMY_NAME_PTR_CNS,           0x00028210+AAS_PSI_SCHED_OFFSET,         0xffffffff,      1,    0x8    }/*AlvlRRDWRRStatus45*/
        ,{DUMMY_NAME_PTR_CNS,           0x00028218+AAS_PSI_SCHED_OFFSET,         0xffffffff,      1,    0x8    }/*AlvlRRDWRRStatus67*/
        ,{DUMMY_NAME_PTR_CNS,           0x00028000+AAS_PSI_SCHED_OFFSET,         0x00000000,      1,    0x8    }/*AlvlWFS*/
        ,{DUMMY_NAME_PTR_CNS,           0x00028100+AAS_PSI_SCHED_OFFSET,         0x00040000,      1,    0x8    }/*AlvlL0ClusterStateLo*/
        ,{DUMMY_NAME_PTR_CNS,           0x00028108+AAS_PSI_SCHED_OFFSET,         0x00040000,      1,    0x8    }/*AlvlL0ClusterStateHi*/
        ,{DUMMY_NAME_PTR_CNS,           0x00028110+AAS_PSI_SCHED_OFFSET,         0x00040000,      1,    0x8    }/*AlvlL1ClusterStateLo*/
        ,{DUMMY_NAME_PTR_CNS,           0x00028118+AAS_PSI_SCHED_OFFSET,         0x00040000,      1,    0x8    }/*AlvlL1ClusterStateHi*/
        ,{DUMMY_NAME_PTR_CNS,           0x00028120+AAS_PSI_SCHED_OFFSET,         0x00040000,      1,    0x8    }/*AlvlL2ClusterStateLo*/
        ,{DUMMY_NAME_PTR_CNS,           0x00028128+AAS_PSI_SCHED_OFFSET,         0x00040000,      1,    0x8    }/*AlvlL2ClusterStateHi*/

        ,{NULL,            0,         0x00000000,      0,    0x0      }
        };
        static SMEM_LINK_LIST_REGISTER_DEFAULT_VALUE_STC list = {myUnit_registersDefaultValueArr,NULL};
        unitPtr->unitDefaultRegistersPtr = &list;
    }
}


static void smemAasUnitTxqPdx
(
    IN SKERNEL_DEVICE_OBJECT *devObjPtr,
    IN SMEM_UNIT_CHUNKS_STC  *unitPtr
)
{
    SMEM_CHUNK_BASIC_STC  chunksMem[]=
    {
/*{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x0001F004,0x0001F004)},*/



             {SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00000000, 4096),
                SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(6, 4),SMEM_BIND_TABLE_MAC(txqPdxQueueGroupMap)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00004000, 4096)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00008000, 0x0000800C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00008020, 0x00008020)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00008030, 0x00008030)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00008040, 0x00008040)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00008060, 0x00008064)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00010000, 0x00010000)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00018000, 0x00018010)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00018030, 0x00018030)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00018040, 0x0001805C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00018100, 0x00018110)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00018120, 0x00018130)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00018140, 0x00018150)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00018160, 0x00018170)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00018190, 0x000181A0)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00019000, 0x00019004)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x0001A000, 0x0001A004)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x0001B000, 0x0001B010)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x0001F004, 0x0001F004)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x0001F010, 0x0001F028)}
            /*fake until interrupts implemented*/
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x0000140c,0x000140c)},
    };

    GT_U32  numOfChunks = sizeof(chunksMem)/sizeof(SMEM_CHUNK_BASIC_STC);
    smemInitMemChunk(devObjPtr,chunksMem, numOfChunks, unitPtr);



   {
    static SMEM_REGISTER_DEFAULT_VALUE_STC myUnit_registersDefaultValueArr[] =
    {
         {DUMMY_NAME_PTR_CNS,           0x0001f004,         0x0000ffff,      1,    0x4    }/*pdx_metal_fix*/
        ,{DUMMY_NAME_PTR_CNS,           0x00008060,         0x00688688,      1,    0x4    }/*dp_core_mapping_register_pds_id*/
        ,{DUMMY_NAME_PTR_CNS,           0x00008064,         0x000000f0,      1,    0x4    }/*dp_core_mapping_register_pdx_id*/
        ,{DUMMY_NAME_PTR_CNS,           0x0001800c,         0x000000c0,      1,    0x4    }/*pfcc_burst_fifo_thr*/
        ,{DUMMY_NAME_PTR_CNS,           0x00018008,         0x000000c0,      1,    0x4    }/*global_burst_fifo_thr*/
        ,{DUMMY_NAME_PTR_CNS,           0x00018004,         0x0003ffff,      1,    0x4    }/*MIN_Global_Burst_Fifo_Available_Entries*/
        ,{DUMMY_NAME_PTR_CNS,           0x00019004,         0x00000005,      1,    0x4    }/*epb_fifo_thr*/
        ,{DUMMY_NAME_PTR_CNS,           0x0001a000,         0x23444688,      1,    0x4    }/*pds_msg_mapping_register_pds_id*/
        ,{DUMMY_NAME_PTR_CNS,           0x0001a004,         0x000003e0,      1,    0x4    }/*pds_msg_mapping_register_pdx_id*/
        ,{DUMMY_NAME_PTR_CNS,           0x0001b000,         0x000000ff,      1,    0x4    }/*Telemetry_Decay_Counter_Threshold*/
        ,{DUMMY_NAME_PTR_CNS,           0x0001b010,         0x000000e4,      1,    0x4    }/*qcx_dp_core_to_db_map*/
        ,{NULL,                         0,                  0x00000000,      0,    0x0  }
    };
    static SMEM_LINK_LIST_REGISTER_DEFAULT_VALUE_STC list = {myUnit_registersDefaultValueArr,NULL};
    unitPtr->unitDefaultRegistersPtr = &list;
   }
}

/**
* @internal smemAasUnitTxqPfcc function
* @endinternal
*
* @brief   Allocate address type specific memories -- for the txq pfcc unit
*/
static void smemAasUnitTxqPfcc
(
    IN SKERNEL_DEVICE_OBJECT *devObjPtr,
    IN SMEM_UNIT_CHUNKS_STC  *unitPtr
)
{
        SMEM_CHUNK_BASIC_STC  chunksMem[]=
        {
          {SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000000,0x00000010)},
          {SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000100,0x00000108)},
          {SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000200,0x00000214)},
          {SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000300,0x0000031C)},
          {SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000400,0x00000444)},
          {SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000500,0x00000548)},
          {SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00001000,840)}
        };

        GT_U32  numOfChunks = sizeof(chunksMem)/sizeof(SMEM_CHUNK_BASIC_STC);

        smemInitMemChunk(devObjPtr,chunksMem, numOfChunks, unitPtr);
        {
          static SMEM_REGISTER_DEFAULT_VALUE_STC myUnit_registersDefaultValueArr[] =
          {
             {DUMMY_NAME_PTR_CNS,           0x00000000,         0x000001A2,      1,    0x4    }/*global_pfcc_cfg*/
            ,{DUMMY_NAME_PTR_CNS,           0x00000010,         0x0000ffff,      1,    0x4    }/*PFCC_metal_fix*/
            ,{DUMMY_NAME_PTR_CNS,           0x00000008,         0x00924924,      1,    0x4    }/*TC_to_pool_CFG*/
            ,{DUMMY_NAME_PTR_CNS,           0x0000000c,         0x0fffe000,      1,    0x4    }/*Total_virtual_buffer_limit_CFG*/
            ,{DUMMY_NAME_PTR_CNS,           0x00000400,         0x0000003f,      1,    0x4    }/*Source_Port_Requested_For_Read*/
            ,{NULL,                         0,                  0x00000000,      0,    0x0  }
          };
          static SMEM_LINK_LIST_REGISTER_DEFAULT_VALUE_STC list = {myUnit_registersDefaultValueArr,NULL};
          unitPtr->unitDefaultRegistersPtr = &list;
        }

}

/**
* @internal smemAasSpecificDeviceUnitAlloc_TXQ_units function
* @endinternal
*
* @brief   specific initialization units allocation that called before alloc units
*         of any device.
*         SIP units
* @param[in] devObjPtr                - pointer to device object.
*                                       Pointer to object for specific subunit
*/
static void smemAasSpecificDeviceUnitAlloc_TXQ_units
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr
)
{
    SMEM_DEVICE_UNIT_ALLOCATION_STC allocUnitsArr []=
    {
        {STR(UNIT_TXQ_PSI)       ,smemAasUnitTxqPsi}
       ,{STR(UNIT_TXQ_PDS0)       ,smemAasUnitTxqPds}
       ,{STR(UNIT_TXQ_SDQ0)       ,smemAasUnitTxqSdq}
       ,{STR(UNIT_TXQ_QFC0)       ,smemAasUnitTxqQfc}
       ,{STR(UNIT_TXQ_PDX)       ,smemAasUnitTxqPdx}
       ,{STR(UNIT_TXQ_PFCC)       ,smemAasUnitTxqPfcc}

        /* must be last */
        ,{NULL,NULL}
    };

    smemGenericUnitAlloc(devObjPtr,allocUnitsArr);
}

/**
* @internal smemAasUnitL2i function
* @endinternal
*
* @brief   Allocate address type specific memories -- for the L2i unit
*
* @param[in] devObjPtr                - pointer to device object.
* @param[in,out] unitPtr                  - pointer to the unit chunk
*/
static void smemAasUnitL2i
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    INOUT SMEM_UNIT_CHUNKS_STC  * unitPtr
)
{
    START_BIND_UNIT_ACTIVE_MEM_MAC(devObjPtr,unitPtr)

    /* Bridge Interrupt Cause Register */
    {0x00002300, SMEM_FULL_MASK_CNS,
        smemChtActiveReadIntrCauseReg, 14, smemChtActiveWriteIntrCauseReg, 0},
    /* Bridge Interrupt Mask Register */
    {0x00002304, SMEM_FULL_MASK_CNS,
        NULL, 0, smemChtActiveWriteBridgeInterruptsMaskReg, 0},

    /* Security Breach Status Register 3 */
    {0x0000160C, SMEM_FULL_MASK_CNS, smemChtActiveReadBreachStatusReg, 0, NULL, 0},

    /*hostIncomingPktsCount;               */
    {0x00001710, SMEM_FULL_MASK_CNS, smemChtActiveReadCntrs, 0, NULL,0},
    /*hostOutgoingPktsCount;               */
    {0x00001714, SMEM_FULL_MASK_CNS, smemChtActiveReadCntrs, 0, NULL,0},
    /*hostOutgoingMcPktCount;              */
    {0x00001720, SMEM_FULL_MASK_CNS, smemChtActiveReadCntrs, 0, NULL,0},
    /*hostOutgoingBcPktCount;              */
    {0x00001724, SMEM_FULL_MASK_CNS, smemChtActiveReadCntrs, 0, NULL,0},
    /*matrixSourceDestinationPktCount;     */
    {0x00001728, SMEM_FULL_MASK_CNS, smemChtActiveReadCntrs, 0, NULL,0},
    /*setVLANIngrFilteredPktCount[n]*/
    {0x0000173c, SMEM_FULL_MASK_CNS, smemChtActiveReadCntrs, 0, NULL,0},
    {0x0000175c, SMEM_FULL_MASK_CNS, smemChtActiveReadCntrs, 0, NULL,0},
    /*setIncomingPktCount[n]        */
    {0x00001738, SMEM_FULL_MASK_CNS, smemChtActiveReadCntrs, 0, NULL,0},
    {0x00001758, SMEM_FULL_MASK_CNS, smemChtActiveReadCntrs, 0, NULL,0},
    /*setSecurityFilteredPktCount[n]*/
    {0x00001740, SMEM_FULL_MASK_CNS, smemChtActiveReadCntrs, 0, NULL,0},
    {0x00001760, SMEM_FULL_MASK_CNS, smemChtActiveReadCntrs, 0, NULL,0},
    /*setBridgeFilteredPktCount[n]  */
    {0x00001744, SMEM_FULL_MASK_CNS, smemChtActiveReadCntrs, 0, NULL,0},
    {0x00001764, SMEM_FULL_MASK_CNS, smemChtActiveReadCntrs, 0, NULL,0},

    /* HSR PRP Proxy Node Table Ready Entry <%i> :
       0x00002C00 + 0x4*i: where i (0-127) represents reg_num */
    {0x00002C00, SMEM_FULL_MASK_CNS-((128*4)-1), NULL, 0, smemSip6_30ActiveWritePntReadyReg, 0},

    END_BIND_UNIT_ACTIVE_MEM_MAC(devObjPtr,unitPtr)

    {
        SMEM_CHUNK_BASIC_STC  chunksMem[]=
        {
             {SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000000, 0x00000018)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000030, 0x0000003C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000050, 0x00000058)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000060, 0x00000060)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000120, 0x00000120)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000130, 0x00000130)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000140, 0x0000014C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000160, 0x00000164)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000170, 0x00000170)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000180, 0x0000019C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000700, 0x0000071C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000800, 0x0000087C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000900, 0x0000093C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000A00, 0x00000A1C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000B00, 0x00000B7C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000C00, 0x00000C3C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000D00, 0x00000D1C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000E00, 0x00000E08)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001000, 0x00001018)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001100, 0x0000112C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001500, 0x00001508)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001600, 0x0000160C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001700, 0x00001708)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001710, 0x00001714)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001720, 0x00001728)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001730, 0x00001744)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001750, 0x00001764)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001800, 0x0000187C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00002120, 0x00002120)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00002200, 0x00002200)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00002210, 0x00002210)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00002220, 0x00002220)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00002300, 0x00002304)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00002400, 0x0000245C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000024A0, 0x000024A4)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000024C0, 0x000024DC)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00002500, 0x0000250C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00002600, 0x00002FFC)}

            /*Ingress Bridge physical Port Table*/
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC(0x00200000 ,4*NUM_PHY_PORTS ), SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(29, 4),SMEM_BIND_TABLE_MAC(bridgePhysicalPortEntry)}
            /* Source Trunk Attribute Table */
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC(0x00202000 ,8*(NUM_TRUNKS/8)),SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(40, 8),SMEM_BIND_TABLE_MAC(bridgeIngressTrunk)}
            /* ingress EPort learn prio Table */                          /*0x40000*/
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC(0x00210000 ,8*(NUM_EPORTS/8)),SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(40, 8),SMEM_BIND_TABLE_MAC(bridgeIngressEPortLearnPrio)}
            /* Ingress Span State Group Index Table */                    /*0x20000*/
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC(0x00240000 , 4*NUM_EVIDS), SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(12 , 4),SMEM_BIND_TABLE_MAC(ingressSpanStateGroupIndex)}
            /* Ingress Spanning Tree State Table */                       /*0x20000*/
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC(0x00220000 , (NUM_PHY_PORTS*2/8)*NUM_STGS ),SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(NUM_PHY_PORTS*2, (NUM_PHY_PORTS*2)/8),SMEM_BIND_TABLE_MAC(stp)}
            /* Ingress Port Membership Table */                           /*0x80000*/
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC(0x00280000 , (NUM_PHY_PORTS/8)*NUM_4K_VLANS), SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(NUM_PHY_PORTS , NUM_PHY_PORTS/8),SMEM_BIND_TABLE_MAC(bridgeIngressPortMembership)}
            /* Ingress Vlan Table */                                      /*0x80000*/
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC(0x00300000 , 16*NUM_EVIDS), SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(124 , 16),SMEM_BIND_TABLE_MAC(vlan)}
            /*Bridge Ingress ePort Table*/                                /*0x40000*/
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC(0x00400000 ,16*NUM_EPORTS), SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(80 ,16),SMEM_BIND_TABLE_MAC(bridgeIngressEPort)}
        };
        GT_U32  numOfChunks = sizeof(chunksMem)/sizeof(SMEM_CHUNK_BASIC_STC);
        SMEM_UNIT_CHUNKS_STC    tmpUnitChunk;

        smemInitMemChunk(devObjPtr,chunksMem, numOfChunks, &tmpUnitChunk);

        /*add the tmp unit chunks to the main unit */
        smemInitMemCombineUnitChunks(devObjPtr,unitPtr,&tmpUnitChunk);
    }

    {
        SMEM_CHUNK_EXTENDED_STC  chunksMem[]=
        {
            /* IEEE Reserved Multicast Configuration register */ /* register and not table SMEM_BIND_TABLE_MAC(ieeeRsrvMcConfTable) */
             {{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC(0x00000200 ,0),SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(32, 4),SMEM_BIND_TABLE_MAC(ieeeRsrvMcConfTable)}, FORMULA_TWO_PARAMETERS(16 , 0x4 , 8 ,0x80)}
            ,{{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC(0x00000600 ,0),SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(32, 4),SMEM_BIND_TABLE_MAC(ieeeRsrvMcCpuIndex)}, FORMULA_SINGLE_PARAMETER(16 , 0x4)}
        };
        GT_U32  numOfChunks = sizeof(chunksMem)/sizeof(SMEM_CHUNK_EXTENDED_STC);
        SMEM_UNIT_CHUNKS_STC    tmpUnitChunk;

        smemInitMemChunkExt(devObjPtr,chunksMem, numOfChunks, &tmpUnitChunk);

        /*add the tmp unit chunks to the main unit */
        smemInitMemCombineUnitChunks(devObjPtr,unitPtr,&tmpUnitChunk);
    }


    {
        static SMEM_REGISTER_DEFAULT_VALUE_STC myUnit_registersDefaultValueArr[] =
        {
             {DUMMY_NAME_PTR_CNS,            0x00000000,         0x12806004,      1,    0x4  }
            ,{DUMMY_NAME_PTR_CNS,            0x00000004,         0x00002640,      1,    0x4  }
            ,{DUMMY_NAME_PTR_CNS,            0x00000008,         0x0000ffff,      1,    0x4  }
            ,{DUMMY_NAME_PTR_CNS,            0x00000030,         0x22023924,      1,    0x4  }
            ,{DUMMY_NAME_PTR_CNS,            0x00000058,         0x001f803f,      1,    0x4  }
            ,{DUMMY_NAME_PTR_CNS,            0x00000120,         0x52103210,      1,    0x4  }
            ,{DUMMY_NAME_PTR_CNS,            0x00000130,         0x0000fffe,      1,    0x4  }
            ,{DUMMY_NAME_PTR_CNS,            0x00000140,         0x05f205f2,      4,    0x4  }
            ,{DUMMY_NAME_PTR_CNS,            0x00000160,         0x0001ffff,      2,    0x4  }
            ,{DUMMY_NAME_PTR_CNS,            0x00001800,         0xffffffff,     32,    0x4  }
            ,{DUMMY_NAME_PTR_CNS,            0x00002200,         0x0000007f,      1,    0x4  }
            ,{DUMMY_NAME_PTR_CNS,            0x00002210,         0x0000ffff,      1,    0x4  }
            ,{DUMMY_NAME_PTR_CNS,            0x00002404,         0x000403f0,      1,    0x4  }
            ,{DUMMY_NAME_PTR_CNS,            0x00002408,         0x00002004,      1,    0x4  }
            ,{DUMMY_NAME_PTR_CNS,            0x0000240c,         0x3ff00000,      1,    0x4  }
            ,{DUMMY_NAME_PTR_CNS,            0x00002500,         0x0000000a,      4,    0x4  }

            ,{NULL,            0,         0x00000000,      0,    0x0      }
        };
        static SMEM_LINK_LIST_REGISTER_DEFAULT_VALUE_STC list = {myUnit_registersDefaultValueArr,NULL};
        unitPtr->unitDefaultRegistersPtr = &list;
    }
}

/**
* @internal smemAasUnitEgfSht function
* @endinternal
*
* @brief   Allocate address type specific memories -- for the EGF-SHT unit
*
* @param[in] devObjPtr                - pointer to device object.
* @param[in,out] unitPtr                  - pointer to the unit chunk
*/
static void smemAasUnitEgfSht
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    INOUT SMEM_UNIT_CHUNKS_STC  * unitPtr
)
{
    {
        SMEM_CHUNK_BASIC_STC  chunksMem[]=
        {
             /*eVLAN Members Table*/
            {SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00000000, 524288)   , SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(1024, 128),SMEM_BIND_TABLE_MAC(egressVlan)}
             /*eVLAN Attribute Table*/
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00080000, 262144)   , SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(11, 4),SMEM_BIND_TABLE_MAC(egfShtEVlanAttribute)}
             /*Non Trunk Members Table 2*/
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x000C0000, 131072)   , SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(1024, 128),SMEM_BIND_TABLE_MAC(nonTrunkMembers2)}
             /*L2 Port Isolation Table */
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00100000, 655360)   , SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(1024, 128),SMEM_BIND_TABLE_MAC(l2PortIsolation)}
             /*Egress ePort Table*/
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x001A0000, 65536)    , SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(29, 4),SMEM_BIND_TABLE_MAC(egfShtEgressEPort)}
             /*eVLAN Spanning Table*/
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x001C0000, 262144)   , SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(9, 4),SMEM_BIND_TABLE_MAC(egfShtEVlanSpanning)}
             /*L3 Port Isolation Table*/
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00200000, 655360)   , SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(1024, 128),SMEM_BIND_TABLE_MAC(l3PortIsolation)}
             /*Device Map Table*/
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x002A0000, 32768)    , SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(14, 4),SMEM_BIND_TABLE_MAC(deviceMapTable)}
             /*Designated Trunk Members Table*/
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x002B0000, 32768)    , SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(1024, 128),SMEM_BIND_TABLE_MAC(designatedPorts)}
             /*Source ID Members Table*/
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00300000, 524288)   , SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(1024, 128),SMEM_BIND_TABLE_MAC(sst)}
             /*Spanning Tree State Table*/
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00380000, 65536)    , SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(1024, 128),SMEM_BIND_TABLE_MAC(egressStp)}
             /*Non Trunk Members Table*/
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00390000, 32768)    , SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(1024, 128),SMEM_BIND_TABLE_MAC(nonTrunkMembers)}
             /*Multicast Groups Table*/
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00400000, 655360)   , SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(1024, 128),SMEM_BIND_TABLE_MAC(mcast)}

             /* registers (non-tables) */
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00560000, 0x00560010)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00560020, 0x00560020)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00560030, 0x00560030)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00560040, 0x00561140)}

        };
        GT_U32  numOfChunks = sizeof(chunksMem)/sizeof(SMEM_CHUNK_BASIC_STC);

        smemInitMemChunk(devObjPtr,chunksMem,numOfChunks,unitPtr);
    }

    {
        static SMEM_REGISTER_DEFAULT_VALUE_STC myUnit_registersDefaultValueArr[] =
        {
             {DUMMY_NAME_PTR_CNS,          0x00560000,         0x01fff007,      1,    0x0    }
            ,{DUMMY_NAME_PTR_CNS,          0x00560004,         0x00000001,      1,    0x0    }
            ,{DUMMY_NAME_PTR_CNS,          0x00560008,         0x0000000f,      1,    0x0    }
            ,{DUMMY_NAME_PTR_CNS,          0x0056000c,         0x00000078,      1,    0x0    }
            ,{DUMMY_NAME_PTR_CNS,          0x00560030,         0xffff0000,      1,    0x0    }
            ,{DUMMY_NAME_PTR_CNS,          0x00560040,         0xffffffff,      (NUM_PHY_PORTS/32),    0x4    }
            ,{DUMMY_NAME_PTR_CNS,          0x00560240,         0xffffffff,      (NUM_PHY_PORTS/32),    0x4    }
            ,{DUMMY_NAME_PTR_CNS,          0x00560340,         0xffffffff,      (NUM_PHY_PORTS/32),    0x4    }

             /* Device Map Table */
            /* Default value of 'UplinkIsTrunk - 0x1 = Trunk;' like in legacy devices */
            ,{DUMMY_NAME_PTR_CNS,           0x002A0000,         0x00000002,   8192,    0x4   }
             /* Designated Port Table */
            ,{DUMMY_NAME_PTR_CNS,           0x002B0000,         0xffffffff,    256*(NUM_PHY_PORTS/32),    0x4   }

#if 0 /* already done in smemSip5AdditionalDefaultRegInit ... init of those 2 tables */
            /* L2 port isolation Table */
            ,{DUMMY_NAME_PTR_CNS,           0x00100000,         0xffffffff,   NUM_PORT_ISOLATION*(NUM_PHY_PORTS/32),    0x4   }
            /* L3 port isolation Table */
            ,{DUMMY_NAME_PTR_CNS,           0x00200000,         0xffffffff,   NUM_PORT_ISOLATION*(NUM_PHY_PORTS/32),    0x4   }
#endif
            /* Source ID Members Table */
            ,{DUMMY_NAME_PTR_CNS,           0x00300000,         0xffffffff,   NUM_SSTS*(NUM_PHY_PORTS/32),    0x4   }

            ,{NULL,            0,         0x00000000,      0,    0x0      }
        };
        static SMEM_LINK_LIST_REGISTER_DEFAULT_VALUE_STC list = {myUnit_registersDefaultValueArr,NULL};
        unitPtr->unitDefaultRegistersPtr = &list;
    }

    {/*start of unit EGF_sht */
        GT_U32  numOfPorts = NUM_PHY_PORTS;

        {/*start of unit global */

            {/*01007c0+n*0x4*/
                GT_U32    n;
                for(n = 0 ; n < (numOfPorts/2); n++) {
                    SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->EGF_sht.global.eportAssociatedVid1[n] =
                        0x005607c0+n*0x4;
                }/* end of loop n */
            }/*01007c0+n*0x4*/
            {/*0100040+0x4*n*/
                GT_U32    n;
                for(n = 0 ; n < (numOfPorts/32); n++) {
                    SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->EGF_sht.global.UCSrcIDFilterEn[n] =
                        0x00560040+0x4*n;
                }/* end of loop n */
            }/*0100040+0x4*n*/
            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->EGF_sht.global.MESHIDConfigs = 0x00560004;
            {/*01010c0+0x4*n*/
                GT_U32    n;
                for(n = 0 ; n < (numOfPorts/32); n++) {
                    SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->EGF_sht.global.MCLocalEn[n] =
                        0x005610c0+0x4*n;
                }/* end of loop n */
            }/*01010c0+0x4*n*/
            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->EGF_sht.global.SHTInterruptsMask = 0x00560020;
            {/*0101040+0x4*n*/
                GT_U32    n;
                for(n = 0 ; n < (numOfPorts/32); n++) {
                    SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->EGF_sht.global.ignorePhySrcMcFilterEn[n] =
                        0x00561040+0x4*n;
                }/* end of loop n */
            }/*0101040+0x4*n*/
            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->EGF_sht.global.SHTGlobalConfigs = 0x00560000;
            {/*01002c0+0x4*n*/
                GT_U32    n;
                for(n = 0 ; n < (numOfPorts/32); n++) {
                    SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->EGF_sht.global.eportStpStateMode[n] =
                        0x005602c0+0x4*n;
                }/* end of loop n */
            }/*01002c0+0x4*n*/
            {/*0100340+0x4*n*/
                GT_U32    n;
                for(n = 0 ; n < (numOfPorts/32); n++) {
                    SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->EGF_sht.global.eportStpState[n] =
                        0x00560340+0x4*n;
                }/* end of loop n */
            }/*0100340+0x4*n*/
            {/*01001c0+0x4*n*/
                GT_U32    n;
                for(n = 0 ; n < (numOfPorts/32); n++) {
                    SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->EGF_sht.global.eportRoutedForwardRestricted[n] =
                        0x005601c0+0x4*n;
                }/* end of loop n */
            }/*01001c0+0x4*n*/
            {/*01003c0+0x4*n*/
                GT_U32    n;
                for(n = 0 ; n < (numOfPorts/16); n++) {
                    SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->EGF_sht.global.eportPortIsolationMode[n] =
                        0x005603c0+0x4*n;
                }/* end of loop n */
            }/*01003c0+0x4*n*/
            {/*0100540+0x4*n*/
                GT_U32    n;
                for(n = 0 ; n < (numOfPorts/32); n++) {
                    SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->EGF_sht.global.eportOddOnlySrcIdFilterEnable[n] =
                        0x00560540+0x4*n;
                }/* end of loop n */
            }/*0100540+0x4*n*/
            {/*01005c0+n * 0x4*/
                GT_U32    n;
                for(n = 0 ; n < (numOfPorts/8); n++) {
                    SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->EGF_sht.global.ePortMeshID[n] =
                        0x005605c0+n * 0x4;
                }/* end of loop n */
            }/*01005c0+n * 0x4*/
            {/*01004c0+0x4*n*/
                GT_U32    n;
                for(n = 0 ; n < (numOfPorts/32); n++) {
                    SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->EGF_sht.global.eportIPMCRoutedFilterEn[n] =
                        0x005604c0+0x4*n;
                }/* end of loop n */
            }/*01004c0+0x4*n*/
            {/*01000c0+0x4*n*/
                GT_U32    n;
                for(n = 0 ; n < (numOfPorts/32); n++) {
                    SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->EGF_sht.global.eportFromCPUForwardRestricted[n] =
                        0x005600c0+0x4*n;
                }/* end of loop n */
            }/*01000c0+0x4*n*/
            {/*0100240+0x4*n*/
                GT_U32    n;
                for(n = 0 ; n < (numOfPorts/32); n++) {
                    SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->EGF_sht.global.eportEvlanFilteringEnable[n] =
                        0x00560240+0x4*n;
                }/* end of loop n */
            }/*0100240+0x4*n*/
            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->EGF_sht.global.eportVlanEgrFiltering = 0x0056000c;
            {/*0100fc0+n * 0x4*/
                GT_U32    n;
                for(n = 0 ; n < (numOfPorts/32); n++) {
                    SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->EGF_sht.global.eportDropOnEportVid1Mismatch[n] =
                        0x00560fc0+n * 0x4;
                }/* end of loop n */
            }/*0100fc0+n * 0x4*/
            {/*0100140+0x4*n*/
                GT_U32    n;
                for(n = 0 ; n < (numOfPorts/32); n++) {
                    SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->EGF_sht.global.eportBridgedForwardRestricted[n] =
                        0x00560140+0x4*n;
                }/* end of loop n */
            }/*0100140+0x4*n*/
            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->EGF_sht.global.SHTInterruptsCause  = 0x00560010;
            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->EGF_sht.global.SHTEgrFiltersEnable = 0x00560008;

        }/*end of unit global */


    }/*end of unit EGF_sht */
}
/**
* @internal smemAasUnitEgfQag function
* @endinternal
*
* @brief   Allocate address type specific memories -- for the EGF-QAG unit
*
* @param[in] devObjPtr                - pointer to device object.
* @param[in,out] unitPtr                  - pointer to the unit chunk
*/
void smemAasUnitEgfQag
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    INOUT SMEM_UNIT_CHUNKS_STC  * unitPtr
)
{
    {
        SMEM_CHUNK_BASIC_STC  chunksMem[]=
        {
             /*eVLAN Tag Command Table*/
             {SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00000000, 2097152),SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(48, 8),SMEM_BIND_TABLE_MAC(egfQagEVlanDescriptorAssignmentAttributes)}
             /*Queue Map Table*/
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00200000, 524288),SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(15, 4),SMEM_BIND_TABLE_MAC(egfQueueMapTable)}
             /*ePort Descriptor Assignment Attributes Table*/
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00280000, 131072) ,SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(49, 8),SMEM_BIND_TABLE_MAC(egfQagEgressEPort)}
             /*TC DP Mapper Table*/
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x002A0000, 4096)   ,SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(15, 4),SMEM_BIND_TABLE_MAC(egfQagTcDpMapper)}
             /*Port Target Attributes Table*/
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x002A6000, 4096)   ,SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(14, 4),SMEM_BIND_TABLE_MAC(egfQagPortTargetAttribute)}
             /*Port Enq Attributes Table*/
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x002A8000, 8192)   ,SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(48, 8),SMEM_BIND_TABLE_MAC(egfQagTargetPortMapper)}
             /*Port Source Attributes Table*/
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x002AC000, 4096)   ,SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(7, 4) ,SMEM_BIND_TABLE_MAC(egfQagPortSourceAttribute) }
             /*CPU Code To Loopback Mapper Table*/
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x002AD000, 1024)   ,SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(11, 4), SMEM_BIND_TABLE_MAC(egfQagCpuCodeToLbMapper)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x002AF000, 0x002AF000)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x002AF170, 0x002AF27C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x002AFA00, 0x002AFA04)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x002AFB00, 0x002AFB00)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x002AFB10, 0x002AFB10)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x002AFB20, 0x002AFB20)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x002AFC00, 0x002AFC14)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x002AFD00, 0x002AFD00)}

        };
        GT_U32  numOfChunks = sizeof(chunksMem)/sizeof(SMEM_CHUNK_BASIC_STC);

        smemInitMemChunk(devObjPtr,chunksMem,numOfChunks,unitPtr);
    }


    {
        static SMEM_REGISTER_DEFAULT_VALUE_STC myUnit_registersDefaultValueArr[] =
        {
             {DUMMY_NAME_PTR_CNS,            0x002A6000,         0x00000004,   1024,    0x4 }
            ,{DUMMY_NAME_PTR_CNS,            0x002afa04,         0x0000bfff,      1,    0x4 }
            ,{DUMMY_NAME_PTR_CNS,            0x002afb20,         0xffff0000,      1,    0x4 }
            ,{DUMMY_NAME_PTR_CNS,            0x002afc00,         0x00041011,      1,    0x4 }
            ,{DUMMY_NAME_PTR_CNS,            0x002afc04,         0x00008888,      2,    0x4 }

           ,{NULL,                  0,                  0x00000000,      0,    0x0}
        };
        static SMEM_LINK_LIST_REGISTER_DEFAULT_VALUE_STC list = {myUnit_registersDefaultValueArr,NULL};
        unitPtr->unitDefaultRegistersPtr = &list;
    }

    {/*start of unit EGF_qag */
        {/*start of unit uniMultiArb */
            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->EGF_qag.uniMultiArb.uniMultiCtrl = 0x002AFC00;
            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->EGF_qag.uniMultiArb.multiShaperCtrl = 0x002AFC0C;

        }/*end of unit uniMultiArb */


        {/*start of unit miscellaneous */
            /*SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->EGF_qag.miscellaneous.badAddrLatchReg = 0x002AFD00;*/

        }/*end of unit miscellaneous */


        {/*start of unit global */
            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->EGF_qag.global.QAGInterruptsCause = 0x002AFB00;
            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->EGF_qag.global.QAGInterruptsMask = 0x002AFB10;

        }/*end of unit global */


        {/*start of unit distributor */
            {/*c9b0170+0x4*n*/
                GT_U32    n;
                for(n = 0 ; n <= 3 ; n++) {
                    SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->EGF_qag.distributor.loopbackEnableConfig[n] =
                        0x002AF170+0x4*n;
                }/* end of loop n */
            }/*000a0170+0x4*n*/
            {/*000a0180+0x4*n*/
                GT_U32    n;
                for(n = 0 ; n <= 63 ; n++) {
                    SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->EGF_qag.distributor.toAnalyzerLoopback[n] =
                        0x002AF180+0x4*n;
                }/* end of loop n */
            }/*000a0180+0x4*n*/
            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->EGF_qag.distributor.distributorGeneralConfigs = 0x002AF000;
            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->EGF_qag.distributor.loopbackForwardingGlobalConfig = 0x002AFa00;
            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->EGF_qag.distributor.cutThroughConfig = 0x002AFA04;

        }/*end of unit distributor */


    }/*end of unit EGF_qag */

}

/**
* @internal smemAasUnitEgfEft function
* @endinternal
*
* @brief   Allocate address type specific memories -- for the EGF-EFT unit
*
* @param[in] devObjPtr                - pointer to device object.
* @param[in,out] unitPtr                  - pointer to the unit chunk
*/
static void smemAasUnitEgfEft
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    INOUT SMEM_UNIT_CHUNKS_STC  * unitPtr
)
{
#define EFT_STEP_HIGH_TO_LOW_OF_64BIT_COUNTER 0x8
    {
        START_BIND_UNIT_ACTIVE_MEM_MAC(devObjPtr,unitPtr)

        /* ROC (read only clear) counters */
        /*0x00045000-0x0004501c*/
        { 0x00045000 , SMEM_FULL_MASK_CNS-0x1F, smemChtActiveReadCntrs, 0, NULL,0},
        /*0x00045020-0x00045024*/
        { 0x00045020, SMEM_FULL_MASK_CNS-0x7, smemChtActiveReadCntrs, 0, NULL,0},
        /*0x00045028*/
        { 0x00045028, SMEM_FULL_MASK_CNS, smemChtActiveReadCntrs, 0, NULL,0},

        /* step 8 from the 'high 32bits of the counter' :
           addresses of the 'high counter' */
        {0x00047414+EFT_STEP_HIGH_TO_LOW_OF_64BIT_COUNTER , SMEM_FULL_MASK_CNS  , smemChtActiveReadCntrs64Bit_high32, EFT_STEP_HIGH_TO_LOW_OF_64BIT_COUNTER, NULL,0},
        {0x00047418+EFT_STEP_HIGH_TO_LOW_OF_64BIT_COUNTER , SMEM_FULL_MASK_CNS  , smemChtActiveReadCntrs64Bit_high32, EFT_STEP_HIGH_TO_LOW_OF_64BIT_COUNTER, NULL,0},
        {0x00047424+EFT_STEP_HIGH_TO_LOW_OF_64BIT_COUNTER , SMEM_FULL_MASK_CNS  , smemChtActiveReadCntrs64Bit_high32, EFT_STEP_HIGH_TO_LOW_OF_64BIT_COUNTER, NULL,0},
        {0x00047428+EFT_STEP_HIGH_TO_LOW_OF_64BIT_COUNTER , SMEM_FULL_MASK_CNS  , smemChtActiveReadCntrs64Bit_high32, EFT_STEP_HIGH_TO_LOW_OF_64BIT_COUNTER, NULL,0},
        {0x00047434+EFT_STEP_HIGH_TO_LOW_OF_64BIT_COUNTER , SMEM_FULL_MASK_CNS  , smemChtActiveReadCntrs64Bit_high32, EFT_STEP_HIGH_TO_LOW_OF_64BIT_COUNTER, NULL,0},
        {0x00047438+EFT_STEP_HIGH_TO_LOW_OF_64BIT_COUNTER , SMEM_FULL_MASK_CNS  , smemChtActiveReadCntrs64Bit_high32, EFT_STEP_HIGH_TO_LOW_OF_64BIT_COUNTER, NULL,0},

        END_BIND_UNIT_ACTIVE_MEM_MAC(devObjPtr,unitPtr)
    }

    {
        SMEM_CHUNK_BASIC_STC  chunksMem[]=
        {
             /*EFT eVlan Attributes Table*/
             {SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00000000, 262144)  , SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(12, 4) , SMEM_BIND_TABLE_MAC(egfEftEVlanAttributesTable)}
             /*Fast Stack Failover Secondary Target Physical Port Table*/
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00040000, 4096)    , SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(10, 4) , SMEM_BIND_TABLE_MAC(secondTargetPort)}
            /*TrgDev to Hash Block Size Mapping Table*/
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00041000, 4096)    , SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(7, 4) , SMEM_BIND_TABLE_MAC(egfEftTrgDevToHashBlockSizeMappingTable)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00042000, 0x00042000)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00042020, 0x00042020)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00042030, 0x0004203C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000420A0, 0x000420A0)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000420B0, 0x000420B0)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00042110, 0x00042110)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00042130, 0x00042130)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00042140, 0x00042140)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00042150, 0x000423CC)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00043000, 0x00043000)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00043100, 0x00043100)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00043108, 0x00043108)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000431D0, 0x000431D0)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00043200, 0x00043280)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00044000, 0x0004401C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00044080, 0x00044380)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00045000, 0x00045028)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00046000, 0x00046000)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00047000, 0x00047004)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00047080, 0x000472FC)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00047380, 0x00047444)}

        };
        GT_U32  numOfChunks = sizeof(chunksMem)/sizeof(SMEM_CHUNK_BASIC_STC);


        smemInitMemChunk(devObjPtr,chunksMem,numOfChunks,unitPtr);
    }

    {
        static SMEM_REGISTER_DEFAULT_VALUE_STC myUnit_registersDefaultValueArr[] =
        {
            /*TrgDev to Hash Block Size Mapping Table*/
             {DUMMY_NAME_PTR_CNS,            0x00041000,         0x0000007f,    4*_1K,    0x0      }

            ,{DUMMY_NAME_PTR_CNS,            0x00042000,         0x000007e0,      1,    0x4        }
            ,{DUMMY_NAME_PTR_CNS,            0x00042020,         0x09401000,      1,    0x4        }
            ,{DUMMY_NAME_PTR_CNS,            0x00042030,         0x000000a0,      1,    0x4        }
            ,{DUMMY_NAME_PTR_CNS,            0x00042110,         0xffff0000,      1,    0x4        }
            ,{DUMMY_NAME_PTR_CNS,            0x00042130,         0x00000001,      2,    0xfd0      }
            ,{DUMMY_NAME_PTR_CNS,            0x00042150,         0x0000fc3f,    128,    0x4        }
            ,{DUMMY_NAME_PTR_CNS,            0x00043108,         0x00000808,      1,    0x4        }
            ,{DUMMY_NAME_PTR_CNS,            0x000431d0,         0x00002040,      2,    0xb0       }
            ,{DUMMY_NAME_PTR_CNS,            0x00044000,         0x00000010,      8,    0x4        }
            ,{DUMMY_NAME_PTR_CNS,            0x00044380,         0x000041e0,      1,    0x4        }
            ,{DUMMY_NAME_PTR_CNS,            0x00047000,         0x00018801,      1,    0x4        }
            ,{DUMMY_NAME_PTR_CNS,            0x00047004,         0x000fff39,      1,    0x4        }
            ,{DUMMY_NAME_PTR_CNS,            0x00047400,         0x003fc1e0,      1,    0x4        }
            ,{DUMMY_NAME_PTR_CNS,            0x00047444,         0x00000008,      1,    0x4        }

            ,{NULL,            0,         0x00000000,      0,    0x0      }
        };
        static SMEM_LINK_LIST_REGISTER_DEFAULT_VALUE_STC list = {myUnit_registersDefaultValueArr,NULL};
        unitPtr->unitDefaultRegistersPtr = &list;
    }


    {/*start of unit EGF_eft */
        GT_U32  eftNumPorts = 1 << devObjPtr->egfNumBitsPerPort;
        {/*start of unit mcFIFO */
            {/*start of unit mcFIFOConfigs */
                {/*0002200+4*n*/
                    GT_U32    n;
                    for(n = 0 ; n < eftNumPorts/32 ; n++) {
                        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->EGF_eft.MCFIFO.MCFIFOConfigs.portToMcFIFOAttributionReg[n] =
                            0x0043200+4*n;
                    }/* end of loop n */
                }/*0002200+4*n*/
                SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->EGF_eft.MCFIFO.MCFIFOConfigs.MCFIFOGlobalConfigs = 0x00043100;
                SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->EGF_eft.MCFIFO.MCFIFOConfigs.MCFIFOArbiterWeights0 = 0x00043108;

            }/*end of unit mcFIFOConfigs */


        }/*end of unit mcFIFO */


        {/*start of unit miscellaneous */
            /*SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->EGF_eft.miscellaneous.badAddrLatchReg = 0x00046000;*/

        }/*end of unit miscellaneous */


        {/*start of unit global */
            {/*0001350+n*0x4*/
                GT_U32    n;
                for(n = 0 ; n < eftNumPorts/32 ; n++) {
                    SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->EGF_eft.global.bypassEGFTargetEPortAttributes[n] =
                        0x00042350+n*0x4;
                }/* end of loop n */
            }/*0001350+n*0x4*/
            {/*0001150+4*n*/
                GT_U32    n;
                for(n = 0 ; n <= 127 ; n++) {
                    SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->EGF_eft.global.cpuPortMapOfReg[n] =
                        0x00042150+4*n;
                }/* end of loop n */
            }/*0001150+4*n*/
            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->EGF_eft.global.EFTInterruptsMask = 0x000420B0;
            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->EGF_eft.global.portIsolationLookup0 = 0x00042020;
            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->EGF_eft.global.portIsolationLookup1 = 0x00042030;
            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->EGF_eft.global.EFTInterruptsCause = 0x000420A0;
            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->EGF_eft.global.cpuPortDist = 0x00042000;
            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->EGF_eft.global.ECCConf = 0x00042130;
            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->EGF_eft.global.ECCStatus = 0x00042140;

        }/*end of unit global */


        {/*start of unit egrFilterConfigs */
            {/*0006100+0x4*n*/
                GT_U32    n;
                for(n = 0 ; n < eftNumPorts/32 ; n++) {
                    SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->EGF_eft.egrFilterConfigs.unregedMCFilterEn[n] =
                        0x0047100+0x4*n;
                }/* end of loop n */
            }/*0006100+0x4*n*/
            {/*0006180+0x4*n*/
                GT_U32    n;
                for(n = 0 ; n < eftNumPorts/32 ; n++) {
                    SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->EGF_eft.egrFilterConfigs.unregedBCFilterEn[n] =
                        0x0047180+0x4*n;
                }/* end of loop n */
            }/*0006180+0x4*n*/
            {/*0006080+0x4*n*/
                GT_U32    n;
                for(n = 0 ; n < eftNumPorts/32 ; n++) {
                    SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->EGF_eft.egrFilterConfigs.unknownUCFilterEn[n] =
                        0x0047080+0x4*n;
                }/* end of loop n */
            }/*0006080+0x4*n*/
            {/*0006380+4*n*/
                GT_U32    n;
                for(n = 0 ; n < eftNumPorts/32 ; n++) {
                    SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->EGF_eft.egrFilterConfigs.physicalPortLinkStatusMask[n] =
                        0x0047380+4*n;
                }/* end of loop n */
            }/*0006380+4*n*/
            {/*0006200+0x4*n*/
                GT_U32    n;
                for(n = 0 ; n < eftNumPorts/32 ; n++) {
                    SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->EGF_eft.egrFilterConfigs.OAMLoopbackFilterEn[n] =
                        0x0047200+0x4*n;
                }/* end of loop n */
            }/*0006200+0x4*n*/
            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->EGF_eft.egrFilterConfigs.egrFiltersGlobal = 0x00047000;
            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->EGF_eft.egrFilterConfigs.egrFiltersEnable = 0x00047004;
            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->EGF_eft.egrFilterConfigs.globalHashSelection = 0x00047400;

        }/*end of unit egrFilterConfigs */


        {/*start of unit deviceMapConfigs */
            {/*0003080+0x4*n*/
                GT_U32    n;
                for(n = 0 ; n < eftNumPorts/32 ; n++) {
                    SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->EGF_eft.deviceMapConfigs.localSrcPortMapOwnDevEn[n] =
                        0x0044080+0x4*n;
                }/* end of loop n */
            }/*0003080+0x4*n*/
            {/*0003100+0x4*n*/
                GT_U32    n;
                for(n = 0 ; n < eftNumPorts/32 ; n++) {
                    SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->EGF_eft.deviceMapConfigs.localTrgPortMapOwnDevEn[n] =
                        0x0044100+0x4*n;
                }/* end of loop n */
            }/*0003100+0x4*n*/
            {/*0003180+4*n*/
                GT_U32    n;
                for(n = 0 ; n < eftNumPorts/8 ; n++) {
                    SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->EGF_eft.deviceMapConfigs.portAddrConstructMode[n] =
                        0x0044180+4*n;
                }/* end of loop n */
            }/*0003180+4*n*/
            {/*0003000+4*p*/
                GT_U32    p;
                for(p = 0 ; p <= 7 ; p++) {
                    SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->EGF_eft.deviceMapConfigs.devMapTableAddrConstructProfile[p] =
                        0x0044000+4*p;
                }/* end of loop p */
            }/*0003000+4*p*/

        }/*end of unit deviceMapConfigs */


        {/*start of unit cntrs */
            {/*0004010+4*n*/
                GT_U32    n;
                for(n = 0 ; n <= 3 ; n++) {
                    SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->EGF_eft.counters.TXQ0MCFIFODropCntr[n] =
                        0x004500c+4*n;
                }/* end of loop n */
            }/*0004010+4*n*/
            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->EGF_eft.counters.descEccCriticalDropCounter = 0x00045000;
            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->EGF_eft.counters.descEccNonCriticalDropCounter = 0x00045004;
            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->EGF_eft.counters.eftDescEcc1ErrorCntr = 0x00045008;

        }/*end of unit cntrs */

        {/*start of unit egress MIB counters */
            GT_U32    n;
            for(n = 0 ; (n <= 1); n++)
            {
                SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->EGF_eft.
                    egrMIBCntrs.egrMIBCntrsPortSetConfig[n]       = 0x0004740c + (n * 4);
                SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->EGF_eft.
                    egrMIBCntrs.egrMIBCntrsSetConfig[n]           = 0x00047404 + (n * 4);
                SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->EGF_eft.
                    egrMIBCntrs.egrMIBMcFIFODroppedPktsCntr[n]    = 0x00047424 + (n * 4);
                SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->EGF_eft.
                    egrMIBCntrs.egrMIBBridgeEgrFilteredPktCntr[n] = 0x00047414 + (n * 4);
                SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->EGF_eft.
                    egrMIBCntrs.egrMIBMcFilteredPktCntr[n]        = 0x00047434 + (n * 4);
            }
        }/*end of unit egress MIB counters */

        {/* start of unit CNC eVlan Configurations */
            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->EGF_eft.
                cncEvlanConfigs.vlanPassDropConfigs     = 0x00047444;
        }/*end of unit CNC eVlan Configurations */
    }/*end of unit EGF_eft */
}

/**
* @internal smemAasUnitTcam function
* @endinternal
*
* @brief   Allocate address type specific memories -- for the TCAM unit
*/
static void smemAasUnitTcam
(
    IN SKERNEL_DEVICE_OBJECT *devObjPtr,
    IN SMEM_UNIT_CHUNKS_STC  *unitPtr
)
{
    GT_U32  tcamNumOfFloors = devObjPtr->tcamNumOfFloors;
    GT_U32  num10bRulesForAddressSpace  = tcamNumOfFloors * (4 * _1K);/* 4 and not 3 , because it also hold the 'jump over index 12..15' */

    START_BIND_UNIT_ACTIVE_MEM_MAC(devObjPtr,unitPtr)

    /* SIP5 Tcam management registers - CPU lookup trigger */
    {0x00702000, SMEM_FULL_MASK_CNS, NULL, 0 , smemLion3ActiveWriteTcamMgLookup,0},
    /* CPU lookup results - 0x007021BC - read only */
    /* register range param:  base - bits27:16, step - bits15:8, num - bits7:0 */
    /* base 1BC, step 0x4, num - (5*4 + 1) = 0x15 - grops0-4 4 hits, group5 1 hit */
    {0x007021BC, 0xFFFFFC00, NULL, 0, smemLion3ActiveWriteProtectReadOnly ,0x01BC0415},
    /* TCAMInterruptCause register */
    {0x00701004, SMEM_FULL_MASK_CNS, smemChtActiveReadIntrCauseReg, 0, smemChtActiveWriteIntrCauseReg, 0},
    {0x0070100c, SMEM_FULL_MASK_CNS, smemChtActiveReadIntrCauseReg, 0, smemChtActiveWriteIntrCauseReg, 0},
    {0x00701000, SMEM_FULL_MASK_CNS, NULL, 0, smemChtActiveGenericWriteInterruptsMaskReg, 0},
    {0x00701008, SMEM_FULL_MASK_CNS, NULL, 0, smemChtActiveGenericWriteInterruptsMaskReg, 0},

    END_BIND_UNIT_ACTIVE_MEM_MAC(devObjPtr,unitPtr)

    {
        SMEM_CHUNK_BASIC_STC  chunksMem[]=
        {
             /* 24 floors : (24 + 256 * 16) = 192K lines : 96K - X lines , 96K - Y lines */
             {SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00000000, 3145728), /* 192K lines * 16 bytes-in-line */
              SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(84, 16),SMEM_BIND_TABLE_MAC(tcamMemory)}
             /* (192K / 4) actions * 64 bytes-in-action */
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00400000, 3145728),
              SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(350, 64),SMEM_BIND_TABLE_MAC(globalActionTable)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00700000, 0x00700018)} /* group / client enable */
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00701000, 0x00701010)} /*interrupts */
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00702000, 0x0070207C)} /*MG*/
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x007021A8, 0x007021A8)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00702308, 0x00702310)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00703000, 0x00703030)} /*parity daemon*/
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x0070303C, 0x0070303C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00704010, 0x00704014)} /*TCAM array*/
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00704100, 0x0070414C)} /*client request counters*/
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00704200, 0x00704224)} /*FIFOs Config*/
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x0070426C, 0x0070426C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00707000, 0x00707008)} /*miscelanous registers*/
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00707010, 0x00707010)}
        };

        GT_U32  numOfChunks = sizeof(chunksMem)/sizeof(SMEM_CHUNK_BASIC_STC);

        chunksMem[0].numOfRegisters = 2/*X,Y*/ * num10bRulesForAddressSpace * (chunksMem[0].enrtyNumBytesAlignement / 4);
        chunksMem[1].numOfRegisters =           (num10bRulesForAddressSpace * (chunksMem[1].enrtyNumBytesAlignement / 4)) / 2;

        smemInitMemChunk(devObjPtr,chunksMem, numOfChunks, unitPtr);
    }

    /* chunks with formulas */
    {
        SMEM_CHUNK_EXTENDED_STC  chunksMem[]=
        {
            /* mapping to group/hit */
            /* TCAM Hit Number and Group Select Floor %n : 0x00700100 + n*0x8: where n (0-23) represents Floor num */
             {{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC(0x00700100 ,0)}, FORMULA_SINGLE_PARAMETER(24,0x8)}

             /* CPU triggered search results */
             /*0x007021BC + i*0x4+n*0x10: where n (0-4) represents TCAM Group Num, where i (0-3) represents Hit Number*/
             ,{{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC(0x007021BC, 0)}, FORMULA_TWO_PARAMETERS(4,0x4,5,0x10)}
             /*0x007021BC + i*0x4+5*0x10: where i (0-0) represents Hit Number*/
             ,{{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC(0x0070220C ,0)}, FORMULA_SINGLE_PARAMETER(1,0x4)}

             /* Subkeys build */
             /* Groups0-4 subkeys0-3 */
             /*0x00705000 + 64*4*4*g +4*4*(n-1) + 4*i: where n (1-63) represents Entry, */
             /*where i (0-3) represents SubKey, where g (0-4) represents Group*/
             ,{{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC(0x00705000, 0),
                 SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(32, 4),
                 SMEM_BIND_TABLE_MAC(tcamGroups0_4ProfileSubkeySizeAndMux)},
                FORMULA_THREE_PARAMETERS(5,0x400, 63,0x10, 4,0x4)}
             /* Group5 subkey */
             /*0x00705000 + 64*4*4*5 +4*4*(n-1) + 4*i: */
             /*where n (1-63) represents Entry, where i (0-0) represents SubKey*/
             ,{{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC(0x00706400 ,0),
                 SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(32, 4),
                 SMEM_BIND_TABLE_MAC(tcamGroups0_5SubkeySharedMux)},
                FORMULA_SINGLE_PARAMETER(63,0x10)}
             /* shared subkey part */
             /*0x00706800 + 64*4*g +4*(n-1): */
             /*where n (1-63) represents Entry, where g (0-5) represents Group*/
             ,{{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC(0x00706800, 0),
                 SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(32, 4),
                 SMEM_BIND_TABLE_MAC(tcamGroups0_5SubkeySharedMux)},
                FORMULA_TWO_PARAMETERS(6,0x100,63,0x4)}

             /* Mux Configuration Table */
             /*0x0070A800 + 4*i+8*4*(n-1)+0x40*8*4*g: where i (0-5) represents 10B, */
             /*where n (1-47) represents 60B line, where g (0-5) represents Group*/
             ,{{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC(0x0070A800, 0),
                 SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(32, 4),
                 SMEM_BIND_TABLE_MAC(tcamGroups0_5SubkeyMux2byteUnits)},
                FORMULA_THREE_PARAMETERS(6,0x800, 47,0x20, 6,0x4)}
       };
        GT_U32  numOfChunks = sizeof(chunksMem)/sizeof(SMEM_CHUNK_EXTENDED_STC);
        SMEM_UNIT_CHUNKS_STC    tmpUnitChunk;

        chunksMem[0].formulaCellArr[0].size = tcamNumOfFloors;

        smemInitMemChunkExt(devObjPtr,chunksMem, numOfChunks, &tmpUnitChunk);

        /*add the tmp unit chunks to the main unit */
        smemInitMemCombineUnitChunks(devObjPtr,unitPtr,&tmpUnitChunk);
    }

    {
        static SMEM_REGISTER_DEFAULT_VALUE_STC myUnit_registersDefaultValueArr[] =
        {
            /* init the X,Y of the tcam */
             {DUMMY_NAME_PTR_CNS,            0x00000000,         0x0000000f,  (192*_1K)/2,    0x20     }
            ,{DUMMY_NAME_PTR_CNS,            0x00000010,         0x0000000f,  (192*_1K)/2,    0x20     }

            ,{DUMMY_NAME_PTR_CNS,            0x00700000,         0x0000001F,      1,    0x0   }
            ,{DUMMY_NAME_PTR_CNS,            0x00703000,         0x00000043,      1,    0x0   }
            ,{DUMMY_NAME_PTR_CNS,            0x00703008,         0x00001fef,      1,    0x0   }
            ,{DUMMY_NAME_PTR_CNS,            0x0070300c,         0x0000000f,      1,    0x0   }
            ,{DUMMY_NAME_PTR_CNS,            0x00703014,         0x0001fff7,      1,    0x0   }
            ,{DUMMY_NAME_PTR_CNS,            0x00703018,         0x00000001,      1,    0x0   }
            ,{DUMMY_NAME_PTR_CNS,            0x0070301c,         0xffffffff,      2,    0x4,      2,    0xc}
            ,{DUMMY_NAME_PTR_CNS,            0x00703024,         0x000fffff,      1,    0x0   }
            ,{DUMMY_NAME_PTR_CNS,            0x00703030,         0x000fffff,      1,    0x0   }
            ,{DUMMY_NAME_PTR_CNS,            0x00704010,         0x00000018,      1,    0x0   } /* numOfFloors */
            ,{DUMMY_NAME_PTR_CNS,            0x00704014,         0x00000002,      1,    0x0   }
            ,{DUMMY_NAME_PTR_CNS,            0x00704104,         0x00000f3f,     10,    0x8   }
            ,{DUMMY_NAME_PTR_CNS,            0x00704200,         0x00000010,     10,    0x4   }
            ,{DUMMY_NAME_PTR_CNS,            0x0070426c,         0x000fffff,      1,    0x0   }
            ,{DUMMY_NAME_PTR_CNS,            0x00707000,         0x00010302,      1,    0x0   }
            ,{DUMMY_NAME_PTR_CNS,            0x00707004,         0x00000202,      1,    0x0   }
            ,{DUMMY_NAME_PTR_CNS,            0x00707008,         0x00000008,      1,    0x0   }
            ,{DUMMY_NAME_PTR_CNS,            0x00707010,         0x0000ffff,      1,    0x0   }

            ,{NULL,            0,         0x00000000,      0,    0x0      }
        };
        static SMEM_LINK_LIST_REGISTER_DEFAULT_VALUE_STC list = {myUnit_registersDefaultValueArr,NULL};

        myUnit_registersDefaultValueArr[0].numOfRepetitions = num10bRulesForAddressSpace;
        myUnit_registersDefaultValueArr[1].numOfRepetitions = num10bRulesForAddressSpace;

        unitPtr->unitDefaultRegistersPtr = &list;
    }
}

/**
* @internal smemAasUnitTti function
* @endinternal
*
* @brief   Allocate address type specific memories -- for the TTI unit
*
* @param[in] devObjPtr                - pointer to device object.
* @param[in,out] unitPtr              - pointer to the unit chunk
*/
static void smemAasUnitTti
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    INOUT SMEM_UNIT_CHUNKS_STC  * unitPtr
)
{
    {
        SMEM_CHUNK_BASIC_STC  chunksMem[]=
        {
             {SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000000, 0x000000B4)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000000F0, 0x00000118)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000120, 0x00000148)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000154, 0x0000018C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000001CC, 0x000001F4)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000200, 0x00000214)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000220, 0x00000220)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000250, 0x00000274)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000300, 0x00000320)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000340, 0x00000348)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000350, 0x000003CC)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000400, 0x0000040C)}
            /* remove after ttiRangeClassification0Entry is deleted */
            /*,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000418, 0x0000080C)}*/

            /*DSCP To DSCP Map - one entry per translation profile
              Each entry holds 64 DSCP values, one per original DSCP value. */
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00070000, 4608),SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(384 , 64),SMEM_BIND_TABLE_MAC(dscpToDscpMap)}
            /*EXP To QosProfile Map - Each entry represents Qos translation profile
              Each entry holds QoS profile for each of 8 EXP values*/
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00072000, 1152),SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(80, 16),SMEM_BIND_TABLE_MAC(expToQoSProfile)}
            /*DSCP To QosProfile Map - holds 72 profiles, each defining a 10bit QoSProfile per each of the 64 DSCP values */
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00074000, 9216),SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(640 , 128),SMEM_BIND_TABLE_MAC(dscpToQoSProfile)}
            /*UP_CFI To QosProfile Map - Each entry holds a QoS profile per each value of {CFI,UP[2:0]} */
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00077000, 2304),SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(160, 32),SMEM_BIND_TABLE_MAC(upToQoSProfile)}

            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001000, 0x0000103C)} /* PPU Profile */
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000012B0, 0x000012B8)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000012C0, 0x0000130C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000013F8, 0x00001428)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001430, 0x000014E8)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001500, 0x00001540)}

            /* next are registers but hold 128 'entries' each */
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00002700, 0x000028FC),SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(32, 4),SMEM_BIND_TABLE_MAC(ttiEmProfileId1Mapping)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00002900, 0x00002AFC),SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(32, 4),SMEM_BIND_TABLE_MAC(ttiEmProfileId2Mapping)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00002C00, 0x00002CFC)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00002E00, 0x00002EFC)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00003000, 0x00003004)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x0000300C, 0x0000300C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00003030, 0x00003034)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00003040, 0x0000307C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00003090, 0x000030AC)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00003200, 0x0000324C),
                SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(32, 4),SMEM_BIND_TABLE_MAC(ttiPacketTypeTcamProfileIdMapping)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00003300, 0x000034FC),
                SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(32, 4),SMEM_BIND_TABLE_MAC(ttiPortAndPacketTypeTcamProfileIdMapping)}

            /*IP2ME*/
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00004000, 0x000057FC)}

            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00007000, 0x0000703C)}

            /* Default Port Protocol eVID and QoS Configuration Table */  /*0x00010000*/
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00010000, 4*(16*NUM_DEF_EPORTS)), SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(32, 4),SMEM_BIND_TABLE_MAC(portProtocolVidQoSConf)}
            /* PCL User Defined Bytes Configuration Memory -- 60 udb's in each entry */
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00020000, 2048), SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(720, 128),SMEM_BIND_TABLE_MAC(ipclUserDefinedBytesConf)}
            /* TTI User Defined Bytes Configuration Memory -- TTI keys based on UDB's : 8 entries support 8 keys*/
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00040000, 1280), SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(384, 64),SMEM_BIND_TABLE_MAC(ttiUserDefinedBytesConf)}
            /* VLAN Translation Table */
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00050000, 16384), SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(15, 4),SMEM_BIND_TABLE_MAC(ingressVlanTranslation)}
            /* Port to Queue Translation Table */
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00060000, NUM_PHY_PORTS*4), SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(18, 4),SMEM_BIND_TABLE_MAC(ttiPort2QueueTranslation)}

            /*Physical Port Attributes*/
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00100000, NUM_PHY_PORTS*16), SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(92, 16),SMEM_BIND_TABLE_MAC(ttiPhysicalPortAttribute)}

            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00110000, 0x001104C0)}/*My_Physical_Port*/
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00110500, 0x00110500)}

            /*Physical Port Attributes 2*/
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00160000, NUM_PHY_PORTS*32), SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(251, 32),SMEM_BIND_TABLE_MAC(ttiPhysicalPort2Attribute)}

            /*Default ePort Attributes (pre-tti lookup eport table)*/
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00210000, NUM_DEF_EPORTS*32), SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(190, 32),SMEM_BIND_TABLE_MAC(ttiPreTtiLookupIngressEPort)}
            /*ePort Attributes (post-tti lookup eport table)*/
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00240000, NUM_EPORTS*8), SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(16, 4),SMEM_BIND_TABLE_MAC(ttiPostTtiLookupIngressEPort)}
            /* QCN to Pause Timer Map*/
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00280000, 256), SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(16, 4),SMEM_BIND_TABLE_MAC(ttiQcnToPauseTimerMap)}

         };
        GT_U32  numOfChunks = sizeof(chunksMem)/sizeof(SMEM_CHUNK_BASIC_STC);

        smemInitMemChunk(devObjPtr,chunksMem,numOfChunks,unitPtr);

    }

    {
        SMEM_CHUNK_BASIC_STC  chunksMem[]=
        {
            /* (new table in sip6) vrf_id eVlan Mapping Table */
             {SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00300000, 262144), SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(15, 4),SMEM_BIND_TABLE_MAC(ttiVrfidEvlanMapping)}
        };
        GT_U32  numOfChunks = sizeof(chunksMem)/sizeof(SMEM_CHUNK_BASIC_STC);
        SMEM_UNIT_CHUNKS_STC    tmpUnitChunk;

        GT_U32  numEVlans = devObjPtr->limitedResources.eVid;
        GT_U32  index = 0;

        /* support Hawk , Phoenix */
        chunksMem[index].numOfRegisters = numEVlans * (chunksMem[index].enrtyNumBytesAlignement / 4);
        index++;

        smemInitMemChunk(devObjPtr,chunksMem, numOfChunks, &tmpUnitChunk);

        /*add the tmp unit chunks to the main unit */
        smemInitMemCombineUnitChunks(devObjPtr,unitPtr,&tmpUnitChunk);
    }

    { /* sip5: chunks with formulas */
        {
            SMEM_CHUNK_EXTENDED_STC  chunksMem[]=
            {
                /* MAC2ME Registers */ /* registers not table -- SMEM_BIND_TABLE_MAC(macToMe)*/
                 {{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC(0x00008000,0)}, FORMULA_TWO_PARAMETERS(6 , 0x4 , 256, 0x20)}
            };

            GT_U32  numOfChunks = sizeof(chunksMem)/sizeof(SMEM_CHUNK_EXTENDED_STC);
            SMEM_UNIT_CHUNKS_STC    tmpUnitChunk;

            smemInitMemChunkExt(devObjPtr,chunksMem, numOfChunks, &tmpUnitChunk);

            /*add the tmp unit chunks to the main unit */
            smemInitMemCombineUnitChunks(devObjPtr,unitPtr,&tmpUnitChunk);
        }
    }

    {
        static SMEM_REGISTER_DEFAULT_VALUE_STC myUnit_registersDefaultValueArr[] =
        {
             /*                          23 LSBits of 'Addr',     val,                      */
             {DUMMY_NAME_PTR_CNS,            0x00000000,         0x30002501,      1,    0x0}
            ,{DUMMY_NAME_PTR_CNS,            0x00000018,         0x65586558,      1,    0x0}
            ,{DUMMY_NAME_PTR_CNS,            0x0000001c,         0x0000000e,      1,    0x0}
            ,{DUMMY_NAME_PTR_CNS,            0x00000024,         0x0000ffff,      1,    0x0}
            ,{DUMMY_NAME_PTR_CNS,            0x00000028,         0x000088e7,      1,    0x0}
            ,{DUMMY_NAME_PTR_CNS,            0x00000030,         0x88488847,      1,    0x0}
            ,{DUMMY_NAME_PTR_CNS,            0x00000034,         0x65586558,      1,    0x0}
            ,{DUMMY_NAME_PTR_CNS,            0x00000038,         0x00003232,      1,    0x0}
            ,{DUMMY_NAME_PTR_CNS,            0x0000003c,         0x0000000d,      1,    0x0}
            ,{DUMMY_NAME_PTR_CNS,            0x00000040,         0xff000000,      1,    0x0}
            ,{DUMMY_NAME_PTR_CNS,            0x00000044,         0x00000001,      1,    0x0}
            ,{DUMMY_NAME_PTR_CNS,            0x0000004c,         0xff020000,      1,    0x0}
            ,{DUMMY_NAME_PTR_CNS,            0x00000050,         0xff000000,      1,    0x0}
            ,{DUMMY_NAME_PTR_CNS,            0x00000054,         0xffffffff,      3,    0x4}
            ,{DUMMY_NAME_PTR_CNS,            0x00000060,         0x00001800,      1,    0x0}
            ,{DUMMY_NAME_PTR_CNS,            0x00000068,         0x186db81b,      1,    0x0}
            ,{DUMMY_NAME_PTR_CNS,            0x0000006c,         0x00000007,      1,    0x0}
            ,{DUMMY_NAME_PTR_CNS,            0x00000070,         0x00008906,      1,    0x0}
            ,{DUMMY_NAME_PTR_CNS,            0x00000084,         0x000fff00,      1,    0x0}
            ,{DUMMY_NAME_PTR_CNS,            0x00000088,         0x3fffffff,      2,    0x4}
            ,{DUMMY_NAME_PTR_CNS,            0x000000f0,         0xffffffff,      4,    0x4,      2,    0x10}
            ,{DUMMY_NAME_PTR_CNS,            0x00000110,         0x0000004b,      1,    0x0}
            ,{DUMMY_NAME_PTR_CNS,            0x00000118,         0x00001320,      1,    0x0}
            ,{DUMMY_NAME_PTR_CNS,            0x00000140,         0x20a6c003,      1,    0x0}
            ,{DUMMY_NAME_PTR_CNS,            0x00000144,         0x24924924,      2,    0x4}
            ,{DUMMY_NAME_PTR_CNS,            0x00000154,         0x0000311f,      1,    0x0}
            ,{DUMMY_NAME_PTR_CNS,            0x00000170,         0x0fffffff,      4,    0x4}
            ,{DUMMY_NAME_PTR_CNS,            0x00000188,         0x1a00003c,      1,    0x0}
            ,{DUMMY_NAME_PTR_CNS,            0x000001e4,         0x00000002,      1,    0x0}
            ,{DUMMY_NAME_PTR_CNS,            0x000001e8,         0x86000104,      1,    0x0}
            ,{DUMMY_NAME_PTR_CNS,            0x000001ec,         0x00600000,      1,    0x0}
            ,{DUMMY_NAME_PTR_CNS,            0x000001f0,         0x000c0000,      1,    0x0}
            ,{DUMMY_NAME_PTR_CNS,            0x000001f4,         0x200BD680,      1,    0x0}
            ,{DUMMY_NAME_PTR_CNS,            0x00000200,         0x030022f3,      1,    0x0}
            ,{DUMMY_NAME_PTR_CNS,            0x00000204,         0x00400000,      1,    0x0}
            ,{DUMMY_NAME_PTR_CNS,            0x00000208,         0x12492492,      1,    0x0}
            ,{DUMMY_NAME_PTR_CNS,            0x0000020c,         0x00000092,      1,    0x0}
            ,{DUMMY_NAME_PTR_CNS,            0x00000210,         0x0180c200,      1,    0x0}
            ,{DUMMY_NAME_PTR_CNS,            0x00000220,         0x000388fb,      1,    0x0}
            ,{DUMMY_NAME_PTR_CNS,            0x00000300,         0x81008100,      4,    0x4}
            ,{DUMMY_NAME_PTR_CNS,            0x00000310,         0xffffffff,      2,    0x8}
            ,{DUMMY_NAME_PTR_CNS,            0x00000340,         0x0000000f,      1,    0x0}
            ,{DUMMY_NAME_PTR_CNS,            0x000013f8,         0x0000ffff,      1,    0x0}
            ,{DUMMY_NAME_PTR_CNS,            0x000013fc,         0x00000118,      1,    0x0}
            ,{DUMMY_NAME_PTR_CNS,            0x00001500,         0x00602492,      1,    0x0}
            ,{DUMMY_NAME_PTR_CNS,            0x00003000,         0x88f788f7,      1,    0x0}
            ,{DUMMY_NAME_PTR_CNS,            0x00003004,         0x013f013f,      1,    0x0}
            ,{DUMMY_NAME_PTR_CNS,            0x0000300c,         0x00000570,      1,    0x0}
            ,{DUMMY_NAME_PTR_CNS,            0x00003090,         0xffffffff,      1,    0x0}
            ,{DUMMY_NAME_PTR_CNS,            0x00003094,         0x88b588b5,      1,    0x0}
            ,{DUMMY_NAME_PTR_CNS,            0x00007000,         0x00224fd0,      4,    0x4}
            ,{DUMMY_NAME_PTR_CNS,            0x00007020,         0x08002001,      4,    0x4}
            ,{DUMMY_NAME_PTR_CNS,            0x00007030,         0x00050000,      4,    0x4}
            ,{DUMMY_NAME_PTR_CNS,            0x00008000,         0x0000ffff,    256,    0x20}/*mac2me*/
            ,{DUMMY_NAME_PTR_CNS,            0x00008008,         0xffffffff,    256,    0x20}/*mac2me*/
            ,{DUMMY_NAME_PTR_CNS,            0x0000800c,         0xffffffff,    256,    0x20}/*mac2me*/
            ,{DUMMY_NAME_PTR_CNS,            0x00110004,         0x00800000,    304,    0x4}/*My Physical Port %p Attributes*/
            ,{DUMMY_NAME_PTR_CNS,            0x00110500,         0x88a8893f,      1,    0x0}
            ,{NULL,                          0,                  0x00000000,      0,    0x0}
        };

        /*9 MSBits of 'Addr', 23 LSBits of 'Addr',     val,    repeat,    skip,      block_repeat, block_skip*/

        static SMEM_LINK_LIST_REGISTER_DEFAULT_VALUE_STC list = {myUnit_registersDefaultValueArr,NULL};
        unitPtr->unitDefaultRegistersPtr = &list;
    }

    {
        START_BIND_UNIT_ACTIVE_MEM_MAC(devObjPtr,unitPtr)

        /* ROC (read only clear) counters */
        /*  CT_byte_count_extarction_fail_counter */
        {0x00000184, SMEM_FULL_MASK_CNS, smemChtActiveReadCntrs, 0, NULL,0},
        /* TTI Engine Interrupt Cause */
        {0x00000004, SMEM_FULL_MASK_CNS, smemChtActiveReadIntrCauseReg,0,smemChtActiveWriteIntrCauseReg,0},
        {0x00000008, SMEM_FULL_MASK_CNS, NULL, 0, smemChtActiveGenericWriteInterruptsMaskReg, 0},

        END_BIND_UNIT_ACTIVE_MEM_MAC(devObjPtr,unitPtr)
    }

}

/**
* @internal smemAasUnitIpcl function
* @endinternal
*
* @brief   Allocate address type specific memories -- for the IPCL unit
*
* @param[in] devObjPtr                - pointer to device object.
* @param[in,out] unitPtr                  - pointer to the unit chunk
*/
static void smemAasUnitIpcl
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    INOUT SMEM_UNIT_CHUNKS_STC  * unitPtr
)
{

    {
        START_BIND_UNIT_ACTIVE_MEM_MAC(devObjPtr,unitPtr)

        /* PCL Unit Interrupt Cause */
        {0x00000004, SMEM_FULL_MASK_CNS, smemChtActiveReadIntrCauseReg, 0, smemChtActiveWriteIntrCauseReg,0},
        {0x00000008, SMEM_FULL_MASK_CNS, NULL, 0, smemChtActiveGenericWriteInterruptsMaskReg, 0},

        END_BIND_UNIT_ACTIVE_MEM_MAC(devObjPtr,unitPtr)
    }

    {
        SMEM_CHUNK_BASIC_STC  chunksMem[]=
        {
            {SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000000, 0x0000003C)}
           ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000044, 0x00000048)}
           ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x0000005C, 0x00000060)}
           ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000070, 0x00000078)}
           ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000080, 0x00000100)}
           ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000110, 0x0000011C)}
           ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000130, 0x00000130)}
           ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000140, 0x00000148)}
           ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000150, 0x00000158)}
           ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00006020, 0x00006028)}
           ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000065C0, 0x000065FC),SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(32, 4),SMEM_BIND_TABLE_MAC(pearsonHash)}
           ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000730, 0x0000073C)}
           ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000744, 0x0000077C)}
           ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000007A0, 0x000007B4)}
           ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00006800, 0x00006850)}
           ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00006860, 0x000068B0)}
           ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000900, 0x00000CFC)}

           ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00001000,  512),SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(160, 32),SMEM_BIND_TABLE_MAC(crcHashMode)}
           ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00002000, 1024),SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(148, 32),SMEM_BIND_TABLE_MAC(crcHashMask)}
            /* next are set below as formula of 3 tables
            {SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00010000, 33280)}
            {SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00020000, 33280)}
            {SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00030000, 33280)}
            */
/*         ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00040000,    0),SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(490,64),SMEM_BIND_TABLE_MAC(ipcl0UdbSelect)}*/
           ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00044000, 7168),SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(490,64),SMEM_BIND_TABLE_MAC(ipcl1UdbSelect)}
/*         ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00048000,    0),SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(490,64),SMEM_BIND_TABLE_MAC(ipcl2UdbSelect)}*/

/*           ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00050000, 0),SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(25,4),SMEM_BIND_TABLE_MAC(ipcl0UdbReplacement)}*/
           ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00052000, 448),SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(25,4),SMEM_BIND_TABLE_MAC(ipcl1UdbReplacement)}
           ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00054000, 448),SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(25,4),SMEM_BIND_TABLE_MAC(ipcl2UdbReplacement)}

/*           ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00003000, 256),SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(24,4),SMEM_BIND_TABLE_MAC(ipcl0SourcePortConfig)}*/
           ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00004000, NUM_PHY_PORTS*4),SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(24,4),SMEM_BIND_TABLE_MAC(ipcl1SourcePortConfig)}
           ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00005000, NUM_PHY_PORTS*4),SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(24,4),SMEM_BIND_TABLE_MAC(ipcl2SourcePortConfig)}
        };
        GT_U32  numOfChunks = sizeof(chunksMem)/sizeof(SMEM_CHUNK_BASIC_STC);

        smemInitMemChunk(devObjPtr,chunksMem,numOfChunks,unitPtr);

    }

    /* chunks with formulas */
    {
        SMEM_CHUNK_EXTENDED_STC  chunksMem[]=
        {
            /* IPCL0,IPCL1,IPCL2 Configuration Table */
            {{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC(0x00020000, 8*(6*_1K)), SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(33, 8),SMEM_BIND_TABLE_MAC(pclConfig)}, FORMULA_SINGLE_PARAMETER(2 , 0x00010000)}
        };
        GT_U32  numOfChunks = sizeof(chunksMem)/sizeof(SMEM_CHUNK_EXTENDED_STC);
        SMEM_UNIT_CHUNKS_STC    tmpUnitChunk;

        smemInitMemChunkExt(devObjPtr,chunksMem, numOfChunks, &tmpUnitChunk);

        /*add the tmp unit chunks to the main unit */
        smemInitMemCombineUnitChunks(devObjPtr,unitPtr,&tmpUnitChunk);
    }


    {
        static SMEM_REGISTER_DEFAULT_VALUE_STC myUnit_registersDefaultValueArr[] =
        {
             {DUMMY_NAME_PTR_CNS,            0x00000000,         0x05e10001,      1,    0x4  }
            ,{DUMMY_NAME_PTR_CNS,            0x0000000c,         0x02801000,      1,    0x4  }
            ,{DUMMY_NAME_PTR_CNS,            0x00000018,         0x0000ffff,      1,    0x4  }
            ,{DUMMY_NAME_PTR_CNS,            0x0000001c,         0x00000028,      1,    0x4  }
            ,{DUMMY_NAME_PTR_CNS,            0x00000020,         0x0000004a,      1,    0x4  }
            ,{DUMMY_NAME_PTR_CNS,            0x00000038,         0x00000fff,      2,    0x4  }
            ,{DUMMY_NAME_PTR_CNS,            0x00000044,         0x3fffffff,      1,    0x4  }
            ,{DUMMY_NAME_PTR_CNS,            0x00000048,         0x0000ffff,      1,    0x4  }
            ,{DUMMY_NAME_PTR_CNS,            0x00000730,         0x00ff0080,      1,    0x4  }
            ,{DUMMY_NAME_PTR_CNS,            0x00000738,         0x00080008,      1,    0x4  }

            ,{NULL,            0,         0x00000000,      0,    0x0      }
        };



        static SMEM_LINK_LIST_REGISTER_DEFAULT_VALUE_STC list = {myUnit_registersDefaultValueArr,NULL};
        unitPtr->unitDefaultRegistersPtr = &list;
    }

}

/**
* @internal smemAasUnitEpcl function
* @endinternal
*
* @brief   Allocate address type specific memories -- for the EPCL unit
*
* @param[in] devObjPtr                - pointer to device object.
* @param[in,out] unitPtr                  - pointer to the unit chunk
*/
static void smemAasUnitEpcl
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    INOUT SMEM_UNIT_CHUNKS_STC  * unitPtr
)
{
    {
        SMEM_CHUNK_BASIC_STC  chunksMem[]=
        {
            {SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000000, 0x00000028)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000030, 0x00000040)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000070, 0x00000074)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000000A0, 0x000000A8)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000000C0, 0x000000C0)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000100, 0x00000110)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000120, 0x0000015C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000164, 0x00000180)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000210, 0x00000214)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000220, 0x00000220)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000250, 0x00000254)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000260, 0x0000026C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000300, 0x00000AFC)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000B00, 0x00000B1C)}
            /* this is registers but treated as memory*/
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000C00, 0x00000C14),SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(31, 4),SMEM_BIND_TABLE_MAC(epclUdbReplacement)}

            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00008000, 4*(4*_1K + NUM_PHY_PORTS)),SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(19, 4),SMEM_BIND_TABLE_MAC(epclConfigTable)}
/*          ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00010000, 6144),SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(364, 64),SMEM_BIND_TABLE_MAC(epclUdbSelect)}*/
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00012000, NUM_PHY_PORTS*4),SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(18, 4),SMEM_BIND_TABLE_MAC(epclTargetPhysicalPortMapping)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00013000, NUM_PHY_PORTS*4),SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(17, 4),SMEM_BIND_TABLE_MAC(epclSourcePhysicalPortMapping)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00014000, 8192),SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(32, 4),SMEM_BIND_TABLE_MAC(epclPortLatencyMonitoring)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00016000, 1024),SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(14, 4),SMEM_BIND_TABLE_MAC(epclExactMatchProfileIdMapping)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00100000, 16*16384) ,SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(96, 16), SMEM_BIND_TABLE_MAC(queueGroupLatencyProfileConfigTable)}
        };
        GT_U32  numOfChunks = sizeof(chunksMem)/sizeof(SMEM_CHUNK_BASIC_STC);

        smemInitMemChunk(devObjPtr,chunksMem,numOfChunks,unitPtr);
    }

    {
        static SMEM_REGISTER_DEFAULT_VALUE_STC myUnit_registersDefaultValueArr[] =
        {
             {DUMMY_NAME_PTR_CNS,            0x00000000,         0x01780115,      1,    0x0      }
            ,{DUMMY_NAME_PTR_CNS,            0x0000000c,         0x00FF0080,      1,    0x0      }
            ,{DUMMY_NAME_PTR_CNS,            0x0000001c,         0x00000808,      1,    0x0      }
            ,{DUMMY_NAME_PTR_CNS,            0x00000020,         0x00000042,      1,    0x0      }
            ,{DUMMY_NAME_PTR_CNS,            0x00000070,         0x00000FFF,      1,    0x0      }
            ,{DUMMY_NAME_PTR_CNS,            0x00000074,         0x76543210,      1,    0x0      }
            ,{DUMMY_NAME_PTR_CNS,            0x000000A0,         0x000000ff,      1,    0x0      }
            ,{DUMMY_NAME_PTR_CNS,            0x000000C0,         0x0000ffff,      1,    0x0      }
            ,{DUMMY_NAME_PTR_CNS,            0x00000100,         0xFFFFFFFF,      5,    0x4      }
            ,{DUMMY_NAME_PTR_CNS,            0x00000170,         0x0000FFFF,      4,    0x4      }
            ,{DUMMY_NAME_PTR_CNS,            0x00000220,         0x00000008,      1,    0x0      }
            ,{DUMMY_NAME_PTR_CNS,            0x00000260,         0x0000FFFF,      4,    0x4      }

            ,{NULL,            0,         0x00000000,      0,    0x0      }
        };

        static SMEM_LINK_LIST_REGISTER_DEFAULT_VALUE_STC list = {myUnit_registersDefaultValueArr,NULL};
        unitPtr->unitDefaultRegistersPtr = &list;
    }
    {
        {/* start of queue offset config */
            GT_U32 i;

            for(i = 0; i <= 7; i++)
                SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->EPCL.queueOffsetLatencyProfileConfig[i] = 0x00000b00 + 0x4*i;
        }/* end of queue offset config*/
    }
}

/**
* @internal smemAasUnitMpcl function
* @endinternal
*
* @brief   Allocate address type specific memories -- for the MPCL unit
*
* @param[in] devObjPtr                - pointer to device object.
* @param[in,out] unitPtr                  - pointer to the unit chunk
*/
static void smemAasUnitMpcl
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    INOUT SMEM_UNIT_CHUNKS_STC  * unitPtr
)
{
    {
        SMEM_CHUNK_BASIC_STC  chunksMem[]=
        {
             {SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000000, 0x00000010)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000034, 0x00000034)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000060, 0x00000060)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000070, 0x00000070)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000110, 0x0000011C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000130, 0x0000013C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000140, 0x00000140)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000150, 0x00000150)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000200, 0x0000020C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000800, 0x00000804)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001000, 0x00001004)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001010, 0x0000120C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000730, 0x0000077C)} /*OAM*/
            /*internal*/
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x0000001C, 0x0000001C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000028, 0x00000028)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000044, 0x00000048)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x0000005C, 0x0000005C)}

            /* this is registers but treated as memory*/
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00000900, 1024),SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(14, 4),SMEM_BIND_TABLE_MAC(mpclExactMatchProfileIdMapping)}
            /* tables */
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00010000, 4*(4*_1K + NUM_PHY_PORTS)),SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(18, 4),SMEM_BIND_TABLE_MAC(mpclConfigTable)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00003000, NUM_PHY_PORTS*4),SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(24, 4),SMEM_BIND_TABLE_MAC(mpclSourcePortCfgTable)}
        };
        GT_U32  numOfChunks = sizeof(chunksMem)/sizeof(SMEM_CHUNK_BASIC_STC);

        smemInitMemChunk(devObjPtr,chunksMem,numOfChunks,unitPtr);
    }

    {
        static SMEM_REGISTER_DEFAULT_VALUE_STC myUnit_registersDefaultValueArr[] =
        {
             {DUMMY_NAME_PTR_CNS,            0x00000000,         0x00351001,      1,    0x0      }
            ,{DUMMY_NAME_PTR_CNS,            0x0000000C,         0x00001000,      1,    0x0      }
            ,{DUMMY_NAME_PTR_CNS,            0x00000034,         0x00000FFF,      1,    0x0      }
            ,{DUMMY_NAME_PTR_CNS,            0x00000110,         0x0000FFFF,      4,    0x4      }

            ,{NULL,            0,         0x00000000,      0,    0x0      }
        };

        static SMEM_LINK_LIST_REGISTER_DEFAULT_VALUE_STC list = {myUnit_registersDefaultValueArr,NULL};
        unitPtr->unitDefaultRegistersPtr = &list;
    }
}

/**
* @internal smemAasUnitHa function
* @endinternal
*
* @brief   Allocate address type specific memories -- for the HA unit
*
* @param[in] devObjPtr                - pointer to device object.
* @param[in,out] unitPtr              - pointer to the unit chunk
*/
static void smemAasUnitHa
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    INOUT SMEM_UNIT_CHUNKS_STC  * unitPtr
)
{
    {
        START_BIND_UNIT_ACTIVE_MEM_MAC(devObjPtr,unitPtr)

        /* HA Interrupt Cause Register */
        {0x00000300, SMEM_FULL_MASK_CNS,
            smemChtActiveReadIntrCauseReg, 12 /*parent summary bit*/, smemChtActiveWriteIntrCauseReg, 0},
        /* HA Interrupt Mask Register */
        {0x00000304, SMEM_FULL_MASK_CNS,
            NULL, 0, smemLion3ActiveWriteHaInterruptsMaskReg, 0},

        /* ROC (read only clear) counters */
        /*HA Oversize Tags Drop Counter*/
        { 0x0000030C, SMEM_FULL_MASK_CNS, smemChtActiveReadCntrs, 0, NULL,0},
        /*HA ECC or SER Drop Counter*/
        { 0x00000310, SMEM_FULL_MASK_CNS, smemChtActiveReadCntrs, 0, NULL,0},
        /*Nat Exception Drop Counter*/
        { 0x00000314, SMEM_FULL_MASK_CNS, smemChtActiveReadCntrs, 0, NULL,0},
        /*HA Set<<%s>> traffic counter - 2 registers*/
        { 0x000003C0, SMEM_FULL_MASK_CNS, smemChtActiveReadCntrs, 0, NULL,0},
        { 0x000003C4, SMEM_FULL_MASK_CNS, smemChtActiveReadCntrs, 0, NULL,0},

        END_BIND_UNIT_ACTIVE_MEM_MAC(devObjPtr,unitPtr)
    }

    {
        SMEM_CHUNK_BASIC_STC  chunksMem[]=
        {
             {SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000000, 0x00000058)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000060, 0x0000006C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000080, 0x000000A4)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000140, 0x00000144)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000150, 0x0000016C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000300, 0x00000314)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000003C0, 0x000003C4)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000003D0, 0x000003D4)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000408, 0x00000410)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000420, 0x00000428)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000430, 0x00000434)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000500, 0x0000053C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000550, 0x00000560)}/* after we do the change in MPLSEtherType need to change 0x00000550 to be 0x00000554*/
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000570, 0x00000570)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000590, 0x000005AC)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000600, 0x0000067C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000710, 0x00000720)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000800, 0x000009FC)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000A04, 0x00000A18)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000A2C, 0x00000A2C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000A34, 0x00000A7C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000AC0, 0x00000B3C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000C00, 0x000013FC)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001C00, 0x000023FC)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00002C00, 0x00002C08)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00002CA4, 0x00002CB4)}

            /*HA Physical Port Table 1*/                                   /*0x4000*/
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00008000, 16*NUM_PHY_PORTS),SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(81, 16), SMEM_BIND_TABLE_MAC(haEgressPhyPort1)}
            /*EPCL User Defined Bytes Configuration Memory*/
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x0000C000, 2048),SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(720,128), SMEM_BIND_TABLE_MAC(haEpclUserDefinedBytesConfig)}
            /*Analyzers Target Circuits Table*/
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x0000D000, 504),SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(44,8), SMEM_BIND_TABLE_MAC(haAnalyzersTargetCircuits)}
            /*QoS Mapping Table*/
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00010000, 9216),SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(68,16), SMEM_BIND_TABLE_MAC(haQosMapping)}
             /*HA Trg Physical Port Table 2*/                                  /*0x4000*/
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00014000, 16*NUM_PHY_PORTS),SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(99, 16), SMEM_BIND_TABLE_MAC(haEgressPhyPort2)}
             /*HA Src Physical Port Table 2*/
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00018000, 4*NUM_PHY_PORTS),SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(20, 4), SMEM_BIND_TABLE_MAC(haIngressPhyPort2)}

            /*HA QoS Profile to EXP Table*/                                /*0x1000*/
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00020000, 4096),SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(3, 4), SMEM_BIND_TABLE_MAC(haQosProfileToExp)}
             /*HA Global MAC SA Table*/
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00030000, 32768),SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(48, 8), SMEM_BIND_TABLE_MAC(haGlobalMacSa)}

            /*PTP Domain table*/
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x000D0000, 40960) , SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(35, 8), SMEM_BIND_TABLE_MAC(haPtpDomain)}
            /*Generic TS Profile table*/
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x000C0000, 4096), SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(573,128), SMEM_BIND_TABLE_MAC(tunnelStartGenericIpProfile) }

            /*HA Ingress ePort Attribute Table 2*/                         /*0x10000*/
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x000E0000, 4*NUM_EPORTS),SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(13, 4), SMEM_BIND_TABLE_MAC(haIngressEPortAttr2)}
            /*HA Egress ePort Attribute Table 2*/                         /*0x10000*/
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x000F0000, 4*NUM_EPORTS),SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(24, 4), SMEM_BIND_TABLE_MAC(haEgressEPortAttr2)}
            /*HA Egress ePort Attribute Table 1*/                         /*0x40000*/
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00100000, 16*NUM_EPORTS),SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(112,16), SMEM_BIND_TABLE_MAC(haEgressEPortAttr1)}
             /*HA Ingress ePort Attribute Table 1*/                         /*0x20000*/
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00200000, 8*NUM_EPORTS),SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(44, 8), SMEM_BIND_TABLE_MAC(haIngressEPortAttr2)}

            /* Target Circuits Table*/
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00300000, 1048576),SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(196,32), SMEM_BIND_TABLE_MAC(haTargetCircuits)}
             /* HA Queue Mapping Table*/
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00400000, 262144),SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(80,16), SMEM_BIND_TABLE_MAC(haQueueMapping)}

            /*Header Fields Table 0*/
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x02000000, 16777216),SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(784 ,128), SMEM_BIND_TABLE_MAC(haHeaderFieldsTable0)}
            /*Header Fields Table 1 */
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x01000000, 16777216),SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(784 ,128), SMEM_BIND_TABLE_MAC(haHeaderFieldsTable1)}

        };
        GT_U32  numOfChunks = sizeof(chunksMem)/sizeof(SMEM_CHUNK_BASIC_STC);

        smemInitMemChunk(devObjPtr,chunksMem,numOfChunks,unitPtr);
    }

    {
        SMEM_CHUNK_BASIC_STC  chunksMem[]=
        {
             /*EVLAN Table (was 'vlan translation' in legacy device)*/    /*0x40000*/
            {SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00040000, 4*NUM_EVIDS),SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(28, 4), SMEM_BIND_TABLE_MAC(egressVlanTranslation)}
            /*VLAN MAC SA Table (was 'VLAN/Port MAC SA Table' in legacy device)*/
                                                                          /*0x40000*/
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00080000, 4*NUM_EVIDS), SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(12, 4), SMEM_BIND_TABLE_MAC(vlanPortMacSa)}

            /*Router ARP DA */                                             /*0x00800000*/
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x04000000, (NUM_ARPS/8)*64),SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(384,64), SMEM_BIND_SHARED_TABLE_MAC(arpTable)}
            /*Tunnel Start Table*/                                          /*0x04000000*/
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x03000000, (NUM_TS/2)*256),SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(1584 ,256), SMEM_BIND_SHARED_TABLE_MAC(tunnelStartTable)}

        };

        GT_U32 index = 0;
        GT_U32  numEVlans = devObjPtr->limitedResources.eVid;
        GT_U32  numArps = devObjPtr->limitedResources.numOfArps;
        GT_U32  numTs = devObjPtr->limitedResources.numOfTs;
        /* number of entries : evlans  . keep alignment and use for memory size */
        chunksMem[index].numOfRegisters =  numEVlans     * (chunksMem[index].enrtyNumBytesAlignement / 4);
        index++;
        /* number of entries : evlans  . keep alignment and use for memory size */
        chunksMem[index].numOfRegisters =  numEVlans     * (chunksMem[index].enrtyNumBytesAlignement / 4);
        index++;
        /* number of entries : 8 ARPs in line . keep alignment and use for memory size */
        chunksMem[index].numOfRegisters = (numArps/8)    * (chunksMem[index].enrtyNumBytesAlignement / 4);
        index++;
        /* number of entries : 2 TS in line . keep alignment and use for memory size */
        chunksMem[index].numOfRegisters = (numTs/8)      * (chunksMem[index].enrtyNumBytesAlignement / 4);
        index++;

        smemUnitChunkAddBasicChunk(devObjPtr,unitPtr,
            ARRAY_NAME_AND_NUM_ELEMENTS_MAC(chunksMem));
    }

    {
        static SMEM_REGISTER_DEFAULT_VALUE_STC myUnit_registersDefaultValueArr[] =
        {
             {DUMMY_NAME_PTR_CNS,            0x00000000,         0x00101010,      1,    0x0}
            ,{DUMMY_NAME_PTR_CNS,            0x00000004,         0x03fdd003,      1,    0x0}
            ,{DUMMY_NAME_PTR_CNS,            0x00000008,         0x0000000c,      1,    0x0}
            ,{DUMMY_NAME_PTR_CNS,            0x00000080,         0xff000000,      1,    0x0}
            ,{DUMMY_NAME_PTR_CNS,            0x00000084,         0x00000001,      1,    0x0}
            ,{DUMMY_NAME_PTR_CNS,            0x0000008c,         0xff020000,      1,    0x0}
            ,{DUMMY_NAME_PTR_CNS,            0x00000090,         0xffffffff,      4,    0x4}
            ,{DUMMY_NAME_PTR_CNS,            0x000000a4,         0x00000003,      1,    0x0}
            ,{DUMMY_NAME_PTR_CNS,            0x000003d4,         0x00000002,      1,    0x0}
            ,{DUMMY_NAME_PTR_CNS,            0x00000408,         0x81000000,      2,    0x4}
            ,{DUMMY_NAME_PTR_CNS,            0x00000410,         0x00010000,      1,    0x0}
            ,{DUMMY_NAME_PTR_CNS,            0x00000424,         0x00110000,      1,    0x0}
            ,{DUMMY_NAME_PTR_CNS,            0x00000500,         0x00008100,      8,    0x4}
            ,{DUMMY_NAME_PTR_CNS,            0x00000550,         0x88488847,      1,    0x0}/* after we do the change in MPLSEtherType need to delete this line */
            ,{DUMMY_NAME_PTR_CNS,            0x00000554,         0x00008100,      1,    0x0}
            ,{DUMMY_NAME_PTR_CNS,            0x00000558,         0x000022f3,      1,    0x0}
            ,{DUMMY_NAME_PTR_CNS,            0x0000055c,         0x00006558,      1,    0x0}
            ,{DUMMY_NAME_PTR_CNS,            0x00000570,         0x00180000,      1,    0x0}
            ,{DUMMY_NAME_PTR_CNS,            0x00000710,         0x0000ffff,      1,    0x0}
            ,{DUMMY_NAME_PTR_CNS,            0x00000714,         0x000037bf,      1,    0x0}
            ,{DUMMY_NAME_PTR_CNS,            0x00000718,         0x03d1f0f4,      1,    0x0}
            ,{DUMMY_NAME_PTR_CNS,            0x0000071c,         0x00000803,      1,    0x0}
            ,{DUMMY_NAME_PTR_CNS,            0x00000720,         0x00020100,      1,    0x0}
            ,{DUMMY_NAME_PTR_CNS,            0x00000a04,         0x00008000,      1,    0x0}
            ,{DUMMY_NAME_PTR_CNS,            0x00000a18,         0x00000181,      1,    0x0}
            ,{DUMMY_NAME_PTR_CNS,            0x00000a2c,         0x00000188,      1,    0x0}
            ,{DUMMY_NAME_PTR_CNS,            0x00000a3c,         0x005d5500,      1,    0x0}
            ,{DUMMY_NAME_PTR_CNS,            0x00002ca4,         0x88488847,      4,    0x4}

            ,{NULL,                          0x00000000,         0x00000000,      0,    0x0}
        };

        static SMEM_LINK_LIST_REGISTER_DEFAULT_VALUE_STC list =
                {myUnit_registersDefaultValueArr,NULL};

        unitPtr->unitDefaultRegistersPtr = &list;
    }
}

/**
* @internal smemSip6_30ActiveWriteSmuSngIrfEntry function
* @endinternal
*
* @brief   Write the Smu Sng Irf entry.
*
* @param[in] devObjPtr                - device object PTR.
* @param[in] address                  - Address for ASIC memory.
* @param[in] memPtr                   - Pointer to the register's memory in the simulation.
* @param[in] param                    - Registers' specific parameter.
* @param[in] inMemPtr                 - Pointer to the memory to get register's content.
*/
static void smemSip6_30ActiveWriteSmuSngIrfEntry(
    IN         SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN         GT_U32   address,
    IN         GT_U32   memSize,
    IN         GT_U32 * memPtr,
    IN         GT_UINTPTR   param,
    IN         GT_U32 * inMemPtr
)
{
    GT_U32  tempEntryArr[2];
    GT_U32  origEntryArr[2];
    GT_U32  streamNumber = (address & 0x3FFF)>>2;/* entry index for the LOG*/
    GT_U32  tmpValue,ii;
    GT_U32  *internalDataPtr = smemTableInternalDataPtrGet(devObjPtr,address,NULL);
    GT_U32  roFields[] = {
         SMEM_SIP6_30_SMU_IRF_SNG_TABLE_FIELDS_IRF_RECOVERY_SEQUENCE_NUM_E
        ,SMEM_SIP6_30_SMU_IRF_SNG_TABLE_FIELDS_SNG_PACKET_COUNTER_E
        /* must be last */
        ,SMAIN_NOT_VALID_CNS
    };

    /*the entry as the CPU wanted to set the entry */
    tempEntryArr[0] = internalDataPtr[0]; /* word in internalDataOffset */
    tempEntryArr[1] =          *inMemPtr;

    /*the entry as the exists before we modify it */
    origEntryArr[0] = memPtr[-1]; /* word in the orig entry */
    origEntryArr[1] = memPtr[ 0]; /* word in the orig entry */

    /* we need to make sure that 'RO' (read only) are not modified in the process ! */
    for(ii = 0 ; roFields[ii] != SMAIN_NOT_VALID_CNS ; ii++)
    {
        tmpValue =
        SMEM_SIP6_30_SMU_IRF_SNG_FIELD_GET(devObjPtr,origEntryArr,
            streamNumber,
            roFields[ii]);

        SMEM_SIP6_30_SMU_IRF_SNG_FIELD_SET(devObjPtr,tempEntryArr,
            streamNumber,
            roFields[ii],
            tmpValue);
    }

    if(SMEM_SIP6_30_SMU_IRF_SNG_FIELD_GET(devObjPtr,
        tempEntryArr,
        streamNumber,
        SMEM_SIP6_30_SMU_IRF_SNG_TABLE_FIELDS_SNG_RESET_PACKET_COUNTER_E))
    {
        SMEM_SIP6_30_SMU_IRF_SNG_FIELD_SET(devObjPtr,
            tempEntryArr,
            streamNumber,
            SMEM_SIP6_30_SMU_IRF_SNG_TABLE_FIELDS_SNG_PACKET_COUNTER_E,
            0x0);
        SMEM_SIP6_30_SMU_IRF_SNG_FIELD_SET(devObjPtr,
            tempEntryArr,
            streamNumber,
            SMEM_SIP6_30_SMU_IRF_SNG_TABLE_FIELDS_SNG_RESET_PACKET_COUNTER_E,
            0x0);
    }

    /* copy to the actual entry place */
    memPtr[-1] = tempEntryArr[0];
    memPtr[ 0] = tempEntryArr[1];

    return;
}

/**
* @internal smemAasUnitSmu function
* @endinternal
*
* @brief   Allocate address type specific memories -- for the SMU unit
*
* @param[in] devObjPtr                - pointer to device object.
* @param[in,out] unitPtr                  - pointer to the unit chunk
*/
static void smemAasUnitSmu
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    INOUT SMEM_UNIT_CHUNKS_STC  * unitPtr
)
{
    {
        START_BIND_UNIT_ACTIVE_MEM_MAC(devObjPtr,unitPtr)

        /* SMEM_BIND_TABLE_WITH_LIMITED_WRITE_MAC(smuSngIrf) : support 'RO' fields */
        /* 0x00004000 .. 0x00007ffc */
        {0x00004000, 0xFFFFC004, smemChtActiveReadEntryWithSnapShot, 0 ,NULL, 0},
        {0x00004004, 0xFFFFC004, smemChtActiveReadEntryWithSnapShot, 0 ,smemSip6_30ActiveWriteSmuSngIrfEntry, 0},
        /*SMEM_BIND_TABLE_MAC(smuIrfCounters) 0x00020000..0x0003fffc
          all fields are ROC */
        {0x00020000, 0xFFFE0000, smemChtActiveReadEntryWithSnapShot, 0xEEEEEEEE, smemChtActiveWriteToReadOnlyReg,0},

        END_BIND_UNIT_ACTIVE_MEM_MAC(devObjPtr,unitPtr)
    }

    {   /* handle tables with snapshot that need 'postStartSnapshotWriteFunc'
       (see SMEM_CHT_READ_ENTRY_SNAP_SHOT_INFO_STC)*/
        GT_U32  ii;

        devObjPtr->tablesInfo.snapShot.smuIrfCounters.postStartSnapshotWriteFunc = smemChtPostStartSnapshotWriteClearEntry;

        for(ii = 0 ; unitPtr->unitActiveMemPtr[ii].address != END_OF_TABLE; ii++)
        {
            if(unitPtr->unitActiveMemPtr[ii].readFunParam == 0xEEEEEEEE)
            {
                unitPtr->unitActiveMemPtr[ii].readFunParam = (GT_UINTPTR)&devObjPtr->tablesInfo.snapShot.smuIrfCounters;
            }
        }
    }

    {
        SMEM_CHUNK_BASIC_STC  chunksMem[]=
        {
             {SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000000, 0x0000000C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000040, 0x00000094)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000200, 0x00000204)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001000, 0x00001000)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001008, 0x00001008)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001020, 0x0000111C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00004000, 16384),SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(36, 8),SMEM_BIND_TABLE_WITH_LIMITED_WRITE_MAC(smuSngIrf)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00020000, 65536),SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(146, 32),SMEM_BIND_TABLE_MAC(smuIrfCounters)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00040000, 0x00040010)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00040018, 0x00040018)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00040020, 0x00040020)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00040028, 0x00040028)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00040030, 0x00040030)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00040034, 0x00040034)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00040038, 0x0004003C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00040050, 0x00040050)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00040060, 0x00040060)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00040070, 0x00040070)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00040150, 0x00040180)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00041000, 1024),SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(32, 4),SMEM_BIND_TABLE_MAC(smuSgcIntervalMax)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00042000, 928) ,SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(110, 16),SMEM_BIND_TABLE_MAC(smuSgcTableSetTimeConfigurations)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00044000, 1856),SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(32, 4),SMEM_BIND_TABLE_MAC(smuSgcOctetCounters)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00050000, 59392),SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(32, 4),SMEM_BIND_TABLE_MAC(smuSgcTimeToAdvance)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00080000, 237568),SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(120, 16),SMEM_BIND_TABLE_MAC(smuSgcTimeSlotAttributes)}
        };
        GT_U32  numOfChunks = sizeof(chunksMem)/sizeof(SMEM_CHUNK_BASIC_STC);

        smemInitMemChunk(devObjPtr,chunksMem,numOfChunks,unitPtr);
    }

    {
        static SMEM_REGISTER_DEFAULT_VALUE_STC myUnit_registersDefaultValueArr[] =
        {
             {DUMMY_NAME_PTR_CNS,     0x00000000,         0x0000ffff,      1,    0x4}
            ,{DUMMY_NAME_PTR_CNS,     0x0000005C,         0xFFFFFFFF,      2,    0x14}
            ,{DUMMY_NAME_PTR_CNS,     0x00000078,         0xFFFFFFFF,      1,    0x4}
            ,{DUMMY_NAME_PTR_CNS,     0x00000084,         0x0000007F,      1,    0x4}

            ,{DUMMY_NAME_PTR_CNS,     0x00000200,         0x00000248,      2,    0x4}
            ,{DUMMY_NAME_PTR_CNS,     0x00001000,         0x0000000c,      1,    0x4}
            ,{DUMMY_NAME_PTR_CNS,     0x00001008,         0x000002aa,      1,    0x4}
            ,{DUMMY_NAME_PTR_CNS,     0x00040004,         0x001C8001,      1,    0x4}

            /* SNG_IRF table (smuSngIrf) */
            ,{DUMMY_NAME_PTR_CNS,     0x00004000,         0x0001FFFE,  2*_1K,    0x8}

            ,{NULL,            0,         0x00000000,      0,    0x0      }
        };

        static SMEM_LINK_LIST_REGISTER_DEFAULT_VALUE_STC list = {myUnit_registersDefaultValueArr,NULL};
        unitPtr->unitDefaultRegistersPtr = &list;
    }

    {
        GT_U32 n;

        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->SMU.smuMiscellaneous.smuBadAddrLatchReg = 0x00000004;
        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->SMU.smuMiscellaneous.smuInterruptCause  = 0x00000008;
        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->SMU.smuMiscellaneous.smuInterruptMask   = 0x0000000C;

        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->SMU.debug.todNanoSec = 0x00000040;
        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->SMU.debug.todSecLsb  = 0x00000044;
        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->SMU.debug.todSecMsb  = 0x00000048;

        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->SMU.irfSng.irfSngGlobalConfig          = 0x00001000;
        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->SMU.irfSng.irfSngCountersFieldsConfig  = 0x00001008;
        for(n = 0 ; n <= 63 ; n++)
        {
            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->SMU.irfSng.irfAgeBit[n]          = 0x00001020 + n*0x4;
        }

        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->SMU.streamGateControl.sgcGlobalConfig           = 0x00040000;
        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->SMU.streamGateControl.sgcGlobalScanConfig       = 0x00040004;
        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->SMU.streamGateControl.sgcReconfigTodMsbHigh     = 0x00040010;
        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->SMU.streamGateControl.sgcReconfigTodMsbLow      = 0x00040018;
        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->SMU.streamGateControl.sgcReconfigTodLsb         = 0x00040020;
        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->SMU.streamGateControl.sgcReconfigTableSetConfig = 0x00040028;
        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->SMU.streamGateControl.sgcReconfigPendingStatus  = 0x00040030;
        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->SMU.streamGateControl.sgcReconfigValidStatus    = 0x00040034;

        for(n = 0 ; n <= 1 ; n++)
        {
            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->SMU.streamGateControl.sgcTableSetIsActive[n] = 0x00040038 + 0x04*n;
        }

        for(n = 0 ; n <= 12 ; n++)
        {
            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->SMU.streamGateControl.sgcGateId2TableSetConfig[n] = 0x00040150 + 0x4*n;
        }
    }
}


/*******************************************************************************
*  smemAasActiveCncBlockReadIsMatch_64bits
*
* DESCRIPTION:
*      Function finds if address is in the CNC counters of 64 bits
*
* INPUTS:
*       deviceObjPtr    - device object PTR.
*       address         - address to find in register's DB
*       param           - specific parameter
*
* OUTPUTS:
*       None
*
* RETURNS:
*       GT_TRUE     - the address found in register DB
*       GT_FALSE    - the address not found in register DB
*
* COMMENTS:
*
*******************************************************************************/
GT_BOOL smemAasActiveCncBlockReadIsMatch_64bits
(
    IN        SKERNEL_DEVICE_OBJECT * deviceObjPtr,
    IN        GT_U32 address,
    IN        GT_UINTPTR param
)
{
    SMEM_ACTIVE_MEM_ENTRY_STC  * activeMemoryPtr = (SMEM_ACTIVE_MEM_ENTRY_STC *)param;
    GT_U32  activeAddress   = activeMemoryPtr->address & (CNC_UNIT_ALIGNMENT_SIZE-1);
    GT_U32  relativeAddress = address                  & (CNC_UNIT_ALIGNMENT_SIZE-1);

    if(relativeAddress < activeAddress)
    {
        /* the address is below the address to match */
        return GT_FALSE;
    }

    if(relativeAddress >= ((0x00020000/*step*/ * 16/*blocks*/) + activeAddress))
    {
        /* the address is above the address to match */
        return GT_FALSE;
    }

    /* the address is in the range , and match the step */
    return GT_TRUE;
}

/**
* @internal smemAasUnitCnc function
* @endinternal
*
* @brief   Allocate address type specific memories -- for the CNC unit
*
* @param[in] devObjPtr                - pointer to device object.
* @param[in,out] unitPtr                  - pointer to the unit chunk
*/
static void smemAasUnitCnc
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    INOUT SMEM_UNIT_CHUNKS_STC  * unitPtr
)
{
    START_BIND_UNIT_ACTIVE_MEM_MAC(devObjPtr,unitPtr)
    ACTIVE_MEM_SIP7_CNC_COMMON_MAC
    END_BIND_UNIT_ACTIVE_MEM_MAC(devObjPtr,unitPtr)

    {
        SMEM_CHUNK_BASIC_STC  chunksMem[]=
        {
             {SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000000, 0x00000000)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000024, 0x00000024)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000030, 0x00000030)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000040, 0x00000044)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000100, 0x00000104)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000180, 0x00000180)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000190, 0x00000190)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000001A4, 0x000001A4)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000001B8, 0x000001B8)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000001CC, 0x000001CC)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000001E0, 0x000001E8)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000310, 0x00000314)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001098, 0x00001098)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00001198, 16*0x20)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001398, 0x0000139c)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00001498, 16*0x10)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00001598, 16*0x20)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00001798, 16*0x20)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00001998, 16*0x4)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00001A18, 16*0x4)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001A98, 0x00001A9c)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00001C98, 16*0x30)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00020000, 16 *  8192 * 16), SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(128,16)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00220000, 16 * 16384 *  8), SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(64,8),SMEM_BIND_TABLE_MAC(cncMemory)}
        };
        GT_U32  numOfChunks = sizeof(chunksMem)/sizeof(SMEM_CHUNK_BASIC_STC);

        smemInitMemChunk(devObjPtr,chunksMem,numOfChunks,unitPtr);
    }

    {
        static SMEM_REGISTER_DEFAULT_VALUE_STC myUnit_registersDefaultValueArr[] =
        {
            /*CNC Global Configuration Register*/
             {DUMMY_NAME_PTR_CNS,     0x00000000,         0x03E647CB,      1,    0x4}
            /*CNC Metal Fix Register*/
            ,{DUMMY_NAME_PTR_CNS,     0x00000180,         0xFFFF0000,      1,    0x4}
            /*CNC Blocks Rate Limit Fifo Thr*/
            ,{DUMMY_NAME_PTR_CNS,     0x00001098,         0xFFFFFFFF,      1,    0x4}

            ,{NULL,            0,         0x00000000,      0,    0x0      }
        };

        static SMEM_LINK_LIST_REGISTER_DEFAULT_VALUE_STC list = {myUnit_registersDefaultValueArr,NULL};
        unitPtr->unitDefaultRegistersPtr = &list;
    }
}

/*******************************************************************************
*  smemSip6_30ActiveWritePreqSrfConfigMemory
*
* DESCRIPTION:
*      active Write to memory : support 'RO' fields , when write to preqSrfConfig
*
* INPUTS:
*       devObjPtr   - device object PTR.
*       address     - Address for ASIC memory.
*       memSize     - size of the requested memory
*       memPtr      - Pointer to the register's memory in the simulation.
*       param       - Registers' specific parameter.
*       inMemPtr    - Pointer to the memory to get register's content.
*
* OUTPUTS:
*
* RETURNS:
*
* COMMENTS:
*
*******************************************************************************/
static void smemSip6_30ActiveWritePreqSrfConfigMemory(
    IN         SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN         GT_U32   address,
    IN         GT_U32   memSize,
    IN         GT_U32 * memPtr,  /*target*/
    IN         GT_UINTPTR param,
    IN         GT_U32 * inMemPtr/*source*/
)
{
    GT_U32  tempEntryArr[3];
    GT_U32  origEntryArr[3];
    GT_U32  srfNumber = (address & 0xFFF0)>>4;/* entry index for the LOG*/
    GT_U32  tmpValue,ii;
    GT_U32  *internalDataPtr = smemTableInternalDataPtrGet(devObjPtr,address,NULL);
    GT_U32  roFields[] = {
         SMEM_SIP6_30_PREQ_SRF_CONFIG_TABLE_FIELDS_RECOV_SEQ_NUM_E
        ,SMEM_SIP6_30_PREQ_SRF_CONFIG_TABLE_FIELDS_ROGUE_PKTS_CNT_E
        ,SMEM_SIP6_30_PREQ_SRF_CONFIG_TABLE_FIELDS_CUR_BUFFER_E
        ,SMEM_SIP6_30_PREQ_SRF_CONFIG_TABLE_FIELDS_CUR_BIT_E
        /* must be last */
        ,SMAIN_NOT_VALID_CNS
    };

    /*the entry as the CPU wanted to set the entry */
    tempEntryArr[0] = internalDataPtr[0]; /* word in internalDataOffset */
    tempEntryArr[1] = internalDataPtr[1]; /* word in internalDataOffset */
    tempEntryArr[2] =          *inMemPtr;

    /*the entry as the exists before we modify it */
    origEntryArr[0] = memPtr[-2]; /* word in the orig entry */
    origEntryArr[1] = memPtr[-1]; /* word in the orig entry */
    origEntryArr[2] = memPtr[ 0]; /* word in the orig entry */

    /* we need to make sure that 'RO' (read only) are not modified in the process ! */
    for(ii = 0 ; roFields[ii] != SMAIN_NOT_VALID_CNS ; ii++)
    {
        tmpValue =
        SMEM_SIP6_30_PREQ_SRF_CONFIG_FIELD_GET(devObjPtr,origEntryArr,
            srfNumber,
            roFields[ii]);

        SMEM_SIP6_30_PREQ_SRF_CONFIG_FIELD_SET(devObjPtr,tempEntryArr,
            srfNumber,
            roFields[ii],
            tmpValue);
    }

    /* copy to the actual entry place */
    memPtr[-2] = tempEntryArr[0];
    memPtr[-1] = tempEntryArr[1];
    memPtr[ 0] = tempEntryArr[2];
}


/*******************************************************************************
*  smemSip6_30ActiveWritePreqSrfDaemonsMemory
*
* DESCRIPTION:
*      active Write to memory : support 'RO' fields , when write to preqDaemons
*
* INPUTS:
*       devObjPtr   - device object PTR.
*       address     - Address for ASIC memory.
*       memSize     - size of the requested memory
*       memPtr      - Pointer to the register's memory in the simulation.
*       param       - Registers' specific parameter.
*       inMemPtr    - Pointer to the memory to get register's content.
*
* OUTPUTS:
*
* RETURNS:
*
* COMMENTS:
*
*******************************************************************************/
static void smemSip6_30ActiveWritePreqSrfDaemonsMemory(
    IN         SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN         GT_U32   address,
    IN         GT_U32   memSize,
    IN         GT_U32 * memPtr,  /*target*/
    IN         GT_UINTPTR param,
    IN         GT_U32 * inMemPtr/*source*/
)
{
    GT_U32  tempEntryArr[3];
    GT_U32  origEntryArr[3];
    GT_U32  srfNumber = (address & 0xFFF0)>>4;/* entry index for the LOG*/
    GT_U32  tmpValue,ii;
    GT_U32  *internalDataPtr = smemTableInternalDataPtrGet(devObjPtr,address,NULL);
    GT_U32  roFields[] = {
         SMEM_SIP6_30_PREQ_SRF_DAEMON_TABLE_FIELDS_NUMBER_OF_RESETS_E
        ,SMEM_SIP6_30_PREQ_SRF_DAEMON_TABLE_FIELDS_LE_BASE_DIFFERENCE_E
        ,SMEM_SIP6_30_PREQ_SRF_DAEMON_TABLE_FIELDS_LE_TIME_SINCE_LAST_RESET_E
        /* must be last */
        ,SMAIN_NOT_VALID_CNS
    };

    /*the entry as the CPU wanted to set the entry */
    tempEntryArr[0] = internalDataPtr[0]; /* word in internalDataOffset */
    tempEntryArr[1] = internalDataPtr[1]; /* word in internalDataOffset */
    tempEntryArr[2] =          *inMemPtr;

    /*the entry as the exists before we modify it */
    origEntryArr[0] = memPtr[-2]; /* word in the orig entry */
    origEntryArr[1] = memPtr[-1]; /* word in the orig entry */
    origEntryArr[2] = memPtr[ 0]; /* word in the orig entry */

    /* we need to make sure that 'RO' (read only) are not modified in the process ! */
    for(ii = 0 ; roFields[ii] != SMAIN_NOT_VALID_CNS ; ii++)
    {
        tmpValue =
        SMEM_SIP6_30_PREQ_SRF_DAEMON_FIELD_GET(devObjPtr,origEntryArr,
            srfNumber,
            roFields[ii]);

        SMEM_SIP6_30_PREQ_SRF_DAEMON_FIELD_SET(devObjPtr,tempEntryArr,
            srfNumber,
            roFields[ii],
            tmpValue);
    }

    /* copy to the actual entry place */
    memPtr[-2] = tempEntryArr[0];
    memPtr[-1] = tempEntryArr[1];
    memPtr[ 0] = tempEntryArr[2];
}

/*******************************************************************************
*  smemSip6_30ActiveWritePreqSrfCountersMemory
*
* DESCRIPTION:
*      active Write to memory : support 'RO' fields , when write to preqSrfCounters
*
* INPUTS:
*       devObjPtr   - device object PTR.
*       address     - Address for ASIC memory.
*       memSize     - size of the requested memory
*       memPtr      - Pointer to the register's memory in the simulation.
*       param       - Registers' specific parameter.
*       inMemPtr    - Pointer to the memory to get register's content.
*
* OUTPUTS:
*
* RETURNS:
*
* COMMENTS:
*
*******************************************************************************/
static void smemSip6_30ActiveWritePreqSrfCountersMemory(
    IN         SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN         GT_U32   address,
    IN         GT_U32   memSize,
    IN         GT_U32 * memPtr,  /*target*/
    IN         GT_UINTPTR param,
    IN         GT_U32 * inMemPtr/*source*/
)
{
    GT_U32  tempEntryArr[5];
    GT_U32  origEntryArr[5];
    GT_U32  srfNumber = (address & 0xFFE0)>>5;/* entry index for the LOG*/
    GT_U32  tmpValue,ii;
    GT_U32  *internalDataPtr = smemTableInternalDataPtrGet(devObjPtr,address,NULL);
    GT_U32  roFields[] = {
         SMEM_SIP6_30_PREQ_SRF_COUNTERS_TABLE_FIELDS_PASSED_PKTS_CNT_E
        ,SMEM_SIP6_30_PREQ_SRF_COUNTERS_TABLE_FIELDS_DISCARDED_PKTS_CNT_E
        ,SMEM_SIP6_30_PREQ_SRF_COUNTERS_TABLE_FIELDS_OUT_OF_ORDER_PKTS_CNT_E
        ,SMEM_SIP6_30_PREQ_SRF_COUNTERS_TABLE_FIELDS_CLEARED_ZERO_HIST_CNT_E
        ,SMEM_SIP6_30_PREQ_SRF_COUNTERS_TABLE_FIELDS_RESTART_COUNTER_E
        /* must be last */
        ,SMAIN_NOT_VALID_CNS
    };

    /*the entry as the CPU wanted to set the entry */
    tempEntryArr[0] = internalDataPtr[0]; /* word in internalDataOffset */
    tempEntryArr[1] = internalDataPtr[1]; /* word in internalDataOffset */
    tempEntryArr[2] = internalDataPtr[2]; /* word in internalDataOffset */
    tempEntryArr[3] = internalDataPtr[3]; /* word in internalDataOffset */
    tempEntryArr[4] =          *inMemPtr;

    /*the entry as the exists before we modify it */
    origEntryArr[0] = memPtr[-4]; /* word in the orig entry */
    origEntryArr[1] = memPtr[-3]; /* word in the orig entry */
    origEntryArr[2] = memPtr[-2]; /* word in the orig entry */
    origEntryArr[3] = memPtr[-1]; /* word in the orig entry */
    origEntryArr[4] = memPtr[ 0]; /* word in the orig entry */

    /* we need to make sure that 'RO' (read only) are not modified in the process ! */
    for(ii = 0 ; roFields[ii] != SMAIN_NOT_VALID_CNS ; ii++)
    {
        tmpValue =
        SMEM_SIP6_30_PREQ_SRF_COUNTERS_FIELD_GET(devObjPtr,origEntryArr,
            srfNumber,
            roFields[ii]);

        SMEM_SIP6_30_PREQ_SRF_COUNTERS_FIELD_SET(devObjPtr,tempEntryArr,
            srfNumber,
            roFields[ii],
            tmpValue);
    }

    /* copy to the actual entry place */
    memPtr[-4] = tempEntryArr[0];
    memPtr[-3] = tempEntryArr[1];
    memPtr[-2] = tempEntryArr[2];
    memPtr[-1] = tempEntryArr[3];
    memPtr[ 0] = tempEntryArr[4];
}


/**
* @internal smemAasUnitPreq function
* @endinternal
*
* @brief   Allocate address type specific memories -- for the PREQ unit
*
* @param[in] devObjPtr                - pointer to device object.
* @param[in,out] unitPtr                  - pointer to the unit chunk
*/
static void smemAasUnitPreq
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    INOUT SMEM_UNIT_CHUNKS_STC  * unitPtr
)
{
#define PREQ_STEP_HIGH_TO_LOW_OF_64BIT_COUNTER 0x8
    {
        START_BIND_UNIT_ACTIVE_MEM_MAC(devObjPtr,unitPtr)

        /* ROC (read only clear) 64 bits counters :
           next are addresses of the 'high counter' */
        { 0x00000710+PREQ_STEP_HIGH_TO_LOW_OF_64BIT_COUNTER, SMEM_FULL_MASK_CNS, smemChtActiveReadCntrs64Bit_high32, PREQ_STEP_HIGH_TO_LOW_OF_64BIT_COUNTER, NULL,0},
        { 0x00000714+PREQ_STEP_HIGH_TO_LOW_OF_64BIT_COUNTER, SMEM_FULL_MASK_CNS, smemChtActiveReadCntrs64Bit_high32, PREQ_STEP_HIGH_TO_LOW_OF_64BIT_COUNTER, NULL,0},
        { 0x00000720+PREQ_STEP_HIGH_TO_LOW_OF_64BIT_COUNTER, SMEM_FULL_MASK_CNS, smemChtActiveReadCntrs64Bit_high32, PREQ_STEP_HIGH_TO_LOW_OF_64BIT_COUNTER, NULL,0},
        { 0x00000724+PREQ_STEP_HIGH_TO_LOW_OF_64BIT_COUNTER, SMEM_FULL_MASK_CNS, smemChtActiveReadCntrs64Bit_high32, PREQ_STEP_HIGH_TO_LOW_OF_64BIT_COUNTER, NULL,0},
        { 0x00000730+PREQ_STEP_HIGH_TO_LOW_OF_64BIT_COUNTER, SMEM_FULL_MASK_CNS, smemChtActiveReadCntrs64Bit_high32, PREQ_STEP_HIGH_TO_LOW_OF_64BIT_COUNTER, NULL,0},
        { 0x00000734+PREQ_STEP_HIGH_TO_LOW_OF_64BIT_COUNTER, SMEM_FULL_MASK_CNS, smemChtActiveReadCntrs64Bit_high32, PREQ_STEP_HIGH_TO_LOW_OF_64BIT_COUNTER, NULL,0},
        { 0x00000750+PREQ_STEP_HIGH_TO_LOW_OF_64BIT_COUNTER, SMEM_FULL_MASK_CNS, smemChtActiveReadCntrs64Bit_high32, PREQ_STEP_HIGH_TO_LOW_OF_64BIT_COUNTER, NULL,0},
        { 0x00000754+PREQ_STEP_HIGH_TO_LOW_OF_64BIT_COUNTER, SMEM_FULL_MASK_CNS, smemChtActiveReadCntrs64Bit_high32, PREQ_STEP_HIGH_TO_LOW_OF_64BIT_COUNTER, NULL,0},
        { 0x00000760+PREQ_STEP_HIGH_TO_LOW_OF_64BIT_COUNTER, SMEM_FULL_MASK_CNS, smemChtActiveReadCntrs64Bit_high32, PREQ_STEP_HIGH_TO_LOW_OF_64BIT_COUNTER, NULL,0},
        { 0x00000764+PREQ_STEP_HIGH_TO_LOW_OF_64BIT_COUNTER, SMEM_FULL_MASK_CNS, smemChtActiveReadCntrs64Bit_high32, PREQ_STEP_HIGH_TO_LOW_OF_64BIT_COUNTER, NULL,0},

        /* PREQ Unit Interrupt Cause */
        /*PREQ.preqInterrupts.preqInterruptCause*/
        {0x00000600, SMEM_FULL_MASK_CNS, smemChtActiveReadIntrCauseReg, 0, smemChtActiveWriteIntrCauseReg,0},
        /*PREQ.preqInterrupts.preqInterruptMask*/
        {0x00000604, SMEM_FULL_MASK_CNS, NULL, 0, smemChtActiveGenericWriteInterruptsMaskReg, 0},

        /* SMEM_BIND_TABLE_WITH_LIMITED_WRITE_MAC(preqSrfConfig) : support 'RO' fields */
        {0x00030008,0xFFFF000F, NULL, 0, smemSip6_30ActiveWritePreqSrfConfigMemory,0},
        /* SMEM_BIND_TABLE_WITH_LIMITED_WRITE_MAC(preqDaemons) : support 'RO' fields */
        {0x00040008,0xFFFF000F, NULL, 0, smemSip6_30ActiveWritePreqSrfDaemonsMemory,0},
        /* SMEM_BIND_TABLE_WITH_LIMITED_WRITE_MAC(preqSrfCounters) : support 'RO' fields */
        {0x00060010,0xFFFF001F, NULL, 0, smemSip6_30ActiveWritePreqSrfCountersMemory,0},


        END_BIND_UNIT_ACTIVE_MEM_MAC(devObjPtr,unitPtr)
    }
    {
        SMEM_CHUNK_BASIC_STC  chunksMem[]=
        {
            {SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000000, 0x00000000)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000054, 0x00000054)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000100, 0x0000012C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000340, 0x000003D8)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000400, 0x00000420)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x0000042C, 0x00000458)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000600, 0x00000608)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000700, 0x0000073C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000750, 0x0000076C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000800, 0x00000850)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000860, 0x00000864)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000900, 0x0000097C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001100, 0x00001120)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001200, 0x0000127C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001300, 0x0000137C)}
             /* PREQ Port Profile Table */
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC(0x00001400,  512),
                SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(104, 16), SMEM_BIND_TABLE_MAC(preqPortProfile)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00001600, 128),
              SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(16, 4),SMEM_BIND_TABLE_MAC(preqZeroBitVector0)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00001700, 128),
             SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(16, 4),SMEM_BIND_TABLE_MAC(preqZeroBitVector1)}
             /* PREQ Target Physical Port Table */
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC(0x00002000, 4*NUM_PHY_PORTS),
                SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC( 19,  4), SMEM_BIND_TABLE_MAC(preqTargetPhyPort)}
             /* PREQ Queue Port Mapping Table*/
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC(0x00003000, 4*CNC_QUEUE_PORT_MAPPING_MEMORY_NUM),
                SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC( 26,  4), SMEM_BIND_TABLE_MAC(preqQueuePortMapping)}

             /*CPSS_DXCH_SIP7_PREQ_PORT_PROFILE_BIND_E*/
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00004000, 4096)}

            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00010000, 65536)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00020000, 32768),
              SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(76, 16),SMEM_BIND_TABLE_MAC(preqSrfMapping)}

            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00030000, 16384),
             SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(91, 16),SMEM_BIND_TABLE_WITH_LIMITED_WRITE_MAC(preqSrfConfig)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00040000, 16384),
                SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(79, 16),SMEM_BIND_TABLE_WITH_LIMITED_WRITE_MAC(preqDaemons)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00050000, 16384),
              SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(128, 16),SMEM_BIND_TABLE_MAC(preqHistoryBuffer)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00060000, 32768),
              SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(160, 32),SMEM_BIND_TABLE_WITH_LIMITED_WRITE_MAC(preqSrfCounters)}

            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00080000, 524288)}
        };
        GT_U32  numOfChunks = sizeof(chunksMem)/sizeof(SMEM_CHUNK_BASIC_STC);

        smemInitMemChunk(devObjPtr,chunksMem,numOfChunks,unitPtr);
    }
    {
        GT_U32 n;
        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->PREQ.globalConfig = 0x00000000;
        for (n = 0; (n <= 1); n++)
        {
            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->PREQ.
                egrMIBCntrs.egrMIBCntrsPortSetConfig[n] = 0x00000708 + (4 * n);
            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->PREQ.
                egrMIBCntrs.egrMIBCntrsSetConfig[n]     = 0x00000700 + (4 * n);
            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->PREQ.
                egrMIBCntrs.egrMIBTailDroppedPktCntr[n] = 0x00000750 + (4 * n);
            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->PREQ.
                egrMIBCntrs.egrMIBOutgoingUcPktCntr[n]  = 0x00000710 + (4 * n);
            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->PREQ.
                egrMIBCntrs.egrMIBOutgoingMcPktCntr[n]  = 0x00000720 + (4 * n);
            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->PREQ.
                egrMIBCntrs.egrMIBOutgoingBcPktCntr[n]  = 0x00000730 + (4 * n);
            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->PREQ.
                egrMIBCntrs.egrMIBCtrlPktCntr[n]        = 0x00000760 + (4 * n);
        }
    }
    /*FRE*/
    {
        GT_U32 ii;
        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->PREQ.FRE.freSrfGlobalConfig0 = 0x00001100;
        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->PREQ.FRE.freSrfGlobalConfig1 = 0x00001104;
        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->PREQ.FRE.freGlobalConfig     = 0x00001108;
        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->PREQ.FRE.LatentErrorPeriod   = 0x0000110C;
        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->PREQ.FRE.RestartPeriod       = 0x00001110;
        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->PREQ.FRE.ArbiterPriority     = 0x00001114;
        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->PREQ.FRE.ArbiterWeights      = 0x00001118;
        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->PREQ.FRE.DaemonsRangeControl = 0x0000111C;

        for(ii = 0 ; ii < 32 ; ii++)
        {
            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->PREQ.FRE.ErrorDetected[ii]   = 0x00001200 + ii * 4;
            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->PREQ.FRE.TakeAny      [ii]   = 0x00001300 + ii * 4;
        }
    }

    {/*preqInterrupts*/
        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->PREQ.preqInterrupts.preqInterruptCause =  0x00000600;
        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->PREQ.preqInterrupts.preqInterruptMask  =  0x00000604;
        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->PREQ.preqInterrupts.preqBadAddressLatch  =  0x00000608;
    }

{
  static SMEM_REGISTER_DEFAULT_VALUE_STC myUnit_registersDefaultValueArr[] =
    {
         {DUMMY_NAME_PTR_CNS,           0x00000000,         0x00000003,      1,    0x4    }/*Global_Config*/
        ,{DUMMY_NAME_PTR_CNS,           0x00000054,         0x0000ffff,      1,    0x4    }/*PREQ_Metal_Fix*/
        ,{DUMMY_NAME_PTR_CNS,           0x00000100,         0x00000050,      1,    0x4    }/*Fifos_Depth*/
        ,{DUMMY_NAME_PTR_CNS,           0x00000828,         0x0000001f,      1,    0x4    }/*ingress_pkt_config*/
        ,{DUMMY_NAME_PTR_CNS,           0x00000860,         0x0000007f,      1,    0x4    }/*query_fifo_min_peak*/
        ,{DUMMY_NAME_PTR_CNS,           0x00000450,         0x007fffff,      1,    0x4    }/*global_tail_drop_limit_high*/
        ,{DUMMY_NAME_PTR_CNS,           0x0000041c,         0x007fffff,      2,    0x4    }/*mc_td_configuration*/
        ,{DUMMY_NAME_PTR_CNS,           0x0000044c,         0x007fffff,      1,    0x4    }/*global_tail_drop_limit_low*/
        ,{DUMMY_NAME_PTR_CNS,           0x00001100,         0x00001803,      1,    0x4    }/*FRE_SRF_Global_Config_0*/
        ,{DUMMY_NAME_PTR_CNS,           0x00001104,         0x00060003,      1,    0x4    }/*FRE_SRF_Global_Config_1*/
        ,{DUMMY_NAME_PTR_CNS,           0x0000110c,         0x07bfa480,      1,    0x4    }/*Latent_Error_Period*/
        ,{DUMMY_NAME_PTR_CNS,           0x00001110,         0x00c65d40,      1,    0x4    }/*Restart_Period*/
        ,{DUMMY_NAME_PTR_CNS,           0x00001114,         0x01012492,      1,    0x4    }/*Arbiter_Priority*/
        ,{DUMMY_NAME_PTR_CNS,           0x00001118,         0x04924924,      1,    0x4    }/*Arbiter_Weights*/
        ,{DUMMY_NAME_PTR_CNS,           0x0000111c,         0x000ffc00,      1,    0x4    }/*Daemons_Range_Control*/
        ,{DUMMY_NAME_PTR_CNS,           0x00001120,         0x00b0d400,      1,    0x4    }/*Daemons_Delay_Control*/
        ,{DUMMY_NAME_PTR_CNS,           0x00002000,         0x00000001,      1024,    0x4    }/*Target_Physical_Port_Memory*/
        ,{NULL,                         0,                  0x00000000,      0,    0x0  }
    };
  static SMEM_LINK_LIST_REGISTER_DEFAULT_VALUE_STC list = {myUnit_registersDefaultValueArr,NULL};
  unitPtr->unitDefaultRegistersPtr = &list;
}


}

/**
* @internal smemAasUnitLpm function
* @endinternal
*
* @brief   Allocate address type specific memories -- for the
*          AAS LPM unit
*/
static void smemAasUnitLpm
(
    IN SKERNEL_DEVICE_OBJECT *devObjPtr,
    IN SMEM_UNIT_CHUNKS_STC  *unitPtr
)
{
    if(unitPtr->chunkType == SMEM_UNIT_CHUNK_TYPE_9_MSB_E)
    {
        unitPtr->numOfUnits = 64;/*2*4; supports 8 '23 bits' address units */
    }

    {
        START_BIND_UNIT_ACTIVE_MEM_MAC(devObjPtr,unitPtr)

        /* LPM Memory Table - One BANK of 256K lines*/
        { 0x00000000 , SMEM_FULL_MASK_CNS-0x007FFFFF, smemAasActiveReadLpm, 0, smemAasActiveWriteLpm,0},

        END_BIND_UNIT_ACTIVE_MEM_MAC(devObjPtr,unitPtr)
    }

    {
        SMEM_CHUNK_BASIC_STC  chunksMem[]=
        {
            {SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC(0x00000000, ((256*1024)*32)),
                     SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(132, 32),SMEM_BIND_TABLE_MAC(lpmMemorySingleBank)},

            {SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00F80000, NUM_VRFS*16),
                     SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(75, 16),SMEM_BIND_TABLE_MAC(lpmCommonVrfId)},
            {SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00800000, 3932160),
                     SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(32, 4),SMEM_BIND_TABLE_MAC(lpmAgingMemory)}

            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00F00000, 0x00F00008)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00F00010, 0x00F00010)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00F00020, 0x00F00020)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00F000F0, 0x00F000F0)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00F00120, 0x00F00120)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00F00130, 0x00F00130)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00F00200, 0x00F00240)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00F00250, 0x00F0026C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00F00300, 0x00F00374)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00F00400, 0x00F00474)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00F00500, 0x00F00540)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00F00600, 0x00F00600)}
        };

        GT_U32  numOfChunks = sizeof(chunksMem)/sizeof(SMEM_CHUNK_BASIC_STC);
        smemInitMemChunk(devObjPtr,chunksMem, numOfChunks, unitPtr);
    }

    {
        static SMEM_REGISTER_DEFAULT_VALUE_STC myUnit_registersDefaultValueArr[] =
        {
            {DUMMY_NAME_PTR_CNS,         0x00f00000,         0x00000001,      1,    0x0}
            ,{DUMMY_NAME_PTR_CNS,         0x00f00010,         0x05000000,      1,    0x0}
            ,{DUMMY_NAME_PTR_CNS,         0x00f000f0,         0x0000ffff,      1,    0x0}
            ,{NULL,            0,         0x00000000,         0,               0x0      }
        };
        static SMEM_LINK_LIST_REGISTER_DEFAULT_VALUE_STC list = {myUnit_registersDefaultValueArr,NULL};
        unitPtr->unitDefaultRegistersPtr = &list;
    }

    {
        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->LPM.globalConfig       = 0x00F00000;
        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->LPM.lpmMemBankId       = 0x00F00004;
        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->LPM.directAccessMode   = 0x00F00010;
        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->LPM.exceptionStatus    = 0x00F00020;
        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->LPM.LPMGeneralIntCause = 0x00F00120;
        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->LPM.LPMGeneralIntMask  = 0x00F00130;
    }

}

/**
* @internal smemAasUnitIpvx function
* @endinternal
*
* @brief   Allocate address type specific memories -- for the ipvx unit
*/
static void smemAasUnitIpvx
(
    IN SKERNEL_DEVICE_OBJECT *devObjPtr,
    IN SMEM_UNIT_CHUNKS_STC  *unitPtr
)
{
     START_BIND_UNIT_ACTIVE_MEM_MAC(devObjPtr,unitPtr)
     /* 64 bit counter (take 2 registers) */
         {0x00000950 , SMEM_FULL_MASK_CNS  , smemChtActiveReadCntrs64Bit, 1, NULL,0},
         {0x00000954 , SMEM_FULL_MASK_CNS  , smemChtActiveReadCntrs64Bit, 1, NULL,0},
     END_BIND_UNIT_ACTIVE_MEM_MAC(devObjPtr,unitPtr)
     {
         SMEM_CHUNK_BASIC_STC  chunksMem[]=
         {
             {SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000000, 0x00000028)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000030, 0x0000004C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000100, 0x00000104)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000200, 0x00000204)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000250, 0x0000026C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000278, 0x00000294)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000360, 0x00000364)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000380, 0x00000380)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000900, 0x00000924)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000940, 0x00000948)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000950, 0x00000958)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000968, 0x00000978)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000980, 0x00000988)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000A00, 0x00000A24)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000A80, 0x00000A88)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000B00, 0x00000B24)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000B80, 0x00000B88)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000C00, 0x00000C24)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000C80, 0x00000C88)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000E00, 0x00000E2C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000F00, 0x00000F10)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000F20, 0x00000F20)}

             /* Router QoS Profile Offsets Table */
             ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00010000, 1024),SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(12, 4),SMEM_BIND_TABLE_MAC(ipvxQoSProfileOffsets)}
             /* Router Acces Matrix Table */
             ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00060000, 3072),SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(128, 16),SMEM_BIND_TABLE_MAC(ipvxAccessMatrix)}
              /* Router L3NHE Profile Table */
             ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00070000, 4096),SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(85, 16),SMEM_BIND_TABLE_MAC(ipvxL3NheProfile)}
             /* Router EPort Table */
             ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC(0x00200000, 16384),SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(112, 16),SMEM_BIND_TABLE_MAC(ipvxIngressEPort)}
             /* Router ECMP pointer Table : 4 'pointers' per line */
             ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00300000, 786432),SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(72, 16),SMEM_BIND_TABLE_MAC(ipvxEcmpPointer)}
         };

         GT_U32  numOfChunks = sizeof(chunksMem)/sizeof(SMEM_CHUNK_BASIC_STC);
         smemInitMemChunk(devObjPtr,chunksMem, numOfChunks, unitPtr);
    }

    {
        SMEM_CHUNK_BASIC_STC  chunksMem[]=
        {
            /* Router Next Hop Table */
            {SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00400000, 1572864),SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(129, 32),SMEM_BIND_TABLE_MAC(ipvxNextHop)}
            /* Router Next Hop Table Age Bits */
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC(0x00020000,   24576),SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(32, 4),SMEM_BIND_TABLE_MAC(routeNextHopAgeBits)}
            /* Router EVlan Table */
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC(0x00100000, 1048576),SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(66, 16),SMEM_BIND_TABLE_MAC(ipvxIngressEVlan)}
            /* Router ECMP table : 2 entries per line */
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00280000, 131072),SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(64,  8),SMEM_BIND_TABLE_MAC(ipvxEcmp)}
        };
        GT_U32  numNextHop = devObjPtr->limitedResources.nextHop;/* support Hawk and Phoenix */
        GT_U32  numEVlans = devObjPtr->limitedResources.eVid;
        GT_U32  ipvxEcmp  = devObjPtr->limitedResources.ipvxEcmp;
        GT_U32  index = 0;
        /* number of entries : numNextHop . keep alignment and use for memory size */
        chunksMem[index].numOfRegisters = numNextHop * (chunksMem[index].enrtyNumBytesAlignement / 4);
        index++;
        /* number of entries : (numNextHop/32) . keep alignment and use for memory size */
        chunksMem[index].numOfRegisters = (numNextHop/32) * (chunksMem[index].enrtyNumBytesAlignement / 4);
        index++;
        /* number of entries : (numEVlans) . keep alignment and use for memory size */
        chunksMem[index].numOfRegisters = numEVlans * (chunksMem[index].enrtyNumBytesAlignement / 4);
        index++;
        /* number of entries : (ipvxEcmp) . keep alignment and use for memory size */
        chunksMem[index].numOfRegisters = ipvxEcmp * (chunksMem[index].enrtyNumBytesAlignement / 4);
        index++;

        smemUnitChunkAddBasicChunk(devObjPtr,unitPtr,
            ARRAY_NAME_AND_NUM_ELEMENTS_MAC(chunksMem));
    }

    {
        static SMEM_REGISTER_DEFAULT_VALUE_STC myUnit_registersDefaultValueArr[] =
        {
             /* Router Global Control0                                     */
              {DUMMY_NAME_PTR_CNS,             0x00000000,         0x00000027,      1,    0x0}
              /* Router Global Control1                                     */
             ,{DUMMY_NAME_PTR_CNS,             0x00000004,         0x0380001c,      1,    0x0}
              /* Router Global Control2                                     */
             ,{DUMMY_NAME_PTR_CNS,             0x00000008,         0x00000fff,      1,    0x0}
             /* Router MTU Configuration Register                          */
             ,{DUMMY_NAME_PTR_CNS,             0x00000010,         0x017705dc,      4,    0x4}
              /* IPv4 Control Register0; IPv6 Control Register0             */
             ,{DUMMY_NAME_PTR_CNS,             0x00000100,         0x1b79b01b,      2,    0x100}
              /* IPv4 Control Register1                                     */
             ,{DUMMY_NAME_PTR_CNS,             0x00000104,         0x001b665b,      1,    0x0}
             /* IPv6 Control Register1                                     */
             ,{DUMMY_NAME_PTR_CNS,             0x00000204,         0x0000661b,      1,    0x0}
             /* IPv6 Unicast Scope Prefix 0                                */
             ,{DUMMY_NAME_PTR_CNS,             0x00000250,         0xffc0fe80,      1,    0x0}
             /* IPv6 Unicast Scope Prefix 1                                */
             ,{DUMMY_NAME_PTR_CNS,             0x00000254,         0xfe00fc00,      1,    0x0}
              /* IPv6 Unicast Scope Level 1                                 */
             ,{DUMMY_NAME_PTR_CNS,             0x00000264,         0x00000001,      1,    0x0}
              /* IPv6 Unicast Scope Level 2; IPv6 Unicast Scope Level 3     */
             ,{DUMMY_NAME_PTR_CNS,             0x00000268,         0x00000003,      2,    0x4}
              /* Routing ECMP Configurations                                */
             ,{DUMMY_NAME_PTR_CNS,             0x00000360,         0x00006140,      1,    0x0}
             /* Routing ECMP Seed                                          */
             ,{DUMMY_NAME_PTR_CNS,             0x00000364,         0xffffffff,      1,    0x0}
             /* Router FCoE Global Configuration                           */
             ,{DUMMY_NAME_PTR_CNS,             0x00000380,         0x001b9360,      1,    0x0}
             /* Router Metal Fix                                           */
             ,{DUMMY_NAME_PTR_CNS,             0x00000968,         0x0000ffff,      1,    0x0}
             /* Router FIFOs threshold 1                                   */
             ,{DUMMY_NAME_PTR_CNS,             0x00000978,         0x000fffff,      1,    0x0}
             /* CPU Codes 0                                                */
             ,{DUMMY_NAME_PTR_CNS,             0x00000e00,         0x88878685,      1,    0x0}
             /* CPU Codes 1                                                */
             ,{DUMMY_NAME_PTR_CNS,             0x00000e04,         0x8c8b8a89,      1,    0x0}
             /* CPU Codes 2                                                */
             ,{DUMMY_NAME_PTR_CNS,             0x00000e08,         0x9f8f8e8d,      1,    0x0}
             /* CPU Codes 3                                                */
             ,{DUMMY_NAME_PTR_CNS,             0x00000e0c,         0xa3a2a1a0,      1,    0x0}
             /* CPU Codes 4                                                */
             ,{DUMMY_NAME_PTR_CNS,             0x00000e10,         0xa7a6a5a4,      1,    0x0}
             /* CPU Codes 5                                                */
             ,{DUMMY_NAME_PTR_CNS,             0x00000e14,         0xabaaa9a8,      1,    0x0}
             /* CPU Codes 6                                                */
             ,{DUMMY_NAME_PTR_CNS,             0x00000e18,         0xafaeadac,      1,    0x0}
             /* CPU Codes 7                                                */
             ,{DUMMY_NAME_PTR_CNS,             0x00000e1c,         0x90b6b1b0,      1,    0x0}
             /* CPU Codes 8                                                */
             ,{DUMMY_NAME_PTR_CNS,             0x00000e20,         0x91b5b4b3,      1,    0x0}
             /* CPU Codes 9                                                */
             ,{DUMMY_NAME_PTR_CNS,             0x00000e24,         0xcbcac9c8,      1,    0x0}
             /* CPU Codes 10                                                */
             ,{DUMMY_NAME_PTR_CNS,             0x00000e28,         0x9392cdcc,      1,    0x0}
             /* CPU Codes 11                                                */
             ,{DUMMY_NAME_PTR_CNS,             0x00000e2c,         0x00000094,      1,    0x0}
             /* FDB IPv4 Route Lookup Mask                                 */
             ,{DUMMY_NAME_PTR_CNS,             0x00000f00,         0xffffffff,      1,    0x4}
             /* FDB IPv6 Route Lookup Mask                                 */
             ,{DUMMY_NAME_PTR_CNS,             0x00000f04,         0xffffffff,      4,    0x4}

             ,{NULL,                           0x00000000,         0x00000000,      0,    0x0}

        };
        static SMEM_LINK_LIST_REGISTER_DEFAULT_VALUE_STC list = {myUnit_registersDefaultValueArr,NULL};
        unitPtr->unitDefaultRegistersPtr = &list;
    }
}

void smemHawkUnitPha
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    INOUT SMEM_UNIT_CHUNKS_STC  * unitPtr
);

/**
* @internal smemAasUnitEmx function
* @endinternal
*
* @brief   Allocate address type specific memories -- for the
*          AAS EMX unit
*/
static void smemAasUnitEmx
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    INOUT SMEM_UNIT_CHUNKS_STC  * unitPtr
)
{
    {
        SMEM_CHUNK_BASIC_STC  chunksMem[]=
        {
            /* EM Units */
             {SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000000, 0x00000058)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000060, 0x00000098)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000000A0, 0x000000D8)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000000E0, 0x00000118)}
            /* Mask - Unit 0 */
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000220, 0x00000254)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000260, 0x00000294)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000002A0, 0x000002D4)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000002E0, 0x00000314)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000320, 0x00000354)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000360, 0x00000394)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000003A0, 0x000003D4)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000003E0, 0x00000414)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000420, 0x00000454)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000460, 0x00000494)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000004A0, 0x000004D4)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000004E0, 0x00000514)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000520, 0x00000554)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000560, 0x00000594)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000005A0, 0x000005D4)}
            /* Mask - Unit 1 */
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000620, 0x00000654)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000660, 0x00000694)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000006A0, 0x000006D4)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000006E0, 0x00000714)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000720, 0x00000754)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000760, 0x00000794)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000007A0, 0x000007D4)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000007E0, 0x00000814)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000820, 0x00000854)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000860, 0x00000894)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000008A0, 0x000008D4)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000008E0, 0x00000914)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000920, 0x00000954)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000960, 0x00000994)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000009A0, 0x000009D4)}
            /* Mask - Unit 2 */
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000A20, 0x00000A54)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000A60, 0x00000A94)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000AA0, 0x00000AD4)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000AE0, 0x00000B14)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000B20, 0x00000B54)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000B60, 0x00000B94)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000BA0, 0x00000BD4)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000BE0, 0x00000C14)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000C20, 0x00000C54)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000C60, 0x00000C94)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000CA0, 0x00000CD4)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000CE0, 0x00000D14)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000D20, 0x00000D54)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000D60, 0x00000D94)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000DA0, 0x00000DD4)}
            /* Mask - Unit 3 */
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000E20, 0x00000E54)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000E60, 0x00000E94)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000EA0, 0x00000ED4)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000EE0, 0x00000F14)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000F20, 0x00000F54)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000F60, 0x00000F94)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000FA0, 0x00000FD4)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000FE0, 0x00001014)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001020, 0x00001054)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001060, 0x00001094)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000010A0, 0x000010D4)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000010E0, 0x00001114)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001120, 0x00001154)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001160, 0x00001194)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000011A0, 0x000011D4)}

            /* Default Action - Unit 0 */
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00002220, 0x000024EC)}
            /* Default Action - Unit 1 */
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00002620, 0x000028EC)}
            /* Default Action - Unit 2 */
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00002A20, 0x00002CEC)}
            /* Default Action - Unit 3 */
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00002E20, 0x000030EC)}

            /* 10 Byte Select - Unit 0 Profile 1 */
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00004220, 0x00004234)}
            /* 10 Byte Select - Unit 0 Profile 2 */
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00004250, 0x00004264)}
            /* 10 Byte Select - Unit 0 Profile 3 */
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00004280, 0x00004294)}
            /* 10 Byte Select - Unit 0 Profile 4 */
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000042B0, 0x000042C4)}
            /* 10 Byte Select - Unit 0 Profile 5 */
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000042E0, 0x000042F4)}
            /* 10 Byte Select - Unit 0 Profile 6 */
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00004310, 0x00004324)}
            /* 10 Byte Select - Unit 0 Profile 7 */
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00004340, 0x00004354)}
            /* 10 Byte Select - Unit 0 Profile 8 */
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00004370, 0x00004384)}
            /* 10 Byte Select - Unit 0 Profile 9 */
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000043A0, 0x000043B4)}
            /* 10 Byte Select - Unit 0 Profile 10 */
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000043D0, 0x000043E4)}
            /* 10 Byte Select - Unit 0 Profile 11 */
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00004400, 0x00004414)}
            /* 10 Byte Select - Unit 0 Profile 12 */
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00004430, 0x00004444)}
            /* 10 Byte Select - Unit 0 Profile 13 */
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00004460, 0x00004474)}
            /* 10 Byte Select - Unit 0 Profile 14 */
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00004490, 0x000044A4)}
            /* 10 Byte Select - Unit 0 Profile 15 */
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000044C0, 0x000044D4)}
            /* 10 Byte Select - Unit 1 Profile 1 */
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00004620, 0x00004634)}
            /* 10 Byte Select - Unit 1 Profile 2 */
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00004650, 0x00004664)}
            /* 10 Byte Select - Unit 1 Profile 3 */
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00004680, 0x00004694)}
            /* 10 Byte Select - Unit 1 Profile 4 */
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000046B0, 0x000046C4)}
            /* 10 Byte Select - Unit 1 Profile 5 */
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000046E0, 0x000046F4)}
            /* 10 Byte Select - Unit 1 Profile 6 */
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00004710, 0x00004724)}
            /* 10 Byte Select - Unit 1 Profile 7 */
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00004740, 0x00004754)}
            /* 10 Byte Select - Unit 1 Profile 8 */
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00004770, 0x00004784)}
            /* 10 Byte Select - Unit 1 Profile 9 */
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000047A0, 0x000047B4)}
            /* 10 Byte Select - Unit 1 Profile 10 */
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000047D0, 0x000047E4)}
            /* 10 Byte Select - Unit 1 Profile 11 */
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00004800, 0x00004814)}
            /* 10 Byte Select - Unit 1 Profile 12 */
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00004830, 0x00004844)}
            /* 10 Byte Select - Unit 1 Profile 13 */
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00004860, 0x00004874)}
            /* 10 Byte Select - Unit 1 Profile 14 */
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00004890, 0x000048A4)}
            /* 10 Byte Select - Unit 1 Profile 15 */
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000048C0, 0x000048D4)}
            /* 10 Byte Select - Unit 2 Profile 1 */
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00004A20, 0x00004A34)}
            /* 10 Byte Select - Unit 2 Profile 2 */
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00004A50, 0x00004A64)}
            /* 10 Byte Select - Unit 2 Profile 3 */
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00004A80, 0x00004A94)}
            /* 10 Byte Select - Unit 2 Profile 4 */
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00004AB0, 0x00004AC4)}
            /* 10 Byte Select - Unit 2 Profile 5 */
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00004AE0, 0x00004AF4)}
            /* 10 Byte Select - Unit 2 Profile 6 */
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00004B10, 0x00004B24)}
            /* 10 Byte Select - Unit 2 Profile 7 */
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00004B40, 0x00004B54)}
            /* 10 Byte Select - Unit 2 Profile 8 */
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00004B70, 0x00004B84)}
            /* 10 Byte Select - Unit 2 Profile 9 */
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00004BA0, 0x00004BB4)}
            /* 10 Byte Select - Unit 2 Profile 10 */
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00004BD0, 0x00004BE4)}
            /* 10 Byte Select - Unit 2 Profile 11 */
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00004C00, 0x00004C14)}
            /* 10 Byte Select - Unit 2 Profile 12 */
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00004C30, 0x00004C44)}
            /* 10 Byte Select - Unit 2 Profile 13 */
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00004C60, 0x00004C74)}
            /* 10 Byte Select - Unit 2 Profile 14 */
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00004C90, 0x00004CA4)}
            /* 10 Byte Select - Unit 2 Profile 15 */
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00004CC0, 0x00004CD4)}
            /* 10 Byte Select - Unit 3 Profile 1 */
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00004E20, 0x00004E34)}
            /* 10 Byte Select - Unit 3 Profile 2 */
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00004E50, 0x00004E64)}
            /* 10 Byte Select - Unit 3 Profile 3 */
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00004E80, 0x00004E94)}
            /* 10 Byte Select - Unit 3 Profile 4 */
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00004EB0, 0x00004EC4)}
            /* 10 Byte Select - Unit 3 Profile 5 */
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00004EE0, 0x00004EF4)}
            /* 10 Byte Select - Unit 3 Profile 6 */
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00004F10, 0x00004F24)}
            /* 10 Byte Select - Unit 3 Profile 7 */
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00004F40, 0x00004F54)}
            /* 10 Byte Select - Unit 3 Profile 8 */
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00004F70, 0x00004F84)}
            /* 10 Byte Select - Unit 3 Profile 9 */
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00004FA0, 0x00004FB4)}
            /* 10 Byte Select - Unit 3 Profile 10 */
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00004FD0, 0x00004FE4)}
            /* 10 Byte Select - Unit 3 Profile 11 */
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00005000, 0x00005014)}
            /* 10 Byte Select - Unit 3 Profile 12 */
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00005030, 0x00005044)}
            /* 10 Byte Select - Unit 3 Profile 13 */
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00005060, 0x00005074)}
            /* 10 Byte Select - Unit 3 Profile 14 */
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00005090, 0x000050A4)}
            /* 10 Byte Select - Unit 3 Profile 15 */
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000050C0, 0x000050D4)}

            /* Reduced Action - Unit 0 */
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00006220, 0x00006D5C)}
            /* Reduced Action - Unit 1 */
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00006DD8, 0x00007914)}
            /* Reduced Action - Unit 2 */
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00007990, 0x000084CC)}
            /* Reduced Action - Unit 3 */
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00008548, 0x00009084)}

            /* ILM EM unit */
            /* Config */
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x0000C000, 0x0000C038)}
            /* Mask */
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x0000C040, 0x0000C0B4)}
            /* Default Action */
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x0000C200, 0x0000C4CC)}
            /* Reduced Action */
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x0000D000, 0x0000DB3C)}

            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x0000E000, 0x0000E008)}
        };

        GT_U32  numOfChunks = sizeof(chunksMem)/sizeof(SMEM_CHUNK_BASIC_STC);

        smemInitMemChunk(devObjPtr,chunksMem,numOfChunks,unitPtr);
    }

    {
        static SMEM_REGISTER_DEFAULT_VALUE_STC myUnit_registersDefaultValueArr[] =
        {
             {DUMMY_NAME_PTR_CNS,            0x00000000,         0x0000000F,      8,    0x4}
            ,{NULL,                          0x00000000,         0x00000000,      0,    0x0}
         };
         static SMEM_LINK_LIST_REGISTER_DEFAULT_VALUE_STC list = {myUnit_registersDefaultValueArr,NULL};
         unitPtr->unitDefaultRegistersPtr = &list;
    }


    { /* start of unit EMX */
        {
            GT_U32 n;
            /* 0x000000 + 0x4*n */
            for(n = 0; n < MAX_EMX_CHANNEL_NUM_CNS; n++)
                SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->EMX.emChannel[n]  = 0x000000+0x4*n;

            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->EMX.emxInterruptCause = 0x00e004;
            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->EMX.emxInterruptMask  = 0x00e008;
        }
        { /* start of unit ilmExactMatchProfileTable */
            GT_U32 m,t,b;
            /* 0x00c000 + 4*(m-1) */
            for(m = 1; m < MAX_EMX_PROFILE_NUM_CNS; m++)
                SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->EMX.ilmExactMatchProfileTable.ilmExactMatchProfileTableConfig[m] = 0x00c000 + 4*(m-1);

            /* 0x00c040 + 4*b + 8*(m-1) */
            for(m = 1; m < MAX_EMX_PROFILE_NUM_CNS; m++)
                for(b = 0; b < 2; b++)
                    SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->EMX.ilmExactMatchProfileTable.ilmExactMatchProfileTableMaskData[m][b] = 0x00c040 + 4*b + 8*(m-1);

            /* 0x00c200 + 4*b + 48*(m-1) */
            for(m = 1; m < MAX_EMX_PROFILE_NUM_CNS; m++)
                for(b = 0; b < 12; b++)
                    SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->EMX.ilmExactMatchProfileTable.ilmExactMatchProfileTableDefaultActionData[m][b] = 0x00c200 + 4*b + 48*(m-1);

            /* 0x00d000 + 4*b + 180*t */
            for(t = 0; t < MAX_EMX_PROFILE_NUM_CNS; t++)
                for(b = 0; b < MAX_EMX_REDUCED_ACTION_BYTES_CNS; b++)
                    SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->EMX.ilmExactMatchProfileTable.ilmExactMatchProfileTableReducedActionData[t][b] = 0x00d000 + 4*b + 180*t;

        } /* end of unit ilmExactMatchProfileTable */

        { /* start of unit exactMatchProfilesTable */
            GT_U32 n;
            for(n=0; n < MAX_EMX_UNIT_NUM_CNS; n++)
            {
                GT_U32 m,t,b;
                /* 0x000020 + 4*(m-1) + 64*n */
                for(m = 1; m < MAX_EMX_PROFILE_NUM_CNS; m++)
                    SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->EMX.exactMatchProfilesTable[n].exactMatchProfileTableConfig[m] = 0x000020 + 4*(m-1) + 64*n;

                /* 0x000220 + 4*b + 64*(m-1) + 1024*n */
                for(m = 1; m < MAX_EMX_PROFILE_NUM_CNS; m++)
                    for(b = 0; b < 14; b++)
                        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->EMX.exactMatchProfilesTable[n].exactMatchProfilesTableMaskData[m][b] = 0x000220 + 4*b + 64*(m-1) + 1024*n;

                /* 0x002220 + 4*b + 48*(m-1) + 1024*n */
                for(m = 1; m < MAX_EMX_PROFILE_NUM_CNS; m++)
                    for(b = 0; b < 12; b++)
                        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->EMX.exactMatchProfilesTable[n].exactMatchProfileTableDefaultActionData[m][b] = 0x002220 + 4*b + 48*(m-1) + 1024*n;

                /* 0x004220 + 4*b + 48*(m-1) + 1024*n */
                for(m = 1; m < MAX_EMX_PROFILE_NUM_CNS; m++)
                    for(b = 0; b < 6; b++)
                        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->EMX.exactMatchProfilesTable[n].exactMatchProfileTable10BSelect[m][b] = 0x004220 + 4*b + 48*(m-1) + 1024*n;

                /* 0x006220 + 4*b + 180*t + 3000*n */
                for(t = 0; t < MAX_EMX_PROFILE_NUM_CNS; t++)
                    for(b = 0; b < MAX_EMX_REDUCED_ACTION_BYTES_CNS; b++)
                        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->EMX.exactMatchProfilesTable[n].exactMatchProfileTableReducedActionData[t][b] = 0x006220 + 4*b + 180*t + 3000*n;
            }
        } /* end of unit exactMatchProfilesTable */
    } /* end  of unit EMX */
}

/**
* @internal smemAasUnitTtiLu function
* @endinternal
*
* @brief   Allocate address type specific memories -- for the
*          AAS TTI_LU unit
*/
static void smemAasUnitTtiLu
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    INOUT SMEM_UNIT_CHUNKS_STC  * unitPtr
)
{
    {
        SMEM_CHUNK_BASIC_STC  chunksMem[]=
        {
            /* General regs */
             {SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000000, 0x00000018)}
            /* TTI LU Action*/
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000020, 0x00000038)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000040, 0x00000048)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000050, 0x00000068)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000000A0, 0x000000BC)}
            /* ILM LU */
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000104, 0x00000700)}
            /* TTI LU ACtion (contd) */
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001000, 0x000012FC)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001500, 0x0000173C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00002000, 0x000023FC)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00002500, 0x0000283C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00003008, 0x000033FC)}
        };

        GT_U32  numOfChunks = sizeof(chunksMem)/sizeof(SMEM_CHUNK_BASIC_STC);

        smemInitMemChunk(devObjPtr,chunksMem,numOfChunks,unitPtr);
    }

    {
        static SMEM_REGISTER_DEFAULT_VALUE_STC myUnit_registersDefaultValueArr[] =
        {

             {DUMMY_NAME_PTR_CNS,            0x00000000,         0x00000001,      1,    0x0}
            ,{DUMMY_NAME_PTR_CNS,            0x00000020,         0x00000FFF,      4,    0x4}
            ,{DUMMY_NAME_PTR_CNS,            0x00000030,         0x00000FFF,      3,    0x4}
            ,{DUMMY_NAME_PTR_CNS,            0x00000040,         0x0000001B,      1,    0x0}
            ,{DUMMY_NAME_PTR_CNS,            0x00000044,         0x186DB81B,      1,    0x0}
            ,{DUMMY_NAME_PTR_CNS,            0x00000048,         0x0000AAA8,      1,    0x0}
            ,{DUMMY_NAME_PTR_CNS,            0x000000A0,         0x000001FC,      8,    0x4}
            ,{NULL,                          0x00000000,         0x00000000,      0,    0x0}
         };
         static SMEM_LINK_LIST_REGISTER_DEFAULT_VALUE_STC list = {myUnit_registersDefaultValueArr,NULL};
         unitPtr->unitDefaultRegistersPtr = &list;
    }

    { /* start of unit TTI_LU */
        { /* start of unit generalRegs */
            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->TTI_LU.generalRegs.ttiLuGlobalConfig    = 0x000000;
            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->TTI_LU.generalRegs.ttiInterruptCause    = 0x000004;
            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->TTI_LU.generalRegs.ttiInterruptMask     = 0x000008;
            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->TTI_LU.generalRegs.ttiLastAddrViolation = 0x00000C;
        } /* end of unit generalRegs */

        {/* start of unit ilmLuConfig */
            GT_U32 s,p;

            /* 0x00000104 + 0x200*s + 0x4*p;*/
            for(s = 0; s < MAX_TTI_LU_SERIAL_LOOKUP_NUM_CNS; s++)
            {
                for(p = 0; p < MAX_TTI_LU_SERIAL_EM_PROFILE_NUM_CNS; p++)
                {
                    SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->TTI_LU.ilmLuConfig[s].ilmLuSerialEmProfile[p] = 0x00000104 + 0x200*s + 0x4*p;
                }
            }
        }/* end of unit ilmLuConfig */

        {/* start of unit ttiLuActionConfig */
            GT_U32 n, i, k;

            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->TTI_LU.ttiLuActionConfig.ttiLuMplsExceptionCmds   = 0x000040;
            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->TTI_LU.ttiLuActionConfig.ttiLuIpExceptionCmds     = 0x000044;
            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->TTI_LU.ttiLuActionConfig.ttiLuGenericActionConfig = 0x000048;

            /* 0x000020 + 0x4*n */
            for(n = 0; n < 4; n++)
                SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->TTI_LU.ttiLuActionConfig.ttiLuTtSrcIdAssignment[n] = 0x000020 + 0x4*n;

             /* 0x000030 + 0x4*n */
            for(n = 0; n < 2; n++)
                SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->TTI_LU.ttiLuActionConfig.ttiLuIlmSrcIdAssignment[n] = 0x000030 + 0x4*n;

            /* 0x000050 + 0x4*n */
            for(n = 0; n < MAX_TTI_LU_PARALLEL_LOOKUP_NUM_CNS; n++)
                SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->TTI_LU.ttiLuActionConfig.ttiLuGenericClassifParallelLu[n] = 0x000050 + 0x4*n;

            /* 0x000060 + 0x4*n */
            for(n = 0; n < MAX_TTI_LU_SERIAL_LOOKUP_NUM_CNS; n++)
                SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->TTI_LU.ttiLuActionConfig.ttiLuGenericClassifSerialEmLu[n] = 0x000060 + 0x4*n;
            /* 0x0000A0 + 0x4*n */
            for(n = 0; n < 8; n++)
                SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->TTI_LU.ttiLuActionConfig.ttiLuTunnelHeaderLenProfile[n] = 0x0000A0 + 0x4*n;

            /* 0x001000 + 0x4*i + 0x100*k */
            for(k = 0; k < MAX_TTI_LU_SERIAL_LOOKUP_NUM_CNS; k++)
                for(i = 0; i < MAX_TTI_LU_ILM_QOS_ACTION_ENTRY_NUM_CNS; i++)
                    SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->TTI_LU.ttiLuActionConfig.ttiLuIlmLookupIdxQosActionResolution[k].qosEntry[i] = 0x001000 + 0x4*i + 0x100*k;

            /* 0x001500 + 0x4*i + 0x100*k */
            for(k = 0; k < MAX_TTI_LU_SERIAL_LOOKUP_NUM_CNS; k++)
                for(i = 0; i < MAX_TTI_LU_ILM_TTL_ACTION_ENTRY_NUM_CNS; i++)
                    SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->TTI_LU.ttiLuActionConfig.ttiLuIlmLookupIdxTtlActionResolution[k].ttlEntry[i] = 0x001500 + 0x4*i + 0x100*k;

            /* 0x002000 + 0x4*i + 0x100*k */
            for(k = 0; k < MAX_TTI_LU_PARALLEL_LOOKUP_NUM_CNS; k++)
                for(i = 0; i < MAX_TTI_LU_ILM_QOS_ACTION_ENTRY_NUM_CNS; i++)
                    SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->TTI_LU.ttiLuActionConfig.ttiLuParallelLookupIdxQosActionResolution[k].qosEntry[i] = 0x002000 + 0x4*i + 0x100*k;

            /* 0x002500 + 0x4*i + 0x100*k */
            for(k = 0; k < MAX_TTI_LU_PARALLEL_LOOKUP_NUM_CNS; k++)
                for(i = 0; i < MAX_TTI_LU_ILM_TTL_ACTION_ENTRY_NUM_CNS; i++)
                    SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->TTI_LU.ttiLuActionConfig.ttiLuParallelLookupIdxTtlActionResolution[k].ttlEntry[i] = 0x002500 + 0x4*i + 0x100*k;

        } /* end of unit ttiLuActionConfig */

        {/* start of unit ttiLuGenericRangesConfig */
             {/*0x00003000+0x8*n*/
                    GT_U32    n;
                    for(n = 1 ; n < 128 ; n++) {
                        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->TTI_LU.ttiLuGenericRangesConfig.ttiLuRangeClassification0[n] = 0x00003000 + 0x8*n;
                    }
                }/*0x00003000 + 0x8*n*/

                {/*0x00003004 + 0x8*n*/
                    GT_U32    n;
                    for(n = 1 ; n < 128 ; n++) {
                        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->TTI_LU.ttiLuGenericRangesConfig.ttiLuRangeClassification1[n] = 0x00003004 + 0x8*n;
                    }
                }/*0x00003004 + 0x8*n*/
        }/* end of unit ttiLuGenericRangesConfig */

    } /* end  of unit TTI_LU */
}

/**
* @internal smemAasActiveWriteFDBGlobalCfg2Reg function
* @endinternal
*
* @brief   The function updates FDB table size according to FDB_Global_Configuration 2
*
* @param[in] devObjPtr                - device object PTR.
* @param[in] address                  - Address for ASIC memory.
* @param[in] memPtr                   - Pointer to the register's memory in the simulation.
* @param[in] memSize                  - Size of memory to be written
* @param[in] param                    - Registers' specific parameter.
* @param[in] inMemPtr                 - Pointer to the memory to get register's content.
*/
void smemAasActiveWriteFDBGlobalCfg2Reg
(
    IN         SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN         GT_U32   address,
    IN         GT_U32   memSize,
    IN         GT_U32 * memPtr,
    IN         GT_UINTPTR   param,
    IN         GT_U32 * inMemPtr
)
{
    DECLARE_FUNC_NAME(smemAasActiveWriteFDBGlobalCfg2Reg);

    GT_U32 fdbSize;
    GT_U32 fdbNumEntries;
    GT_U32 multiHashEnable;
    GT_U32 numOfHashes;         /* Number of Multiple Hash Tables */

    /* data to be written */
    *memPtr = *inMemPtr;

    /* Number of Multiple Hash Tables */
    numOfHashes = SMEM_U32_GET_FIELD(*inMemPtr, 2, 2);

    switch(numOfHashes)
    {
        case 0:
            devObjPtr->fdbNumOfBanks = 4;
            break;
        case 1:
            devObjPtr->fdbNumOfBanks = 8;
            break;
        default:
            devObjPtr->fdbNumOfBanks = 16;
            break;
    }

    /* FDBSize */
    fdbSize = SMEM_U32_GET_FIELD(*inMemPtr, 14, 4);
    /* get the <FDBHashMode > and <Multi Hash Enable> bits .
       if both are 1 --> we consider the multi hash mode.
       memPtr[-1] , because it is from 'config 1' register */
    multiHashEnable = (SMEM_U32_GET_FIELD(memPtr[-1], 2, 2) == 3) ? 1 : 0;

    switch(fdbSize)
    {
        case 0:
            fdbNumEntries = SMEM_MAC_TABLE_SIZE_4KB;
            break;
        case 1:
            fdbNumEntries = SMEM_MAC_TABLE_SIZE_8KB;
            break;
        case 2:
            fdbNumEntries = SMEM_MAC_TABLE_SIZE_16KB;
            break;
        case 3:
            fdbNumEntries = SMEM_MAC_TABLE_SIZE_32KB;
            break;
        case 4:
            fdbNumEntries = SMEM_MAC_TABLE_SIZE_64KB;
            break;
        case 5:
            fdbNumEntries = SMEM_MAC_TABLE_SIZE_128KB;
            break;
        case 6:
            fdbNumEntries = SMEM_MAC_TABLE_SIZE_256KB;
            break;
        case 7:
            fdbNumEntries = SMEM_MAC_TABLE_SIZE_512KB;
            break;
        case 8:
            fdbNumEntries = SMEM_MAC_TABLE_SIZE_1MB;
            break;
        default:/*on 4 bits value .. should not get here*/
            fdbNumEntries = devObjPtr->fdbNumEntries;/*unchanged*/
            break;
    }

    devObjPtr->fdbNumEntries = fdbNumEntries;
    devObjPtr->multiHashEnable = multiHashEnable;

    if(devObjPtr->fdbMaxNumEntries < devObjPtr->fdbNumEntries)
    {
        skernelFatalError("smemAasActiveWriteFDBGlobalCfg2Reg: FDB num entries in HW [0x%4.4x] , but set to use[0x%4.4x] \n",
            devObjPtr->fdbMaxNumEntries , devObjPtr->fdbNumEntries);
    }

    /*if(SMEM_CHT_IS_SIP6_30_GET(devObjPtr))*/
    {
        /* check if the FDB/DDE mode should reduce the number of FDB entries ! */
        GT_U32  hsr_prp_fdb_mode;

        devObjPtr->orig_fdbNumEntries = devObjPtr->fdbNumEntries;

        smemRegFldGet(devObjPtr,
            SMEM_SIP6_30_FDB_UNIT_HSR_PRP_GLOBAL_CONFIG_REG(devObjPtr),
            25,3,&hsr_prp_fdb_mode);

        __LOG_PARAM(hsr_prp_fdb_mode);

        switch(hsr_prp_fdb_mode)
        {
            case 0:
                __LOG(("MAC_IP_ONLY : (legacy - non HSR-PRP support) \n"));
                devObjPtr->fdbNumEntries = devObjPtr->orig_fdbNumEntries;
                break;
            case 1:
                __LOG(("MAC_IP_1_2 : HSR-PRP support : First 1/2 of the FDB entries are allocated for MAC/IP addresses, last 1/2 are for DDE \n"));
                devObjPtr->fdbNumEntries = devObjPtr->orig_fdbNumEntries >> 1;
                break;
            case 2:
                __LOG(("MAC_IP_1_4 : HSR-PRP support : First 1/4 of the FDB first entries are allocated for MAC/IP addresses, last 3/4 are for DDE \n"));
                devObjPtr->fdbNumEntries = devObjPtr->orig_fdbNumEntries >> 2;
                break;
            case 3:
                __LOG(("MAC_IP_1_8 : HSR-PRP support : First 1/8 of the FDB entries are allocated for MAC/IP addresses, last 7/8 are for DDE \n"));
                devObjPtr->fdbNumEntries = devObjPtr->orig_fdbNumEntries >> 3;
                break;
            case 7:
                __LOG(("DDE_ONLY : HSR-PRP support : No entry is allocated for MAC/IP addresses \n"));
                devObjPtr->fdbNumEntries = 0;/*!!!*/
                break;
            default:
                __LOG(("Configuration ERROR : unknown hsr_prp_fdb_mode[%d] treat as mode 0 \n",hsr_prp_fdb_mode));
                devObjPtr->fdbNumEntries = devObjPtr->orig_fdbNumEntries;
                break;
        }

        __LOG_PARAM(devObjPtr->orig_fdbNumEntries);
        __LOG_PARAM(devObjPtr->fdbNumEntries);
    }

    return;
}

/**
* @internal smemAasActiveWriteFdbMsg function
* @endinternal
*
* @brief   Write to the Message from CPU Register4 - activate update FDB message.
*
* @param[in] devObjPtr                - device object PTR.
* @param[in] address                  - Address for ASIC memory.
* @param[in] memPtr                   - Pointer to the register's memory in the simulation.
* @param[in] param                    - Registers' specific parameter.
* @param[in] inMemPtr                 - Pointer to the memory to get register's content.
*/
void smemAasActiveWriteFdbMsg(
    IN         SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN         GT_U32   address,
    IN         GT_U32   memSize,
    IN         GT_U32 * memPtr,
    IN         GT_UINTPTR   param,
    IN         GT_U32 * inMemPtr
)
{
    GT_U32            * regPtr;         /* register's entry pointer */
    GT_U32              line;           /* line number */
    GT_U32              rdWr;           /* Read or write operation */
    GT_U32              regAddr_tbl;    /* table memory address */
    GT_U32              regAddr_msg;    /* message memory address */
    GT_U32              RdWrTrig;       /* When set to 1, an FDB read or write access is performed.
                                               This bit is cleared by the device when the access action is completed*/
    GT_U32 numOfBitsPerBanks;
    GT_U32 macEntrySize;
    GT_U32 wrapAround;

    macEntrySize = SMEM_CHT_MAC_TABLE_WORDS_MAC(devObjPtr);

    numOfBitsPerBanks = (devObjPtr->fdbNumOfBanks == 4) ? 2 :
                        (devObjPtr->fdbNumOfBanks == 8) ? 3 : 4;
    /* data to be written */
    *memPtr = *inMemPtr;

    RdWrTrig = SMEM_U32_GET_FIELD(*inMemPtr, 0, 1);
    if(RdWrTrig == 0)
    {
        return;
    }

    rdWr = SMEM_U32_GET_FIELD(*inMemPtr, 1, 1);
    line = SMEM_U32_GET_FIELD(*inMemPtr, 2, 21);

    line = SMEM_U32_GET_FIELD(line, 4, 16) << numOfBitsPerBanks | SMEM_U32_GET_FIELD(line, 0, numOfBitsPerBanks);

    if(devObjPtr->orig_fdbNumEntries)
    {
        /* sip 6.30 support for HSR/PRP sharing of the FDB */
        wrapAround = devObjPtr->orig_fdbNumEntries;
    }
    else
    {
        wrapAround = devObjPtr->fdbNumEntries;
    }

    line %= wrapAround;
    regAddr_tbl = SMEM_CHT_MAC_TBL_MEM(devObjPtr,line);
    regAddr_msg = SMEM_CHT_MAC_TBL_ACC_DATA0_REG(devObjPtr);

    /* Get FDB entry */
    if (rdWr) /* write the data from the msg registers to the FDB table  */
    {
        /* Mac Table Access Data */
        regPtr = smemMemGet(devObjPtr, regAddr_msg);
        smemMemSet(devObjPtr, regAddr_tbl, regPtr, macEntrySize);
    }
    else /* read the data from the FDB table into the msg registers */
    {
        regPtr = smemMemGet(devObjPtr, regAddr_tbl);
        /* Mac Table Access Data */
        smemMemSet(devObjPtr, regAddr_msg, regPtr, macEntrySize);
    }

    /* clear <RdWrTrig> */
    SMEM_U32_SET_FIELD(*memPtr, 0, 1, 0);

    return;
}

/**
* @internal smemAasUnitFdb function
* @endinternal
*
* @brief   Allocate address type specific memories -- for the AAS FDB unit
*
* @param[in] devObjPtr                - pointer to device memory.
* @param[in,out] unitPtr                  - pointer to the unit chunk
*/
static void smemAasUnitFdb
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    INOUT SMEM_UNIT_CHUNKS_STC  * unitPtr
)
{
    START_BIND_UNIT_ACTIVE_MEM_MAC(devObjPtr,unitPtr)
/*FDB*/
    /* Message to CPU register  */
    {FDB_REG_OFFSET + 0x00000090, SMEM_FULL_MASK_CNS, smemChtActiveReadMsg2Cpu, 0 , NULL,0},
    /* Mac Table Access Control Register */
    {FDB_REG_OFFSET + 0x00000130, SMEM_FULL_MASK_CNS, NULL, 0 , smemAasActiveWriteFdbMsg,0},

    /* Message From CPU Management */
    {FDB_REG_OFFSET + 0x000000c0, SMEM_FULL_MASK_CNS, NULL, 0 , smemChtActiveWriteNewFdbMsgFromCpu, 0},

    /* MAC Table Action general Register */
    {FDB_REG_OFFSET + 0x00000020, SMEM_FULL_MASK_CNS, NULL, 0 , smemChtActiveWriteFdbActionTrigger, 0},

    /* FDB Global Configuration 2 register */
    {FDB_REG_OFFSET + 0x00000008, SMEM_FULL_MASK_CNS, NULL, 0 , smemAasActiveWriteFDBGlobalCfg2Reg, 0},

    {FDB_REG_OFFSET + 0x000001b0, SMEM_FULL_MASK_CNS,
        smemChtActiveReadIntrCauseReg, 0, smemChtActiveWriteIntrCauseReg, 0},
    /* MAC Table Interrupt Mask Register */
    {FDB_REG_OFFSET + 0x000001b4, SMEM_FULL_MASK_CNS,
        NULL, 0, smemChtActiveWriteMacInterruptsMaskReg, 0},

    /* FDB Counters Update Control */
    {FDB_REG_OFFSET + 0x00000340, SMEM_FULL_MASK_CNS, NULL, 0, smemLion3ActiveWriteFDBCountersUpdateControlReg,0},
    /* FDB Counters Update Control */
    {FDB_REG_OFFSET + 0x00000280, SMEM_FULL_MASK_CNS, NULL, 0, smemLion3ActiveWriteFDBCountersControlReg,0},

    /* active memory for registers on sip 6.30 */
    /* register <HSR PRP Timer> */
    {FDB_REG_OFFSET + 0x00000508, SMEM_FULL_MASK_CNS, smemSip6_30ActiveReadFdbHsrPrpTimerReg , 0, smemSip6_30ActiveWriteFdbHsrPrpTimerReg,0},
    {FDB_REG_OFFSET + 0x00000500, SMEM_FULL_MASK_CNS, NULL , 0, smemSip6_30ActiveWriteFdbHsrPrpGlobalConfigReg ,0},

    /* HSR : ROC counters :
       0x510 , 0x514 , 0x518 : each 10 times insteps of 0xC
       so range is :
       0x510 .. 0x584
    */
    /* 0x510 .. 0x51C */
    {FDB_REG_OFFSET + 0x00000510, SMEM_FULL_MASK_CNS-0x0F, smemChtActiveReadCntrs , 0, NULL ,0},
    /* 0x520 .. 0x53C */
    {FDB_REG_OFFSET + 0x00000520, SMEM_FULL_MASK_CNS-0x1F, smemChtActiveReadCntrs , 0, NULL ,0},
    /* 0x540 .. 0x57C */
    {FDB_REG_OFFSET + 0x00000540, SMEM_FULL_MASK_CNS-0x3F, smemChtActiveReadCntrs , 0, NULL ,0},
    /* 0x580 .. 0x584 */
    {FDB_REG_OFFSET + 0x00000580, SMEM_FULL_MASK_CNS-0x07, smemChtActiveReadCntrs , 0, NULL ,0},

    END_BIND_UNIT_ACTIVE_MEM_MAC(devObjPtr,unitPtr)

    devObjPtr->fdbRegistersRelativeBase = FDB_REG_OFFSET;

    {
        SMEM_CHUNK_BASIC_STC  chunksMem[]=
        {
             {SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (FDB_REG_OFFSET + 0x00000000, FDB_REG_OFFSET + 0x00000014)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (FDB_REG_OFFSET + 0x00000020, FDB_REG_OFFSET + 0x00000040)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (FDB_REG_OFFSET + 0x00000060, FDB_REG_OFFSET + 0x00000060)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (FDB_REG_OFFSET + 0x00000070, FDB_REG_OFFSET + 0x00000074)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (FDB_REG_OFFSET + 0x00000090, FDB_REG_OFFSET + 0x00000094)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (FDB_REG_OFFSET + 0x000000C0, FDB_REG_OFFSET + 0x000000C0)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (FDB_REG_OFFSET + 0x000000D0, FDB_REG_OFFSET + 0x000000E4)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (FDB_REG_OFFSET + 0x00000110, FDB_REG_OFFSET + 0x00000120)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (FDB_REG_OFFSET + 0x00000130, FDB_REG_OFFSET + 0x00000144)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (FDB_REG_OFFSET + 0x00000150, FDB_REG_OFFSET + 0x00000150)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (FDB_REG_OFFSET + 0x00000170, FDB_REG_OFFSET + 0x00000174)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (FDB_REG_OFFSET + 0x000001B0, FDB_REG_OFFSET + 0x000001B4)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (FDB_REG_OFFSET + 0x00000200, FDB_REG_OFFSET + 0x00000280)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (FDB_REG_OFFSET + 0x00000300, FDB_REG_OFFSET + 0x00000324)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (FDB_REG_OFFSET + 0x00000340, FDB_REG_OFFSET + 0x00000340)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (FDB_REG_OFFSET + 0x00000380, FDB_REG_OFFSET + 0x00000388)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (FDB_REG_OFFSET + 0x00000400, FDB_REG_OFFSET + 0x00000400)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (FDB_REG_OFFSET + 0x00000410, FDB_REG_OFFSET + 0x00000430)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (FDB_REG_OFFSET + 0x00000480, FDB_REG_OFFSET + 0x00000498)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (FDB_REG_OFFSET + 0x000004A0, FDB_REG_OFFSET + 0x000004A0)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (FDB_REG_OFFSET + 0x00000500, FDB_REG_OFFSET + 0x00000508)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (FDB_REG_OFFSET + 0x00000510, FDB_REG_OFFSET + 0x00000584)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (FDB_REG_OFFSET + 0x00000590, FDB_REG_OFFSET + 0x00000594)}
            /* FDB Memory */
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC(0x00000000 ,33554432),SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(133, FDB_TABLE_ALIGN_IN_BYTES/*32*/),SMEM_BIND_SHARED_TABLE_MAC(fdbTable)}
        };
        GT_U32  numOfChunks = sizeof(chunksMem)/sizeof(SMEM_CHUNK_BASIC_STC);

        smemInitMemChunk(devObjPtr,chunksMem,numOfChunks,unitPtr);
    }

    {
        static SMEM_REGISTER_DEFAULT_VALUE_STC myUnit_registersDefaultValueArr[] =
        {
             {DUMMY_NAME_PTR_CNS,            FDB_REG_OFFSET + 0x00000000,         0x107bfc00,      1,    0x4       }
            ,{DUMMY_NAME_PTR_CNS,            FDB_REG_OFFSET + 0x00000004,         0x0701033c,      1,    0x4       }
            ,{DUMMY_NAME_PTR_CNS,            FDB_REG_OFFSET + 0x00000008,         0x00000208,      1,    0x4       }
            ,{DUMMY_NAME_PTR_CNS,            FDB_REG_OFFSET + 0x0000000c,         0xffffffff,      1,    0x4       }
            ,{DUMMY_NAME_PTR_CNS,            FDB_REG_OFFSET + 0x00000014,         0x000023c3,      1,    0x4       }
            ,{DUMMY_NAME_PTR_CNS,            FDB_REG_OFFSET + 0x00000020,         0x000003c1,      1,    0x4       }
            ,{DUMMY_NAME_PTR_CNS,            FDB_REG_OFFSET + 0x00000074,         0x0036ee80,      1,    0x4       }
            ,{DUMMY_NAME_PTR_CNS,            FDB_REG_OFFSET + 0x00000090,         0xffffffff,      2,    0x80      }
            ,{DUMMY_NAME_PTR_CNS,            FDB_REG_OFFSET + 0x00000094,         0x0000006a,      1,    0x4       }
            ,{DUMMY_NAME_PTR_CNS,            FDB_REG_OFFSET + 0x00000114,         0x0000ffff,      2,    0x4       }
            ,{DUMMY_NAME_PTR_CNS,            FDB_REG_OFFSET + 0x0000011c,         0xffffffff,      2,    0x4       }
            ,{DUMMY_NAME_PTR_CNS,            FDB_REG_OFFSET + 0x00000170,         0x0000ffff,      1,    0x4       }
            ,{DUMMY_NAME_PTR_CNS,            FDB_REG_OFFSET + 0x00000174,         0x007fffff,      1,    0x4       }
            ,{DUMMY_NAME_PTR_CNS,            FDB_REG_OFFSET + 0x00000244,         0x00000001,      1,    0x4       }
            ,{DUMMY_NAME_PTR_CNS,            FDB_REG_OFFSET + 0x00000248,         0x00000002,      1,    0x4       }
            ,{DUMMY_NAME_PTR_CNS,            FDB_REG_OFFSET + 0x0000024c,         0x00000003,      1,    0x4       }
            ,{DUMMY_NAME_PTR_CNS,            FDB_REG_OFFSET + 0x00000250,         0x00000004,      1,    0x4       }
            ,{DUMMY_NAME_PTR_CNS,            FDB_REG_OFFSET + 0x00000254,         0x00000005,      1,    0x4       }
            ,{DUMMY_NAME_PTR_CNS,            FDB_REG_OFFSET + 0x00000258,         0x00000006,      1,    0x4       }
            ,{DUMMY_NAME_PTR_CNS,            FDB_REG_OFFSET + 0x0000025c,         0x00000007,      1,    0x4       }
            ,{DUMMY_NAME_PTR_CNS,            FDB_REG_OFFSET + 0x00000260,         0x00000008,      1,    0x4       }
            ,{DUMMY_NAME_PTR_CNS,            FDB_REG_OFFSET + 0x00000264,         0x00000009,      1,    0x4       }
            ,{DUMMY_NAME_PTR_CNS,            FDB_REG_OFFSET + 0x00000268,         0x0000000a,      1,    0x4       }
            ,{DUMMY_NAME_PTR_CNS,            FDB_REG_OFFSET + 0x0000026c,         0x0000000b,      1,    0x4       }
            ,{DUMMY_NAME_PTR_CNS,            FDB_REG_OFFSET + 0x00000270,         0x0000000c,      1,    0x4       }
            ,{DUMMY_NAME_PTR_CNS,            FDB_REG_OFFSET + 0x00000274,         0x0000000d,      1,    0x4       }
            ,{DUMMY_NAME_PTR_CNS,            FDB_REG_OFFSET + 0x00000278,         0x0000000e,      1,    0x4       }
            ,{DUMMY_NAME_PTR_CNS,            FDB_REG_OFFSET + 0x0000027c,         0x0000000f,      1,    0x4       }
            ,{DUMMY_NAME_PTR_CNS,            FDB_REG_OFFSET + 0x00000380,         0x00000002,      1,    0x4       }
            ,{DUMMY_NAME_PTR_CNS,            FDB_REG_OFFSET + 0x00000384,         0x00010162,      1,    0x4       }
            ,{DUMMY_NAME_PTR_CNS,            FDB_REG_OFFSET + 0x00000388,         0x00000182,      1,    0x4       }
            ,{DUMMY_NAME_PTR_CNS,            FDB_REG_OFFSET + 0x00000400,         0x00000002,      1,    0x4       }
            ,{DUMMY_NAME_PTR_CNS,            FDB_REG_OFFSET + 0x00000410,         0x00000007,      1,    0x4       }
            ,{DUMMY_NAME_PTR_CNS,            FDB_REG_OFFSET + 0x00000480,         0x000001cc,      1,    0x4       }
            ,{DUMMY_NAME_PTR_CNS,            FDB_REG_OFFSET + 0x00000484,         0x00088420,      1,    0x4       }
            ,{DUMMY_NAME_PTR_CNS,            FDB_REG_OFFSET + 0x00000488,         0x002bfdfe,      1,    0x4       }
            ,{DUMMY_NAME_PTR_CNS,            FDB_REG_OFFSET + 0x0000048c,         0x00000014,      1,    0x4       }
            ,{DUMMY_NAME_PTR_CNS,            FDB_REG_OFFSET + 0x00000494,         0x000000a5,      1,    0x4       }
            ,{DUMMY_NAME_PTR_CNS,            FDB_REG_OFFSET + 0x00000500,         0x00000064,      1,    0x4       }
            ,{DUMMY_NAME_PTR_CNS,            FDB_REG_OFFSET + 0x00000504,         0x00000019,      1,    0x4       }

            /* must be last */
            ,{NULL              ,                     0,         0x00000000,      0,    0x0      }
        };
        static SMEM_LINK_LIST_REGISTER_DEFAULT_VALUE_STC list = {myUnit_registersDefaultValueArr,NULL};
        unitPtr->unitDefaultRegistersPtr = &list;
    }


}

enum{/* this enum will also be in WM code */
    WM_TABLE_STATRTED_SESSION_E = 1,
    WM_TABLE_ENDED_SESSION_E,

    WM_TABLE_FDB_E  ,
    WM_TABLE_LPM_E  ,
    WM_TABLE_TS_E   ,
    /* new in AAS */
    WM_TABLE_ARP_E  ,
    WM_TABLE_CNC_0_1_E  ,
    WM_TABLE_CNC_2_3_E  ,
    WM_TABLE_EM_0_E  ,
    WM_TABLE_EM_1_E  ,
    WM_TABLE_EM_2_E  ,
    WM_TABLE_EM_3_E  ,
    WM_TABLE_EM_4_E  ,
    WM_TABLE_EM_5_E  ,
    WM_TABLE_EM_6_E  ,
    WM_TABLE_EM_7_E  ,
    WM_TABLE_HF0_E  ,
    WM_TABLE_HF1_E  ,
    WM_TABLE_PLR_METERS_E    ,
    WM_TABLE_PLR_COUNTERS_E  ,
};
const struct SHARED_TABLES_INFO_STCT{
    char* name;
    char* comment;
}shared_tables_info[] =
{
    {"session started"   ,NULL},
    {"session ended"     ,NULL},
    {STR(WM_TABLE_FDB_E) ,NULL},
    {STR(WM_TABLE_LPM_E) ,NULL},
    {STR(WM_TABLE_TS_E ) ,"of ipv6 TS"},

    {STR(WM_TABLE_ARP_E ) ,NULL},
    {STR(WM_TABLE_CNC_0_1_E ) ,NULL},
    {STR(WM_TABLE_CNC_2_3_E ) ,NULL},
    {STR(WM_TABLE_EM_0_E) ,NULL},
    {STR(WM_TABLE_EM_1_E) ,NULL},
    {STR(WM_TABLE_EM_2_E) ,NULL},
    {STR(WM_TABLE_EM_3_E) ,NULL},
    {STR(WM_TABLE_EM_4_E) ,NULL},
    {STR(WM_TABLE_EM_5_E) ,NULL},
    {STR(WM_TABLE_EM_6_E) ,NULL},
    {STR(WM_TABLE_EM_7_E) ,NULL},
    {STR(WM_TABLE_HF0_E ) ,NULL},
    {STR(WM_TABLE_HF1_E ) ,NULL},
    {STR(WM_TABLE_PLR_METERS_E ) ,NULL},
    {STR(WM_TABLE_PLR_COUNTERS_E ) ,NULL},

};

/* for most clients the 32K lines (133bits width) are used for 32K entries */
/* for CNC , there are design needs to use only 1/2 the SBM for the client */
#define SBM_NUM_LINES   (32*1024)

#define DEFAULT_NUM_LINES SBM_NUM_LINES
#define CNC_NUM_LINES     (SBM_NUM_LINES / 2)

static void smemAasIsSharedTableWithOrig
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN GT_U32  tileId,
    IN GT_U32  tableId,
    OUT GT_BOOL *isSharedWithOringPtr,
    OUT GT_U32 *origTileIdPtr,
    OUT GT_U32 *origTableIdPtr
)
{
    GT_U32 ii;

    for(ii = 0 ; ii < SKERNEL_SHARING_PAIRS_MAX_NUM_CNS ; ii++)
    {
        if(GT_FALSE == devObjPtr->sharedTablesInfo.sharing_pairs[ii].isUsed ||
           GT_FALSE == devObjPtr->sharedTablesInfo.sharing_pairs[ii].isSharedWithOrig )
        {
            /* not used index */
            continue;
        }

        if(devObjPtr->sharedTablesInfo.sharing_pairs[ii].tileId  == tileId &&
           devObjPtr->sharedTablesInfo.sharing_pairs[ii].tableId == tableId)
        {
            /* found as table that it have 'orig' table that allocated the memory */
            *isSharedWithOringPtr = GT_TRUE;
            *origTileIdPtr  = devObjPtr->sharedTablesInfo.sharing_pairs[ii].origTileId;
            *origTableIdPtr = devObjPtr->sharedTablesInfo.sharing_pairs[ii].origTableId;
            return;
        }
    }
    /* not found as one with shared info */
    *isSharedWithOringPtr = GT_FALSE;
    *origTileIdPtr  = SMAIN_NOT_VALID_CNS;
    *origTableIdPtr = SMAIN_NOT_VALID_CNS;

    return;
}
/**
* @internal smemAasUnitFdbTable function
* @endinternal
*
* @brief   Allocate address type specific memories -- for the ARP TABLE
*
* @param[in] devObjPtr            - pointer to device memory.
* @param[in] tileId               - the tileId
*/
static void smemAasUnitFdbTable
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN GT_U32                  tileId,
    IN GT_U32                  numEntries
)
{
#if 0  /* for reference purposes */
    ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC(0x02000000 ,33554432),
        SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(133, FDB_TABLE_ALIGN_IN_BYTES /*32*/),SMEM_BIND_SHARED_TABLE_MAC(fdbTable)}
#endif /*0*/

    smemDevUpdateUnitChunkSize(devObjPtr,
        devObjPtr->tablesInfo.fdbTable.commonInfo.baseAddress,
        numEntries * FDB_TABLE_ALIGN_IN_BYTES/*32*/ );/* num of bytes */

    devObjPtr->tablesInfo.fdbTable.paramInfo[0].outOfRangeIndex         =
        numEntries;
}

/**
* @internal smemAasUnitExactMatchTable function
* @endinternal
*
* @brief   Allocate address type specific memories -- for the EXACT MATCH TABLE unit
*
* @param[in] devObjPtr                - pointer to device memory.
* @param[in,out] instanceId           - the instance Id of the EM memory
*/
static void smemAasUnitExactMatchTable
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN GT_U32                  tileId,
    IN GT_U32                  wmTableType,
    IN GT_U32                  numEntries
)
{
#define  exactMatchEntryNumBytes_align  32 /* entry is 130 bits */
    SMEM_GENERIC_HIDDEN_MEM_STC *infoPtr;
    SMEM_GENERIC_HIDDEN_MEM_STC *orig_infoPtr = NULL;
    GT_U32  tableId = wmTableType - WM_TABLE_EM_0_E;
    GT_U32  instanceId = 8*tileId + tableId/*0..7*/;
    GT_U32  orig_instanceId = 0;
    GT_BOOL isSharedWithOrig;
    GT_U32  origTileId;
    GT_U32  origTableId;

    if(wmTableType < WM_TABLE_EM_0_E || wmTableType > WM_TABLE_EM_7_E)
    {
        skernelFatalError("smemAasUnitExactMatchTable: origTableId[%d]  is not EM related  \n" ,
            wmTableType);
    }

    infoPtr = SMEM_HIDDEN_MEM_INFO_GET(devObjPtr,SMEM_GENERIC_HIDDEN_MEM_EXACT_MATCH_TILE_0_TABLE_0_E,instanceId);

    if(numEntries == 0 && (infoPtr->startOfMemPtr == NULL || infoPtr->numOfEntries == 0))
    {
        /* nothing to free , nothing to allocate ... the table get not SBMs */
        return;
    }

    /* get info if the current table is one that was already allocated and we
       should just point to it */
    smemAasIsSharedTableWithOrig(devObjPtr,tileId,WM_TABLE_EM_0_E + tableId,
        &isSharedWithOrig,&origTileId,&origTableId);

    if(isSharedWithOrig)
    {
        if(origTableId < WM_TABLE_EM_0_E || origTableId > WM_TABLE_EM_7_E)
        {
            skernelFatalError("smemAasUnitExactMatchTable: origTableId[%d]  is not EM related  \n" ,
                origTableId);
        }

        origTableId -= WM_TABLE_EM_0_E;

        orig_instanceId = 8*origTileId + origTableId/*0..7*/;
        orig_infoPtr = SMEM_HIDDEN_MEM_INFO_GET(devObjPtr,SMEM_GENERIC_HIDDEN_MEM_EXACT_MATCH_TILE_0_TABLE_0_E,orig_instanceId);

        /* copy info from the orig table --> meaning we also use the same 'start memory' */
        infoPtr->startOfMemPtr           = orig_infoPtr->startOfMemPtr;
        infoPtr->alignmentOfEntryInWords = orig_infoPtr->alignmentOfEntryInWords;
        infoPtr->numOfEntries            = orig_infoPtr->numOfEntries;
        infoPtr->tableType               = orig_infoPtr->tableType;

        return;
    }

    if(numEntries == 0 && devObjPtr->sharedTablesInfo.isEmShared)
    {
        if(isSharedWithOrig == GT_FALSE)
        {
            smemDeviceObjMemoryPtrFree__internal(devObjPtr,infoPtr->startOfMemPtr,
                __FILE__,__LINE__);
        }
        else
        {
            /* let the 'orig' table release the memory*/
        }

        infoPtr->startOfMemPtr = 0;
        infoPtr->alignmentOfEntryInWords = exactMatchEntryNumBytes_align / 4;
        infoPtr->numOfEntries = 0;
        infoPtr->tableType = SMEM_GENERIC_HIDDEN_MEM_EXACT_MATCH_E;
        return;
    }

    if(infoPtr->startOfMemPtr && devObjPtr->sharedTablesInfo.isEmShared)
    {
        smemDeviceObjMemoryRealloc__internal(devObjPtr,infoPtr->startOfMemPtr,
            numEntries*exactMatchEntryNumBytes_align,
            __FILE__,__LINE__);

        infoPtr->numOfEntries = numEntries;
    }
    else
    if(infoPtr->startOfMemPtr == NULL)
    {
        infoPtr->startOfMemPtr = smemDeviceObjMemoryAlloc__internal(devObjPtr,numEntries,
                                                                exactMatchEntryNumBytes_align,__FILE__,__LINE__);
        if(infoPtr->startOfMemPtr == NULL)
        {
            skernelFatalError("smemAasUnitExactMatchTable: allocation failed \n" );
        }

        infoPtr->alignmentOfEntryInWords = exactMatchEntryNumBytes_align / 4;
        infoPtr->numOfEntries = numEntries;
        infoPtr->tableType = SMEM_GENERIC_HIDDEN_MEM_EXACT_MATCH_E;
    }

    return;
}


/**
* @internal smemAasUnitLpmTable function
* @endinternal
*
* @brief   Allocate address type specific memories -- for the LPM TABLE
*
* @param[in] devObjPtr            - pointer to device memory.
* @param[in] tileId               - the tileId of the LPM TABLE
*/
static void smemAasUnitLpmTable
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN GT_U32                  tileId,
    IN GT_U32                  numEntries
)
{
    GT_U32 bankIndex=0;
    GT_U32 numEntriesPerBank=0;
    GT_U32 startOfHiddenMemLpm_enum=0;
#if 0  /* for reference purposes */
    {{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC(0x00000000, ((96*1024)*32)),
         SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(132, 32),SMEM_BIND_SHARED_TABLE_MAC(lpmMemory)},
         FORMULA_SINGLE_PARAMETER(48, (LPM_SIZE/48))},
#endif /*0*/

    SIM_TBD_BOOKMARK    /* WM not use the numEntries that the CPSS set him with */
#if 0
    /* not know how to split the banks to large and small banks !!!
       so we allocated the size of 48 LPM banks */
    smemDevUpdateUnitChunkSize(devObjPtr,
        devObjPtr->tablesInfo.lpmMemory.commonInfo.baseAddress,
        devObjPtr->lpmRam.numOfLpmRams *
        devObjPtr->lpmRam.perRamNumEntries * 32/* num of bytes */ );
#endif

#define  lpmEntryNumBytes_align 32 /* entry is 132 bits */

    {
        SMEM_GENERIC_HIDDEN_MEM_STC *infoPtr;

        if (tileId==0)
        {
            startOfHiddenMemLpm_enum =SMEM_GENERIC_HIDDEN_MEM_LPM_TILE_0_BANK_0_E;
        }
        else
        {
            startOfHiddenMemLpm_enum =SMEM_GENERIC_HIDDEN_MEM_LPM_TILE_1_BANK_0_E;
        }

        /* calculate the number of lines per bank according to
           the init configuration of the shared memory size*/

        /*numEntriesPerBank = numEntries / LPM_MAX_NUM_OF_BLOCKS;*/ /* T.B.D update in the future to correct number */
        numEntriesPerBank = 256*1024; /* TBD- currently hard coded value */

        for(bankIndex = 0 ; bankIndex < LPM_MAX_NUM_OF_BLOCKS ; bankIndex++)
        {

            infoPtr = SMEM_HIDDEN_MEM_INFO_GET(devObjPtr,(startOfHiddenMemLpm_enum+bankIndex),tileId);

    #if 0
            if(numEntries == 0 && devObjPtr->sharedTablesInfo.isFdbShared)
            {
                smemDeviceObjMemoryPtrFree__internal(devObjPtr,infoPtr->startOfMemPtr,
                    __FILE__,__LINE__);

                infoPtr->startOfMemPtr = 0;
                infoPtr->alignmentOfEntryInWords = fdbEntryNumBytes_align / 4;
                infoPtr->numOfEntries = 0;
                infoPtr->tableType = SMEM_GENERIC_HIDDEN_MEM_FDB_E;
                return;
            }

            if(infoPtr->startOfMemPtr && devObjPtr->sharedTablesInfo.isFdbShared)
            {
                smemDeviceObjMemoryRealloc__internal(devObjPtr,infoPtr->startOfMemPtr,
                    numEntries*fdbEntryNumBytes_align,
                    __FILE__,__LINE__);

                infoPtr->numOfEntries = numEntries;
            }
            else
    #endif
            if(infoPtr->startOfMemPtr == NULL)
            {
                infoPtr->startOfMemPtr = smemDeviceObjMemoryAlloc__internal(devObjPtr,numEntriesPerBank,lpmEntryNumBytes_align,__FILE__,__LINE__);
                if(infoPtr->startOfMemPtr == NULL)
                {
                    skernelFatalError("smemFalconUnitFdbTable: allocation failed \n" );
                }

                infoPtr->alignmentOfEntryInWords = lpmEntryNumBytes_align / 4;
                infoPtr->numOfEntries = numEntriesPerBank;
                infoPtr->tableType = startOfHiddenMemLpm_enum+bankIndex;
            }
        }
    }
}

/**
* @internal smemAasUnitHaTsTable function
* @endinternal
*
* @brief   Allocate address type specific memories -- for the TS/NAT TABLE
*
* @param[in] devObjPtr            - pointer to device memory.
* @param[in] tileId               - the tileId
*/
static void smemAasUnitHaTsTable
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN GT_U32                  tileId,
    IN GT_U32                  numEntries
)
{
#if 0  /* for reference purposes */
    ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00800000, (NUM_TS/2)*256),
        SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(1584 ,256), SMEM_BIND_SHARED_TABLE_MAC(tunnelStartTable)}
#endif /*0*/

    devObjPtr->tablesInfo.tunnelStartTable.paramInfo[0].outOfRangeIndex =
        numEntries * devObjPtr->tablesInfo.tunnelStartTable.paramInfo[0].divider;/* support 8 regular TSs in single line */

    smemDevUpdateUnitChunkSize(devObjPtr,
        devObjPtr->tablesInfo.tunnelStartTable.commonInfo.baseAddress,
        numEntries * 256 );/* num of bytes */



}
/**
* @internal smemAasUnitHaArpTable function
* @endinternal
*
* @brief   Allocate address type specific memories -- for the ARP TABLE
*
* @param[in] devObjPtr            - pointer to device memory.
* @param[in] tileId               - the tileId
*/
static void smemAasUnitHaArpTable
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN GT_U32                  tileId,
    IN GT_U32                  numEntries
)
{
#if 0  /* for reference purposes */
    ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00400000, (NUM_ARPS/8)*64),
        SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(384,64), SMEM_BIND_SHARED_TABLE_MAC(arpTable)/*tunnelStart*/}
#endif /*0*/

    devObjPtr->tablesInfo.arpTable.paramInfo[0].outOfRangeIndex         =
        numEntries * devObjPtr->tablesInfo.arpTable.paramInfo[0].divider;/* support 8 arp in single line */

    smemDevUpdateUnitChunkSize(devObjPtr,
        devObjPtr->tablesInfo.arpTable.commonInfo.baseAddress,
        numEntries * 64 );/* num of bytes */
}

/**
* @internal smemAasUnitIpeTable function
* @endinternal
*
* @brief   Allocate address type specific memories -- for the IPE0/1 TABLE
*
* @param[in] devObjPtr            - pointer to device memory.
* @param[in] tileId               - the tileId
*/
static void smemAasUnitIpeTable
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN GT_U32                  tileId,
    IN GT_U32                  ipeId,
    IN GT_U32                  numEntries
)
{


#if 0  /* for reference purposes */
    ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x02000000, 16777216 ),
        SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(128,16) , SMEM_BIND_SHARED_TABLE_MAC(ipeState0Table)/*ipe0*/}
    ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x04000000, 16777216 ),
        SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(128,16) , SMEM_BIND_SHARED_TABLE_MAC(ipeState1Table)/*ipe1*/}

#endif /*0*/
    SKERNEL_TABLE_INFO_STC *ipeStateTablePtr = (ipeId == 0) ?
        &devObjPtr->tablesInfo.ipeStateT0Table :
        &devObjPtr->tablesInfo.ipeStateT1Table;


    ipeStateTablePtr->paramInfo[0].outOfRangeIndex         =
        numEntries * ipeStateTablePtr->paramInfo[0].divider;

    smemDevUpdateUnitChunkSize(devObjPtr,
        ipeStateTablePtr->commonInfo.baseAddress,
        numEntries * 16 );/* num of bytes per entry */
}

/**
* @internal smemAasActiveWriteShmSizeForWm function
* @endinternal
*
* @brief   CPSS write values for WM about table sizes. so WM can optimize the allocations of tables it uses.
*          !!! NOTE: this register does not exists in real HW !!!
*
* @param[in] devObjPtr                - device object PTR.
* @param[in] address                  - Address for ASIC memory.
* @param[in] memPtr                   - Pointer to the register's memory in the simulation.
* @param[in] param                    - Registers' specific parameter.
* @param[in] inMemPtr                 - Pointer to the memory to get register's content.
*/
static void smemAasActiveWriteShmSizeForWm (
    IN         SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN         GT_U32   address,
    IN         GT_U32   memSize,
    IN         GT_U32 * memPtr,
    IN         GT_UINTPTR   param,
    IN         GT_U32 * inMemPtr
)
{
    GT_U32  tileId = (devObjPtr->numOfTiles && devObjPtr->tileOffset) ? address / devObjPtr->tileOffset : 0;
    GT_U32  lastTileId = devObjPtr->numOfTiles ? devObjPtr->numOfTiles - 1 : 0;
    GT_U32  wmTableType;/* bits 0..7 */
    GT_U32  wmNumEntries;/* bits 8..24 (in 1K values)*/
    GT_U32  numOfSbms;  /* bits 25..31 */
    GT_U32  value;
    GT_U32  infoIndex;

    /* Update the register value */
    *memPtr = *inMemPtr;
    value   = *inMemPtr;

    wmTableType = value & 0x7F;/* 7 bits */
    wmNumEntries= (value >> 7) & 0x3FFFF;  /* 18 bits is 256K (times 1K)*/
    numOfSbms   = (value >> 25);/* 7 bits (till 128 banks) */

    if(tileId == 0)
    {
        /* print only once per device (when tile 0 is set) */
        /* to reduce the number on info printed            */
        /* assuming that the info for tile 0 is the same for all tiles */

        infoIndex = wmTableType - WM_TABLE_STATRTED_SESSION_E;

        if(wmTableType <= WM_TABLE_ENDED_SESSION_E)
        {
            simGeneralPrintf("WM : shared tables in tile[%d] : [%s] \n",
                tileId,
                shared_tables_info[infoIndex].name);
        }
        else
        {
            if(wmTableType == WM_TABLE_CNC_0_1_E || wmTableType == WM_TABLE_CNC_2_3_E)
            {
                simGeneralPrintf("WM : shared tables in tile[%d] : table [%s] , num blocks [%d] numOfSbms[%d]\n",
                    tileId,
                    shared_tables_info[infoIndex].name,
                    wmNumEntries,
                    numOfSbms);
            }
            else
            if(!shared_tables_info[infoIndex].comment)
            {
                simGeneralPrintf("WM : shared tables in tile[%d] : table [%s] , num lines [%d] (in K entries) numOfSbms[%d]\n",
                    tileId,
                    shared_tables_info[infoIndex].name,
                    wmNumEntries,
                    numOfSbms);
            }
            else
            {
                simGeneralPrintf("WM : shared tables in tile[%d] : table [%s] , num lines(%s) [%d] (in K entries) numOfSbms[%d]\n",
                    tileId,
                    shared_tables_info[infoIndex].name,
                    shared_tables_info[infoIndex].comment,
                    wmNumEntries,
                    numOfSbms);
            }
        }
    }

    if(wmTableType == WM_TABLE_ENDED_SESSION_E)
    {
        GT_U32  regValue_ipe0,regValue_ipe1;
        GT_U32  ii,numBits_ipe0,numBits_ipe1;

        smemRegGet(devObjPtr, SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->SHM.ipe0_state_select, &regValue_ipe0);
        smemRegGet(devObjPtr, SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->SHM.ipe1_state_select, &regValue_ipe1);

        numBits_ipe0 = 0;
        numBits_ipe1 = 0;
        for(ii = 0 ; ii < 32 ; ii++)
        {
            if(regValue_ipe0 & (1<<ii))
            {
                numBits_ipe0++;
            }
            if(regValue_ipe1 & (1<<ii))
            {
                numBits_ipe1++;
            }
        }

        wmNumEntries = numBits_ipe0 /* there are 2 blocks in SBM */ *
                    (CNC_NUM_LINES/2);

        if(tileId == 0)
        {
            simGeneralPrintf("WM : shared tables in tile[%d] : table [WM_TABLE_IPE_0_E] , num lines [%d] (in K entries)\n",
                tileId,
                wmNumEntries/_1K);
        }

        if(devObjPtr->sharedTablesInfo.isIpe0Shared && wmNumEntries)
        {
            /* allocate the IPE0 memory */
            smemAasUnitIpeTable(devObjPtr,tileId,0/*ipe0*/,wmNumEntries/*no need *_1K*/);
        }

        wmNumEntries = numBits_ipe1 /* there are 2 blocks in SBM */ *
                    (CNC_NUM_LINES/2);

        if(tileId == 0)
        {
            simGeneralPrintf("WM : shared tables in tile[%d] : table [WM_TABLE_IPE_1_E] , num lines [%d] (in K entries)\n",
                tileId,
                wmNumEntries/_1K);
        }

        if(devObjPtr->sharedTablesInfo.isIpe1Shared && wmNumEntries)
        {
            /* allocate the IPE1 memory */
            smemAasUnitIpeTable(devObjPtr,tileId,1/*ipe1*/,wmNumEntries/*no need *_1K*/);
        }
    }/* no 'else / elseif' after it */

    if(wmTableType == WM_TABLE_FDB_E && devObjPtr->sharedTablesInfo.isFdbShared)
    {
        /* allocate the FDB hidden memory */
        /* (according to it's size in the SHM unit) */
        smemAasUnitFdbTable(devObjPtr,tileId,wmNumEntries*_1K);
    }
    else
    if((wmTableType >= WM_TABLE_EM_0_E && wmTableType <= WM_TABLE_EM_7_E) &&
        devObjPtr->sharedTablesInfo.isEmShared)
    {
        /* allocate the Exact Match hidden memory */
        /* (according to it's size in the SHM unit) */
        smemAasUnitExactMatchTable(devObjPtr,tileId,wmTableType,wmNumEntries*_1K);
    }
    else
    if(wmTableType == WM_TABLE_LPM_E && devObjPtr->sharedTablesInfo.isLpmShared)
    {
        /* allocate the LPM memory */
        /* (according to it's size in the SHM unit) */
        smemAasUnitLpmTable(devObjPtr,tileId,wmNumEntries*_1K);
    }
    else
    if(wmTableType == WM_TABLE_TS_E && devObjPtr->sharedTablesInfo.isTsShared)
    {
        /* allocate the TS/NAT memory */
        /* (according to it's size in the SHM unit) */
        smemAasUnitHaTsTable(devObjPtr,tileId,wmNumEntries*_1K);
    }
    else
    if(wmTableType == WM_TABLE_ARP_E && devObjPtr->sharedTablesInfo.isArpShared)
    {
        /* allocate the ARP memory */
        /* (according to it's size in the SHM unit) */
        smemAasUnitHaArpTable(devObjPtr,tileId,wmNumEntries*_1K);
    }
    else
    if(lastTileId == tileId && wmTableType == WM_TABLE_ENDED_SESSION_E)
    {
        /* print the new device allocation summary (same print done during WM init) */
        simGeneralPrintf("allocated [%u] bytes \n",devObjPtr->totalNumberOfBytesAllocated);
    }
}
/**
* @internal smemAasActiveWriteShmCncBmpWm function
* @endinternal
*
* @brief   CPSS write CNC BMP for WM about.
*          !!! NOTE: this register does not exists in real HW !!!
*
* @param[in] devObjPtr                - device object PTR.
* @param[in] address                  - Address for ASIC memory.
* @param[in] memPtr                   - Pointer to the register's memory in the simulation.
* @param[in] param                    - Registers' specific parameter.
* @param[in] inMemPtr                 - Pointer to the memory to get register's content.
*/
static void smemAasActiveWriteShmCncBmpWm (
    IN         SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN         GT_U32   address,
    IN         GT_U32   memSize,
    IN         GT_U32 * memPtr,
    IN         GT_UINTPTR   param,
    IN         GT_U32 * inMemPtr
)
{
    /* Update the register value */
    *memPtr = *inMemPtr;

    if((GT_U32)param == 1)
    {
        /* BMP of CNC 0_1 blocks that connected to memory
           this BMP not hold the blocks that are used for IPE0,1 needs */
        devObjPtr->sharedTablesInfo.cnc.sip7_cnc_0_1_usedBlocksBmp = *memPtr;
    }
    else
    if((GT_U32)param == 2)
    {
        /* BMP of CNC 2_3 blocks that connected to memory */
        devObjPtr->sharedTablesInfo.cnc.sip7_cnc_2_3_usedBlocksBmp = *memPtr;
    }

}

/**
* @internal smemAasActiveWriteShmSharingInfoWm function
* @endinternal
*
* @brief   CPSS write CNC BMP for WM about.
*          !!! NOTE: this register does not exists in real HW !!!
*          NOTE: those settings must be set , before calling
*           smemAasActiveWriteShmSizeForWm(...) , that need to use those settings.
*
* @param[in] devObjPtr                - device object PTR.
* @param[in] address                  - Address for ASIC memory.
* @param[in] memPtr                   - Pointer to the register's memory in the simulation.
* @param[in] param                    - Registers' specific parameter.
* @param[in] inMemPtr                 - Pointer to the memory to get register's content.
*/
static void smemAasActiveWriteShmSharingInfoWm (
    IN         SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN         GT_U32   address,
    IN         GT_U32   memSize,
    IN         GT_U32 * memPtr,
    IN         GT_UINTPTR   param,
    IN         GT_U32 * inMemPtr
)
{
    GT_U32  ii;
    GT_U32  tileId;
    GT_U32  tableId;
    GT_BIT  isSharedWithOrig;
    GT_U32  origTileId;
    GT_U32  origTableId;
    GT_U32  value;

    /* Update the register value */
    *memPtr = *inMemPtr;

    value = *memPtr;

    tileId  = SMEM_U32_GET_FIELD(value,0,1);
    tableId = SMEM_U32_GET_FIELD(value,1,8);
    isSharedWithOrig = SMEM_U32_GET_FIELD(value,9,1);

    origTileId  = SMEM_U32_GET_FIELD(value,10,1);
    origTableId = SMEM_U32_GET_FIELD(value,11,8);

    if(isSharedWithOrig == 0)
    {
        /* TBD if that info needed */
        return;
    }

    for(ii = 0 ; ii < SKERNEL_SHARING_PAIRS_MAX_NUM_CNS ; ii++)
    {
        if(GT_TRUE == devObjPtr->sharedTablesInfo.sharing_pairs[ii].isUsed)
        {
            /* already used index */
            continue;
        }
        /* set entry as used */
        devObjPtr->sharedTablesInfo.sharing_pairs[ii].isUsed = GT_TRUE;
        /* fill the info */
        devObjPtr->sharedTablesInfo.sharing_pairs[ii].tileId           = tileId          ;
        devObjPtr->sharedTablesInfo.sharing_pairs[ii].tableId          = tableId         ;
        devObjPtr->sharedTablesInfo.sharing_pairs[ii].isSharedWithOrig = isSharedWithOrig;
        devObjPtr->sharedTablesInfo.sharing_pairs[ii].origTileId       = origTileId      ;
        devObjPtr->sharedTablesInfo.sharing_pairs[ii].origTableId      = origTableId     ;

        break;
    }


    return;
}

/**
* @internal smemAasActiveWriteShmLpmBlockWm function
* @endinternal
*
* @brief   CPSS write LPM block size for WM .
*          !!! NOTE: this register does not exists in real HW !!!
*
* @param[in] devObjPtr                - device object PTR.
* @param[in] address                  - Address for ASIC memory.
* @param[in] memPtr                   - Pointer to the register's memory in the simulation.
* @param[in] param                    - Registers' specific parameter.
* @param[in] inMemPtr                 - Pointer to the memory to get register's content.
*/
static void smemAasActiveWriteShmLpmBlockWm (
    IN         SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN         GT_U32   address,
    IN         GT_U32   memSize,
    IN         GT_U32 * memPtr,
    IN         GT_UINTPTR   param,
    IN         GT_U32 * inMemPtr
)
{
    GT_U32  value;
    GT_U32  wmNumEntries;/* bits 0..15 (in 1K values)*/
    GT_U32  wmLpmBlock  ;/* bits 16..24 */

    /* Update the register value */
    *memPtr = *inMemPtr;

    value = *memPtr;

    wmNumEntries = value & 0xFFFF;/* 16 bits */
    wmLpmBlock   = value >> 16;

    if(wmLpmBlock >= 48)
    {
        /* avoid access violation */
        skernelFatalError("smemAasActiveWriteShmLpmBlockWm : wmLpmBlock[%d] should not be >= 48 \n");
    }

    /* BMP of LPM0..31 blocks that connected to memory */
    devObjPtr->sharedTablesInfo.lpm.sip7_lpm_numSbmsPerBlock[wmLpmBlock] = wmNumEntries * _1K;

}

/**
* @internal smemAasUnitShm function
* @endinternal
*
* @brief   Allocate address type specific memories -- for the
*          AAS SHM unit
*/
static void smemAasUnitShm
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    INOUT SMEM_UNIT_CHUNKS_STC  * unitPtr
)
{
    START_BIND_UNIT_ACTIVE_MEM_MAC(devObjPtr,unitPtr)
        /* for WM purpose only : see smemFalconActiveWriteShmSizeForWm */
        {SHM_ADDR_REG_FOR_WM_TABLE_SIZE   , SMEM_FULL_MASK_CNS, NULL, 0, smemAasActiveWriteShmSizeForWm, 0},
        /* setting BMP of 32 CNC_0_1 blocks */
        {SHM_ADDR_REG_FOR_WM_TABLE_SIZE+0x4 , SMEM_FULL_MASK_CNS, NULL, 0, smemAasActiveWriteShmCncBmpWm, 1/*CNC_0_1*/},
        /* setting BMP of 32 CNC_2_3 blocks */
        {SHM_ADDR_REG_FOR_WM_TABLE_SIZE+0x8 , SMEM_FULL_MASK_CNS, NULL, 0, smemAasActiveWriteShmCncBmpWm, 2/*CNC_2_3*/},
        /* info about sharing between tables in the same tile or with other tile */
        {SHM_ADDR_REG_FOR_WM_TABLE_SIZE+0xc , SMEM_FULL_MASK_CNS, NULL, 0, smemAasActiveWriteShmSharingInfoWm, 0},
        /* setting num lines for per LPM block */
        {SHM_ADDR_REG_FOR_WM_TABLE_SIZE+0x10 , SMEM_FULL_MASK_CNS, NULL, 0, smemAasActiveWriteShmLpmBlockWm, 0},
    END_BIND_UNIT_ACTIVE_MEM_MAC(devObjPtr,unitPtr)

    {
        SMEM_CHUNK_BASIC_STC  chunksMem[]=
        {
             {SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000000, 0x00000204)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000300, 0x00000374)}

            /* for WM purpose only : see
                smemFalconActiveWriteEm_sizeForWm
                smemAasActiveWriteShmCncBmpWm
                smemAasActiveWriteShmSharingInfoWm
                smemAasActiveWriteShmLpmBlockWm
            */
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (SHM_ADDR_REG_FOR_WM_TABLE_SIZE,
                    SHM_ADDR_REG_FOR_WM_TABLE_SIZE + 0x10)}
        };
        GT_U32  numOfChunks = sizeof(chunksMem)/sizeof(SMEM_CHUNK_BASIC_STC);

        smemInitMemChunk(devObjPtr,chunksMem,numOfChunks,unitPtr);
    }
    {
        static SMEM_REGISTER_DEFAULT_VALUE_STC myUnit_registersDefaultValueArr[] =
        {                                       /*shm_metal_fix_register*/
             {DUMMY_NAME_PTR_CNS,            0x00000360,         0xFFFF0000,      1,    0x0 }

            ,{NULL,            0,         0x00000000,      0,    0x0      }
        };
        static SMEM_LINK_LIST_REGISTER_DEFAULT_VALUE_STC list = {myUnit_registersDefaultValueArr,NULL};
        unitPtr->unitDefaultRegistersPtr = &list;
    }

    {/*start of unit SHM */
        {/*00000000+n*0x4*/
            GT_U32    n;
            for(n = 0 ; n < 130 ; n++) {
                SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->SHM.block_port_select[n] = 0x00000000+n*0x4;
            }/* end of loop n */
        }/*00000000+n*0x4*/
        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->SHM.fdb_illegal_address        = 0x00000300;
        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->SHM.em_illegal_address         = 0x00000304;
        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->SHM.arp_illegal_address        = 0x00000308;
        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->SHM.ts_illegal_address         = 0x0000030c;
        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->SHM.plr_met_illegal_address    = 0x00000310;
        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->SHM.plr_count_illegal_address  = 0x00000314;
        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->SHM.cnc_illegal_address        = 0x00000318;
        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->SHM.lpm_illegal_address        = 0x0000031c;
        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->SHM.lpm_aging_illegal_address  = 0x00000320;
        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->SHM.ipe_illegal_address        = 0x00000324;
        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->SHM.hf0_illegal_address        = 0x00000328;
        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->SHM.hf1_illegal_address        = 0x0000032c;
        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->SHM.bad_address_latch          = 0x00000364;
        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->SHM.shm_error_sum_cause        = 0x00000368;
        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->SHM.shm_error_sum_mask         = 0x0000036c;
        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->SHM.ipe0_state_select          = 0x00000370;
        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->SHM.ipe1_state_select          = 0x00000374;

    }/*end of unit SHM */
}

static GT_U32 smemAasEmInstanceByAddrGet(
    IN SKERNEL_DEVICE_OBJECT *devObjPtr,
    IN GT_U32                 address
)
{
    GT_U32  instance;

    if(address >= AAS_ADDR_EM0 &&
       address <  (AAS_ADDR_EM0+EM_SIZE))
    {
        instance = 0;
    }
    else
    if(address >= AAS_ADDR_EM1 &&
       address <  (AAS_ADDR_EM1+EM_SIZE))
    {
        instance = 1;
    }
    else
    if(address >= AAS_ADDR_EM2 &&
       address <  (AAS_ADDR_EM2+EM_SIZE))
    {
        instance = 2;
    }
    else
    if(address >= AAS_ADDR_EM3 &&
       address <  (AAS_ADDR_EM3+EM_SIZE))
    {
        instance = 3;
    }
    else
    if(address >= AAS_ADDR_EM4 &&
       address <  (AAS_ADDR_EM4+EM_SIZE))
    {
        instance = 4;
    }
    else
    if(address >= AAS_ADDR_EM5 &&
       address <  (AAS_ADDR_EM5+EM_SIZE))
    {
        instance = 5;
    }
    else
    if(address >= AAS_ADDR_EM6 &&
       address <  (AAS_ADDR_EM6+EM_SIZE))
    {
        instance = 6;
    }
    else
    {
        instance = 7;
    }
    return instance;
}

/**
* @internal smemAasActiveWriteExactMatchMsg function
* @endinternal
*
* @brief   Write to the Message from CPU Registers - activate
*          update Exact Match message.
*
* @param[in] devObjPtr                - device object PTR.
* @param[in] address                  - Address for ASIC memory.
* @param[in] memPtr                   - Pointer to the register's memory in the simulation.
* @param[in] param                    - Registers' specific parameter.
* @param[in] inMemPtr                 - Pointer to the memory to get register's content.
*
* logic based on : smemLion3ActiveWriteFdbMsg
*/
static void smemAasActiveWriteExactMatchMsg(
    IN SKERNEL_DEVICE_OBJECT *devObjPtr,
    IN GT_U32                 address,
    IN GT_U32                 memSize,
    IN GT_U32                *memPtr,
    IN GT_UINTPTR             param,
    IN GT_U32                *inMemPtr
)
{
    GT_U32            * regPtr;         /* register's entry pointer */
    GT_U32              line;           /* line number */
    GT_U32              rdWr;           /* Read or write operation */
    GT_U32              RdWrTrig;       /* When set to 1, an FDB read or write access is performed.
                                           This bit is cleared by the device when the access action is completed*/
    GT_U32              numOfBanks;     /* hold number of Exact Match banks*/
    SMEM_GENERIC_HIDDEN_MEM_STC *infoPtr;
    GT_U32              instance = smemAasEmInstanceByAddrGet(devObjPtr,address);

    DECLARE_FUNC_NAME(smemAasActiveWriteExactMatchMsg);

    /* data to be written */
    *memPtr = *inMemPtr;

    RdWrTrig = SMEM_U32_GET_FIELD(*inMemPtr, 0, 1);
    if(RdWrTrig == 0)
    {
        return;
    }

    rdWr = SMEM_U32_GET_FIELD(*inMemPtr, 1, 1);
    line = SMEM_U32_GET_FIELD(*inMemPtr, 2, 21);

    __LOG(("smemAasActiveWriteExactMatchMsg : Exact Match unit [%d] index [0x%08x] (before line convert)  \n", instance , line ));
    /*change back the index format from GM pattern (4 msb bits for bank number )
    to  WM pattern,(number of bits depends on number of banks )*/
    numOfBanks = devObjPtr->emNumOfBanks[instance] ;
    line = (((line>>4) * numOfBanks /*shift 2,3,4 bits left */ ) | ( line & (numOfBanks-1)/*num of bits to take */)) ;

    __LOG(("smemAasActiveWriteExactMatchMsg : Exact Match unit [%d] index [0x%08x] (after line convert)  \n", instance , line ));

    infoPtr = SMEM_HIDDEN_MEM_INFO_GET(devObjPtr,SMEM_GENERIC_HIDDEN_MEM_EXACT_MATCH_TILE_0_TABLE_0_E,instance);
    if(line >= infoPtr->numOfEntries)
    {
        __LOG(("smemAasActiveWriteExactMatchMsg : ERROR : try to access Exact Match unit [%d] index [0x%08x] but hidden memory supports only [0x%08x] lines \n",
            instance , line ,infoPtr->numOfEntries));
    }
    else
    {
        /* Get EM entry */
        if (rdWr)/* write the data from the msg registers to the Exact Match table  */
        {
            /* copy from registers of indirect to the EM specific index */
            regPtr = smemMemGet(devObjPtr, address + 0x4);
            smemGenericHiddenMemSet(devObjPtr, SMEM_GENERIC_HIDDEN_MEM_EXACT_MATCH_TILE_0_TABLE_0_E+instance, line , regPtr, 5);
        }
        else/* read the data from the Exact Match table into the msg registers */
        {
            /* copy from the EM specific index to the registers of indirect */
            regPtr = SMEM_SIP7_HIDDEN_EXACT_MATCH_PTR(devObjPtr, SIP7_EXACT_MATCH_UNIT_0_E+instance, line);
            /* Mac Table Access Data */
            smemMemSet(devObjPtr, address + 0x4, regPtr, 5);
        }
    }

    /* clear <RdWrTrig> */
    SMEM_U32_SET_FIELD(*memPtr, 0, 1, 0);

    return;
}

/**
* @internal smemAasActiveWriteExactMatchGlobalCfgReg function
* @endinternal
*
* @brief   The function updates Exact Match table size according
*          to EM_Global_Configuration 1
*
* @param[in] devObjPtr                - device object PTR.
* @param[in] address                  - Address for ASIC memory.
* @param[in] memPtr                   - Pointer to the register's memory in the simulation.
* @param[in] memSize                  - Size of memory to be written
* @param[in] param                    - Registers' specific parameter.
* @param[in] inMemPtr                 - Pointer to the memory to get register's content.
*/
static void smemAasActiveWriteExactMatchGlobalCfgReg
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN GT_U32       address,
    IN GT_U32       memSize,
    IN GT_U32       *memPtr,
    IN GT_UINTPTR   param,
    IN GT_U32       *inMemPtr
)
{
    GT_U32 emSize;
    GT_U32 emNumEntries;
    GT_U32 banksNumber;
    GT_U32 emNumOfBanks;
    GT_U32 instance = smemAasEmInstanceByAddrGet(devObjPtr,address);

    /* data to be written */
    *memPtr = *inMemPtr;

    /* emSize */
    emSize = SMEM_U32_GET_FIELD(*inMemPtr, 0, 3);
    switch(emSize)
    {
        case 0:
            emNumEntries = SMEM_MAC_TABLE_SIZE_4KB;
            break;
        case 1:
            emNumEntries = SMEM_MAC_TABLE_SIZE_8KB;
            break;
        case 2:
            emNumEntries = SMEM_MAC_TABLE_SIZE_16KB;
            break;
        case 3:
            emNumEntries = SMEM_MAC_TABLE_SIZE_32KB;
            break;
        case 4:
            emNumEntries = SMEM_MAC_TABLE_SIZE_64KB;
            break;
        case 5:
            emNumEntries = SMEM_MAC_TABLE_SIZE_128KB;
            break;
        case 6:
            emNumEntries = SMEM_MAC_TABLE_SIZE_256KB;
            break;
        case 7:
            emNumEntries = SMEM_MAC_TABLE_SIZE_512KB;
            break;
        default:/*on 3 bits value .. can not get here*/
            emNumEntries = devObjPtr->emNumEntries[instance];/*unchanged*/
            break;
    }

    devObjPtr->emNumEntries[instance] = emNumEntries;

    if(devObjPtr->emMaxNumEntries < devObjPtr->emNumEntries[instance])
    {
        skernelFatalError("smemAasActiveWriteExactMatchGlobalCfgReg: EM num entries in HW [0x%4.4x] , but set to use[0x%4.4x] \n",
            devObjPtr->emMaxNumEntries , devObjPtr->emNumEntries[instance]);
    }

    /* banksNumber */
    banksNumber = SMEM_U32_GET_FIELD(*inMemPtr, 3, 2);
    switch(banksNumber)
    {
        case 0:
            emNumOfBanks = 4;
            break;
        case 1:
            emNumOfBanks = 8;
            break;
        case 2:
            emNumOfBanks = 16;
            break;
        default:/*on 3 bits value .. can not get here*/
            emNumOfBanks = devObjPtr->emNumOfBanks[instance];/*unchanged*/
            break;
    }

    devObjPtr->emNumOfBanks[instance] = emNumOfBanks;

    return;
}

#if 0
/**
* @internal smemHawkActiveWriteEMFlowIdAllocationConfiguration1 function
* @endinternal
*
* @brief  automatically clear "Recycle Flow ID En" field
*
* @param[in] devObjPtr                - device object PTR.
* @param[in] address                  - Address for ASIC memory.
* @param[in] memPtr                   - Pointer to the register's memory in the simulation.
* @param[in] param                    - Registers' specific parameter - global interrupt bit number.
*
* @param[out] outMemPtr               - Pointer to the memory to copy register's content.
*
*
*/
static void smemHawkActiveWriteEMFlowIdAllocationConfiguration1
(
    IN         SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN         GT_U32   address,
    IN         GT_U32   memSize,
    IN         GT_U32 * memPtr,
    IN         GT_UINTPTR   param,
    OUT        GT_U32 * outMemPtr
)
{
     /* data to be written */
    *memPtr = *outMemPtr;

    /* bit 0 is set by the CPU and causes the <First Flow ID> to be marked as free */
    if(*memPtr&1)
    {
        sip6_10_ExactMatchRecycleFlowId(devObjPtr);
        /* bit 0 should be automatically cleared. */
        SMEM_U32_SET_FIELD(*memPtr, 0, 1 , 0);
    }
}
#endif


/**
* @internal smemAasUnitEm function
* @endinternal
*
* @brief   Allocate address type specific memories
*          - for the any of the 8 EM units: EM0-EM7
* @param[in]     devObjPtr   - pointer to device object.
* @param[in,out] unitPtr     - pointer to the unit chunk
*/
static void smemAasUnitEm
(
    IN    SKERNEL_DEVICE_OBJECT    *devObjPtr,
    INOUT SMEM_UNIT_CHUNKS_STC     *unitPtr
)
{
    START_BIND_UNIT_ACTIVE_MEM_MAC(devObjPtr,unitPtr)

    /*EM*/
    /* indirect Access Control Register */
    {0x00002000, SMEM_FULL_MASK_CNS, NULL, 0 , smemAasActiveWriteExactMatchMsg,0},

    /* EM Global Configuration 1 register */
    {0x00000000, SMEM_FULL_MASK_CNS, NULL, 0 , smemAasActiveWriteExactMatchGlobalCfgReg, 0},

    /* EM Interrupt Cause Register */
    {0x00004000, SMEM_FULL_MASK_CNS, smemChtActiveReadIntrCauseReg, 17, smemChtActiveWriteIntrCauseReg, 0},
    /* EM Interrupt Mask Register */
    {0x00004004, SMEM_FULL_MASK_CNS, NULL, 0, smemChtActiveWriteMacInterruptsMaskReg, 0},

    /* EM Flow ID Allocation Configuration 1*/
    /*{0x00001100, SMEM_FULL_MASK_CNS,NULL, 0, smemHawkActiveWriteEMFlowIdAllocationConfiguration1, 0},*/

    /* ROC (read only clear) counters */
    /*  EM flow Id fail counter */
    {0x00001148, SMEM_FULL_MASK_CNS, smemChtActiveReadCntrs, 0, NULL,0},
    /*  EM index fail counter */
    {0x0000114c, SMEM_FULL_MASK_CNS, smemChtActiveReadCntrs, 0, NULL,0},

    END_BIND_UNIT_ACTIVE_MEM_MAC(devObjPtr,unitPtr)

    {
        SMEM_CHUNK_BASIC_STC  chunksMem[]=
        {
            /* registers space */
            {SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000000, 0x00000004)}
           ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001000, 0x00001160)}
           ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00002000, 0x00002014)}
           ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00003000, 0x00003004)}
           ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00004000, 0x00004004)}
           ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00005000, 0x00005004)}
           ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00006000, 0x00006040)}
           ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00006048, 0x0000604C)}
           ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00020000, 131072 ),SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(39 , 8)}
        };
        GT_U32  numOfChunks = sizeof(chunksMem)/sizeof(SMEM_CHUNK_BASIC_STC);
        smemInitMemChunk(devObjPtr, chunksMem, numOfChunks, unitPtr);
    }
    {
        SMEM_CHUNK_BASIC_STC  chunksMem[]=
        {
           /*Auto Learned EM Entry Index Table
                0x40000 + i: where i (0-2730) represents flowid */
            {SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00040000, 43696),SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(114 , 16),SMEM_BIND_TABLE_MAC(exactMatchAutoLearnedEntryIndexTable)}
        };

        /* support Hawk , Phoenix */
        chunksMem[0].numOfRegisters = devObjPtr->emAutoLearnNumEntries * (chunksMem[0].enrtyNumBytesAlignement / 4);

        smemUnitChunkAddBasicChunk(devObjPtr,unitPtr,
            ARRAY_NAME_AND_NUM_ELEMENTS_MAC(chunksMem));
    }

    {
        static SMEM_REGISTER_DEFAULT_VALUE_STC myUnit_registersDefaultValueArr[] =
        {
            {DUMMY_NAME_PTR_CNS,           0x00000000,         0x00000135,      1,    0x0}
           ,{DUMMY_NAME_PTR_CNS,           0x00000004,         0xffffffff,      1,    0x0}
           ,{DUMMY_NAME_PTR_CNS,           0x00001100,         0x0001fffe,      1,    0x0}
           ,{DUMMY_NAME_PTR_CNS,           0x00003000,         0x0000ffff,      1,    0x0}
           ,{DUMMY_NAME_PTR_CNS,           0x00005000,         0x0000843f,      1,    0x0}
           ,{DUMMY_NAME_PTR_CNS,           0x00005004,         0x00000009,      1,    0x0}
           ,{DUMMY_NAME_PTR_CNS,           0x0000600c,         0x000007e0,      1,    0x0}
           ,{NULL,                         0x00000000,         0x00000000,      0,    0x0}

        };
        static SMEM_LINK_LIST_REGISTER_DEFAULT_VALUE_STC list = {myUnit_registersDefaultValueArr,NULL};
        unitPtr->unitDefaultRegistersPtr = &list;
    }
    {/*start of unit Exact Match */

        {/*start of emGlobalConfiguration*/
            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->EXACT_MATCH[0].emGlobalConfiguration.emGlobalConfiguration1 = 0x0000;
            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->EXACT_MATCH[0].emGlobalConfiguration.emCRCHashInitConfiguration = 0x0004;
        }/*end of emGlobalConfiguration*/

        {/*start of emIndirectAccess*/
            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->EXACT_MATCH[0].emIndirectAccess.emIndirectAccessControl = 0x00002000;
            {/* 0x00002004 + n*4 */
                GT_U32    n;
                for (n = 0 ; n <= 4 ; n++) {
                    SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->EXACT_MATCH[0].emIndirectAccess.emIndirectAccessData[n] =
                        0x00002004+4*n;
                }/* end of loop n */
            }/* 0x00002004 + n*4 */
        }/*end of emIndirectAccess*/

        {/*start of emInterrupt*/
            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->EXACT_MATCH[0].emInterrupt.emInterruptCauseReg = 0x00004000;
            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->EXACT_MATCH[0].emInterrupt.emInterruptMaskReg = 0x00004004;
        }/*end of emInterrupt*/

        {/*start of emSchedulerConfiguration*/
            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->EXACT_MATCH[0].emSchedulerConfiguration.emSchedulerSWRRArbiterWeights = 0x00005000;
            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->EXACT_MATCH[0].emSchedulerConfiguration.emSchedulerSWRRArbiterPriority = 0x00005004;
        }/*end of emSchedulerConfiguration*/

        {/*start of emAutoLearning*/ /* sip6_10 only*/

            {
                GT_U32    n;
                for (n = 0 ; n <= 15 ; n++) {
                    SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->EXACT_MATCH[0].emAutoLearning.emProfileConfiguration1[n] =
                        0x00001000+0x10*n;
                    SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->EXACT_MATCH[0].emAutoLearning.emProfileConfiguration2[n] =
                        0x00001004+0x10*n;
                    SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->EXACT_MATCH[0].emAutoLearning.emProfileConfiguration3[n] =
                        0x00001008+0x10*n;
                    SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->EXACT_MATCH[0].emAutoLearning.emProfileConfiguration4[n] =
                        0x0000100c+0x10*n;
                }/* end of loop n */
            }
            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->EXACT_MATCH[0].emAutoLearning.emFlowIdAllocationConfiguration1=0x00001100;
            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->EXACT_MATCH[0].emAutoLearning.emFlowIdAllocationConfiguration2=0x00001104;
            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->EXACT_MATCH[0].emAutoLearning.emFlowIdAllocationStatus1=0x00001108;
            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->EXACT_MATCH[0].emAutoLearning.emFlowIdAllocationStatus2=0x0000110c;
            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->EXACT_MATCH[0].emAutoLearning.emFlowIdAllocationStatus3=0x00001160;
            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->EXACT_MATCH[0].emAutoLearning.emAutoLearningCollisionStatus1=0x00001110;
            {/* 0x00001114 + n*4 */
                GT_U32    n;
                for (n = 2 ; n <= 13 ; n++) {
                     SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->EXACT_MATCH[0].emAutoLearning.emAutoLearningCollisionStatus_n[n-2] =
                        0x00001114+(n-2)*4 ;
                }/* end of loop n */
            }/* 0x00001114 + (n-2)*4: where n (2-13) represents chunk*/
            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->EXACT_MATCH[0].emAutoLearning.emSemaphore=0x00001144;
            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->EXACT_MATCH[0].emAutoLearning.emFlowIdFailCounter=0x00001148;
            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->EXACT_MATCH[0].emAutoLearning.emIndexFailCounter=0x0000114c;
            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->EXACT_MATCH[0].emAutoLearning.emRateLimiterFailCounter=0x00001150;
            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->EXACT_MATCH[0].emAutoLearning.emRateLimitConfiguration=0x00001154;
            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->EXACT_MATCH[0].emAutoLearning.emRateLimitBurstCounter=0x00001158;
            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->EXACT_MATCH[0].emAutoLearning.emRateLimitPacketsCounter=0x0000115c;
        }/*end of emAutoLearning*/
    }
}


/**
* @internal smemAasUnitReducedEm function
* @endinternal
*
* @brief   Allocate address type specific memories
*          -- for the REDUCED_EM unit
* @param[in,out] unitPtr - pointer to the unit chunk
*/
static void smemAasUnitReducedEm
(
    IN    SKERNEL_DEVICE_OBJECT *devObjPtr,
    INOUT SMEM_UNIT_CHUNKS_STC  *unitPtr
)
{

   {
        SMEM_CHUNK_BASIC_STC  chunksMem[]=
        {
            /* registers space */
            {SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000000, 0x00000004)}
            /* Reduced EM Table - 8192 lines (8K) */
           ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC(0x00000010, 262144), SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(130, 32),SMEM_BIND_TABLE_MAC(reducedEmTable)}
        };
        GT_U32  numOfChunks = sizeof(chunksMem)/sizeof(SMEM_CHUNK_BASIC_STC);
        smemInitMemChunk(devObjPtr, chunksMem, numOfChunks, unitPtr);
    }
    {
        static SMEM_REGISTER_DEFAULT_VALUE_STC myUnit_registersDefaultValueArr[] =
        {
            {DUMMY_NAME_PTR_CNS,           0x00000000,         0x00000122,      1,    0x0}
           ,{DUMMY_NAME_PTR_CNS,           0x00000004,         0xffffffff,      1,    0x0}
           ,{NULL,                         0x00000000,         0x00000000,      0,    0x0}

        };
        static SMEM_LINK_LIST_REGISTER_DEFAULT_VALUE_STC list = {myUnit_registersDefaultValueArr,NULL};
        unitPtr->unitDefaultRegistersPtr = &list;
    }
    {/*start of unit Exact Match */

        {/*start of emGlobalConfiguration*/
            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->REDUCED_EM.emGlobalConfiguration.emGlobalConfiguration1 = 0x0000;
            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->REDUCED_EM.emGlobalConfiguration.emCRCHashInitConfiguration = 0x0004;
        }/*end of emGlobalConfiguration*/
    }
}

/**
* @internal smemAasUnitMll function
* @endinternal
*
* @brief   Allocate address type specific memories -- for the MLL unit
*/
static void smemAasUnitMll
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    INOUT SMEM_UNIT_CHUNKS_STC  * unitPtr
)
{
    START_BIND_UNIT_ACTIVE_MEM_MAC(devObjPtr,unitPtr)
/*MLL*/
    SIP7_MLL_ACTIVE_MEM_MAC,

    END_BIND_UNIT_ACTIVE_MEM_MAC(devObjPtr,unitPtr)

    {
        SMEM_CHUNK_BASIC_STC  chunksMem[]=
        {
             {SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00460000, 0x00460010)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00460020, 0x00460024)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00460030, 0x00460034)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00460040, 0x00460040)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00460050, 0x00460058)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00460060, 0x0046006C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00460080, 0x00460084)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00460100, 0x004601FC)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00460204, 0x00460208)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00460210, 0x00460224)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00460308, 0x00460370)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00460400, 0x00460404)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00460500, 0x0046058C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00460600, 0x00460628)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00460800, 0x00460814)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00460900, 0x00460900)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00460980, 0x00460984)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00460A00, 0x00460A00)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00460A80, 0x00460A84)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00460B04, 0x00460B04)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00460C00, 0x00460C00)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00460C80, 0x00460C84)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00460D00, 0x00460D00)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00460D80, 0x00460D84)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00460E00, 0x00460E08)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00460E20, 0x00460E28)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00460F20, 0x00460F5C)}
        };
        GT_U32  numOfChunks = sizeof(chunksMem)/sizeof(SMEM_CHUNK_BASIC_STC);

        smemInitMemChunk(devObjPtr,chunksMem,numOfChunks,unitPtr);
    }

    {
        SMEM_CHUNK_BASIC_STC  chunksMem[]=
        {
            /* support 98304 lines (96K) */
            {SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00400000, 393216) , SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(24, 4)   ,SMEM_BIND_TABLE_MAC(l2MllLtt)}
            /* support 32768 lines (32K), for IP/L2 MLL, the line holds 4 entries pairs */
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00000000, 4194304), SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(740, 128) , SMEM_BIND_TABLE_MAC(mllTable)}
        };
        GT_U32  numOfChunks = sizeof(chunksMem)/sizeof(SMEM_CHUNK_BASIC_STC);
        SMEM_UNIT_CHUNKS_STC    tmpUnitChunk;

        GT_U32  numMllPairs = devObjPtr->limitedResources.mllPairs;
        GT_U32  numL2MllLtt = devObjPtr->limitedResources.l2LttMll;
        /* support AAS */
        chunksMem[0].numOfRegisters = numL2MllLtt * (chunksMem[0].enrtyNumBytesAlignement / 4);

         /* each mll line hold 4 mll entries so need to devide the numMllPairs by 4 */
        chunksMem[1].numOfRegisters = numMllPairs/4 * (chunksMem[1].enrtyNumBytesAlignement / 4);

        smemInitMemChunk(devObjPtr,chunksMem, numOfChunks, &tmpUnitChunk);

        /*add the tmp unit chunks to the main unit */
        smemInitMemCombineUnitChunks(devObjPtr,unitPtr,&tmpUnitChunk);
    }

    {
        static SMEM_REGISTER_DEFAULT_VALUE_STC myUnit_registersDefaultValueArr[] =
        {
             {DUMMY_NAME_PTR_CNS,            0x00460000,         0x05200700,      1,    0x0}
            ,{DUMMY_NAME_PTR_CNS,            0x00460004,         0x00ffffff,      1,    0x0}
            ,{DUMMY_NAME_PTR_CNS,            0x00460008,         0x00000003,      1,    0x0}
            ,{DUMMY_NAME_PTR_CNS,            0x0046000c,         0x00008fff,      1,    0x0}
            ,{DUMMY_NAME_PTR_CNS,            0x00460040,         0x0000203c,      1,    0x0}
            ,{DUMMY_NAME_PTR_CNS,            0x00460050,         0x0000ffff,      1,    0x0}
            ,{DUMMY_NAME_PTR_CNS,            0x00460054,         0x00000001,      1,    0x0}
            ,{DUMMY_NAME_PTR_CNS,            0x00460060,         0x00000fff,      1,    0x0}
            ,{DUMMY_NAME_PTR_CNS,            0x00460068,         0x0001ffff,      2,    0x4,      2,    0x2a8}
            ,{DUMMY_NAME_PTR_CNS,            0x00460204,         0x08040201,      1,    0x0}
            ,{DUMMY_NAME_PTR_CNS,            0x00460210,         0x20000000,      1,    0x0}
            ,{DUMMY_NAME_PTR_CNS,            0x00460214,         0x01636300,      1,    0x0}
            ,{DUMMY_NAME_PTR_CNS,            0x00460218,         0x00000101,      1,    0x0}
            ,{DUMMY_NAME_PTR_CNS,            0x0046021c,         0x00000600,      2,    0x4}
            ,{DUMMY_NAME_PTR_CNS,            0x0046050c,         0x0000003f,      5,    0x10}

            ,{NULL,                          0x00000000,         0x00000000,      0,    0x0}

        };
        static SMEM_LINK_LIST_REGISTER_DEFAULT_VALUE_STC list = {myUnit_registersDefaultValueArr,NULL};


        unitPtr->unitDefaultRegistersPtr = &list;
    }

    /* new registers in sip7 */
    {/*multiTargetVPortMap*/
        GT_U32  ii,jj;

        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->MLL.multiTargetVPortMap.multiTargetVportRangeBase  = 0x00460318;
        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->MLL.multiTargetVPortMap.multiTargetVportRangeSize  = 0x0046031c;
        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->MLL.multiTargetVPortMap.multiTargetVportRangeEVidx = 0x00460320;
        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->MLL.multiTargetVPortMap.multiTargetVportIngressDevice=0x00460624;
        for(ii = 0 ; ii < 4 ; ii++)
        {
            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->MLL.multiTargetVPortMap.subRangeArr[ii].multiTargetVPortSubRangeSize =
                0x00460324 + ii*0x4;
            for(jj = 0 ; jj < 4 ; jj++)
            {
                SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->MLL.multiTargetVPortMap.subRangeArr[ii].backupChunks[jj].backupCfgValue =
                    0x00460334 + ii*0x10 + jj*0x4;
                SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->MLL.multiTargetVPortMap.subRangeArr[ii].backupChunks[jj].backupCfgMask =
                    0x00460F20 + ii*0x10 + jj*0x4;
            }
        }
    }/*multiTargetVPortMap*/

}


/**
* @internal smemAasUnitEq function
* @endinternal
*
* @brief   Allocate address type specific memories -- for the Eq unit
*
* @param[in] devObjPtr                - pointer to device object.
* @param[in,out] unitPtr                  - pointer to the unit chunk
*/
static void smemAasUnitEq
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    INOUT SMEM_UNIT_CHUNKS_STC  * unitPtr
)
{
    {
        START_BIND_UNIT_ACTIVE_MEM_MAC(devObjPtr,unitPtr)

        /* EQ active memories without STC interrupts */
        ACTIVE_MEM_EQ_WITHOUT_INT_STC_INT_COMMON_MAC,

        END_BIND_UNIT_ACTIVE_MEM_MAC(devObjPtr,unitPtr)
    }

    {
        SMEM_CHUNK_BASIC_STC  chunksMem[]=
        {
             {SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000020, 0x00000024)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x0000003C, 0x00000040)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000058, 0x0000008C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000000A0, 0x000000A4)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000000B0, 0x000000B4)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000110, 0x0000011C)}

            /*dummy from not in cider ??? */
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000518, 0x00000524)}

            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000700, 0x00000710)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000720, 0x0000072c)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000734, 0x00000744)}

            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00001000, 2048),SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(32, 4),SMEM_BIND_TABLE_MAC(oamProtectionLocStatusTable)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00002000, 2048),SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(32, 4),SMEM_BIND_TABLE_MAC(oamTxProtectionLocStatusTable)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00005000, 0x00005000)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00005014, 0x0000505C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00005100, 0x0000513C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00005200, 0x00005200)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00005400, 0x0000543C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00005500, 32),SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(39, 8),SMEM_BIND_TABLE_MAC(eqQueueGroupProfile)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00005524, 0x00005530)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00005544, 0x00005558)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00006000, 0x0000600C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00007000, 0x0000703C),SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(32, 4),SMEM_BIND_TABLE_MAC(tcpUdpDstPortRangeCpuCode)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00007800, 0x0000783C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00007C00, 0x00007C10),SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(32, 4),SMEM_BIND_TABLE_MAC(ipProtCpuCode)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00008400, 0x00008BFC)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00008C00, 1024)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00009000, 1024)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00009504, 0x00009504)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x0000950C, 0x00009560)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x0000A000, 0x0000A008)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x0000A010, 0x0000A010)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x0000A020, 0x0000A034)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x0000A100, 0x0000A17C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x0000AF00, 0x0000AF08)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x0000AF10, 0x0000AF10)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x0000AF30, 0x0000AF34)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x0000B000, 0x0000B000)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x0000B008, 0x0000B208)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x0000B210, 0x0000B40C)}
            /*vPort/phy port map for q table*/
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x0000C000, 4096)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x0000D000, 0x0000D004)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x0000D010, 0x0000D014)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x0000E400, 1024)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00010000, 0x00010004)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00010020, 0x00010024)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00010030, 0x00010034)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00010040, 0x00010044)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00010050, 0x00010054)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00010060, 0x00010064)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00010070, 0x00010074)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00010080, 0x00010084)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00010090, 0x00010094)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000100A0, 0x000100A4)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000100B0, 0x000100B4)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000100C0, 0x000100C4)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000100D0, 0x000100D4)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000100E0, 0x000100E4)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000100F0, 0x000100F4)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00010100, 0x00010104)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00010110, 0x00010114)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x0002000C, 0x00020010)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00022000, 2048),SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(96, 16),SMEM_BIND_TABLE_MAC(eqPhysicalPortIngressMirrorIndexTable)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00080000, 0x000803F8)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x000A0000, 1024) , SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(32, 4)  ,SMEM_BIND_TABLE_MAC(statisticalRateLimit)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x000A0400, 1024) , SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(32, 4)  ,SMEM_BIND_TABLE_MAC(cpuCode)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x000A1000, 4096) , SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(16, 4)  ,SMEM_BIND_TABLE_MAC(sourcePortHash)} /*Source_Port_Hash_Table*/
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x000A2000, 4096) , SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(14, 4)  ,SMEM_BIND_TABLE_MAC(qosProfile)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x000A3000, 2048) , SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(32, 4)  ,SMEM_BIND_TABLE_MAC(txProtectionSwitchingTable)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x000A4000, 16384), SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(144, 32),SMEM_BIND_TABLE_MAC(pathUtilization0)} /*Path_Utilization_Table_0*/
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x000A8000, 16384), SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(144, 32),SMEM_BIND_TABLE_MAC(pathUtilization1)} /*Path_Utilization_Table_1*/
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x000AC000, 16384), SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(144, 32),SMEM_BIND_TABLE_MAC(pathUtilization2)} /*Path_Utilization_Table_2*/
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x000B0000, 16384), SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(144, 32),SMEM_BIND_TABLE_MAC(pathUtilization3)} /*Path_Utilization_Table_3*/
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x000C0000, 8192) , SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(34, 8)  ,SMEM_BIND_TABLE_MAC(eqTrunkLtt)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x000D0000, 32768), SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(28, 4)  ,SMEM_BIND_TABLE_MAC(ePortToLocMappingTable)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x000E0000, (NUM_EPORTS/4)*8), SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(40, 8)  ,SMEM_BIND_TABLE_MAC(eqIngressEPort)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x000F0000, NUM_TRUNKS_ECMP*4),SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(25, 4),SMEM_BIND_TABLE_MAC(eqTrunkEcmp)}/* new in sip7 s*/
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00140000, 131072),SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(34, 8),SMEM_BIND_TABLE_MAC(eqL2EcmpLtt)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00180000, 131072),SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(25, 4),SMEM_BIND_TABLE_MAC(eqL2Ecmp)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00200000, 131072)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00300000, 524288) ,SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(32, 4),SMEM_BIND_TABLE_MAC(eqHEcmpStatusVector)}SIM_TBD_BOOKMARK/*not in Cider yet*/
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00400000, NUM_VPORTS*8),SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(57, 8),SMEM_BIND_TABLE_MAC(eqVPortMapping)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00600000, NUM_HECMP_LTT*8),SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(35, 8),SMEM_BIND_TABLE_MAC(eqHEcmpLttTable)} SIM_TBD_BOOKMARK/*not in Cider yet*/
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00700000, 0x100000),SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(131, 32),SMEM_BIND_TABLE_MAC(eqHEcmpEcmpTable)} SIM_TBD_BOOKMARK/*not in Cider yet*/

            /*hecmp stg1 ltt table*/
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00800000, 2097144)}
            /*hecmp stg1 ecmp table*/
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00A00000, 2097136)}
            /*hecmp stg1 fast reroute status table*/
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x01280000, 4096)}
            /*E2PHY Table*/
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x01400000, 1048576),SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(44, 8),SMEM_BIND_TABLE_MAC(eqE2Phy)}

        };
        GT_U32  numOfChunks = sizeof(chunksMem)/sizeof(SMEM_CHUNK_BASIC_STC);

        smemInitMemChunk(devObjPtr,chunksMem,numOfChunks,unitPtr);
    }

    {
        static SMEM_REGISTER_DEFAULT_VALUE_STC myUnit_registersDefaultValueArr[]  =
        {

             {DUMMY_NAME_PTR_CNS,   0x00000074,    0x0000003f,      1,    0x4 }
            ,{DUMMY_NAME_PTR_CNS,   0x00000740,    0x00000400,      1,    0x4 }
            ,{DUMMY_NAME_PTR_CNS,   0x00005014,    0x00002200,      1,    0x4 }
            ,{DUMMY_NAME_PTR_CNS,   0x00005020,    0x00000020,      1,    0x4 }
            ,{DUMMY_NAME_PTR_CNS,   0x00005024,    0xffffffff,      1,    0x4 }
            ,{DUMMY_NAME_PTR_CNS,   0x00005028,    0x000001e0,      1,    0x4 }
            ,{DUMMY_NAME_PTR_CNS,   0x0000502c,    0x0001ffff,      4,    0x4 }
            ,{DUMMY_NAME_PTR_CNS,   0x0000503c,    0x00002190,      1,    0x4 }
            ,{DUMMY_NAME_PTR_CNS,   0x00005044,    0x0007ffff,      1,    0x4 }
            ,{DUMMY_NAME_PTR_CNS,   0x00005050,    0x00000002,      1,    0x4 }
            ,{DUMMY_NAME_PTR_CNS,   0x00005058,    0x0000003f,      1,    0x4 }
            ,{DUMMY_NAME_PTR_CNS,   0x00005100,    0x000001e0,     16,    0x4 }
            ,{DUMMY_NAME_PTR_CNS,   0x00005400,    0x000001e0,     16,    0x4 }
            ,{DUMMY_NAME_PTR_CNS,   0x00005524,    0x00000020,      2,    0x4 }
            ,{DUMMY_NAME_PTR_CNS,   0x0000552c,    0xffffffff,      2,    0x4 }
            ,{DUMMY_NAME_PTR_CNS,   0x0000554c,    0x00002200,      2,    0x4 }
            ,{DUMMY_NAME_PTR_CNS,   0x00005554,    0x000001e0,      2,    0x4 }
            ,{DUMMY_NAME_PTR_CNS,   0x00006008,    0x00000002,      1,    0x4 }
            ,{DUMMY_NAME_PTR_CNS,   0x00008800,    0x0000ffff,    256,    0x4 }
            ,{DUMMY_NAME_PTR_CNS,   0x00009504,    0x00004400,      1,    0x4 }
            ,{DUMMY_NAME_PTR_CNS,   0x0000950c,    0x00000020,      1,    0x4 }
            ,{DUMMY_NAME_PTR_CNS,   0x00009510,    0xffffffff,      1,    0x4 }
            ,{DUMMY_NAME_PTR_CNS,   0x00009514,    0x000001e0,      1,    0x4 }
            ,{DUMMY_NAME_PTR_CNS,   0x00009518,    0x0001ffff,      3,    0x4 }
            ,{DUMMY_NAME_PTR_CNS,   0x00009524,    0x000001e0,     16,    0x4 }
            ,{DUMMY_NAME_PTR_CNS,   0x0000a000,    0x3ef084e2,      1,    0x4 }
            ,{DUMMY_NAME_PTR_CNS,   0x0000a004,    0x000001f2,      1,    0x4 }
            ,{DUMMY_NAME_PTR_CNS,   0x0000a010,    0x00000160,      1,    0x4 }
            ,{DUMMY_NAME_PTR_CNS,   0x0000a020,    0x000007e0,      1,    0x4 }
            ,{DUMMY_NAME_PTR_CNS,   0x0000a100,    0xffffffff,      1,    0x4 }
            ,{DUMMY_NAME_PTR_CNS,   0x0000af00,    0x1084211f,      1,    0x4 }
            ,{DUMMY_NAME_PTR_CNS,   0x0000af04,    0x00004201,      1,    0x4 }
            ,{DUMMY_NAME_PTR_CNS,   0x0000af08,    0x00000011,      1,    0x4 }
            ,{DUMMY_NAME_PTR_CNS,   0x0000af10,    0x0000421f,      1,    0x4 }
            ,{DUMMY_NAME_PTR_CNS,   0x0000af30,    0x0000ffff,      1,    0x4 }
            ,{DUMMY_NAME_PTR_CNS,   0x0000af34,    0x00000ec0,      1,    0x4 }
            ,{DUMMY_NAME_PTR_CNS,   0x0000b000,    0x00138000,      1,    0x4 }
            ,{DUMMY_NAME_PTR_CNS,   0x0000b00c,    0x00000001,      NUM_ANALYZER_PORTS,    0x4 }
            ,{DUMMY_NAME_PTR_CNS,   0x0000b10c,    0x00000001,      NUM_ANALYZER_PORTS,    0x4 }
            ,{DUMMY_NAME_PTR_CNS,   0x0000b310,    0x02000000,      NUM_ANALYZER_PORTS,    0x4 }
            ,{DUMMY_NAME_PTR_CNS,   0x0000d000,    0x00000020,      1,    0x4 }
            ,{DUMMY_NAME_PTR_CNS,   0x0000d004,    0xffffffff,      1,    0x4 }
            ,{DUMMY_NAME_PTR_CNS,   0x0000d010,    0x000001e0,      2,    0x4 }
            ,{DUMMY_NAME_PTR_CNS,   0x00020010,    0x0000003f,      1,    0x4 }
            ,{DUMMY_NAME_PTR_CNS,   0x00080000,    0x0000ffff,    255,    0x4 }

            /*Statistical Rate Limits Table*/
            ,{DUMMY_NAME_PTR_CNS,         0x000A0000,         0xffffffff,    256,    0x4  }
            /*TO CPU Rate Limiter Configuration*/
            ,{DUMMY_NAME_PTR_CNS,         0x0000E400,         0x0fffffff,    256,    0x4  }

            ,{NULL,            0,         0x00000000,      0,    0x0      }
        };
        static SMEM_LINK_LIST_REGISTER_DEFAULT_VALUE_STC list = {myUnit_registersDefaultValueArr,NULL};
        unitPtr->unitDefaultRegistersPtr = &list;
    }

    {
        GT_U32  n;

        /* sip7 : vport */
        {
            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->EQ.vport.q_assignment        = 0x00005200;
            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->EQ.vport.vPort_global_config = 0x00000700;
        }

        /* sip7 : GCF (generic classification field) */
        {
            for(n = 0 ; n < 3 ; n++)
            {
                SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->EQ.GCF.stagePathInfo[n] =
                    0x00000704 + 4*n;
            }
        }


        /* sip7 : E2PHY */
        {

            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->EQ.E2PHY.Circuits_base_address_in_E2PHY = 0x00000740;
            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->EQ.E2PHY.Hierarchical_ECMP_out_of_sync  = 0x00000744;

        }

    }

}


#define IPE_SEAHAWK_PPG_PPN_OFFSET 0x02800000

#define IPE_SEAHAWK_PPG_OFFSET 0x80000
#define IPE_SEAHAWK_PPN_OFFSET  0x4000
#define IPE_SEAHAWK_PPN_NUM     4
#define IPE_SEAHAWK_PPG_NUM     12


#define IPE_SEAHAWK_PPN_REPLICATIONS IPE_SEAHAWK_PPN_NUM,IPE_SEAHAWK_PPG_OFFSET , IPE_SEAHAWK_PPG_NUM,IPE_SEAHAWK_PPN_OFFSET
#define IPE_SEAHAWK_PPN_REPLICATIONS_FORMULA_TWO_PARAMETERS FORMULA_TWO_PARAMETERS(IPE_SEAHAWK_PPN_NUM,IPE_SEAHAWK_PPG_OFFSET , IPE_SEAHAWK_PPG_NUM,IPE_SEAHAWK_PPN_OFFSET)
#define IPE_SEAHAWK_PPG_REPLICATIONS_FORMULA_SINGLE_PARAMETER FORMULA_SINGLE_PARAMETER(IPE_SEAHAWK_PPN_NUM,IPE_SEAHAWK_PPG_OFFSET)

#define IPE_SEAHAWK_PPG_REPLICATION_ADDR(ppg)   \
    (IPE_SEAHAWK_PPG_OFFSET * (ppg))

#define IPE_SEAHAWK_PPN_REPLICATION_ADDR(ppg,ppn)   \
    (IPE_SEAHAWK_PPG_REPLICATION_ADDR(ppg) + (IPE_SEAHAWK_PPN_OFFSET * (ppn)))

#define IPE_SEAHAWK_PPN_REPLICATIONS_ACTIVE_MEM(ppg,ppn) \
    /*PPN Internal Error Cause Register*/         \
    {0x00003040 + IPE_SEAHAWK_PPN_REPLICATION_ADDR(ppg,ppn), SMEM_FULL_MASK_CNS, smemChtActiveReadIntrCauseReg, 0, smemChtActiveWriteIntrCauseReg, 0}, \
    {0x00003044 + IPE_SEAHAWK_PPN_REPLICATION_ADDR(ppg,ppn), SMEM_FULL_MASK_CNS, NULL, 0, smemChtActiveGenericWriteInterruptsMaskReg, 0}

#define IPE_SEAHAWK_PPG_REPLICATIONS_ACTIVE_MEM(ppg) \
    /*PPG Interrupt Cause Register*/     \
    {0x0007FF00 + IPE_SEAHAWK_PPG_REPLICATION_ADDR(ppg), SMEM_FULL_MASK_CNS, smemChtActiveReadIntrCauseReg, 0, smemChtActiveWriteIntrCauseReg, 0}, \
    {0x0007FF04 + IPE_SEAHAWK_PPG_REPLICATION_ADDR(ppg), SMEM_FULL_MASK_CNS, NULL, 0, smemChtActiveGenericWriteInterruptsMaskReg, 0},              \
    /*PPG internal error cause Register*/                                                                                              \
    {0x0007FF10 + IPE_SEAHAWK_PPG_REPLICATION_ADDR(ppg), SMEM_FULL_MASK_CNS, smemChtActiveReadIntrCauseReg, 0, smemChtActiveWriteIntrCauseReg, 0}, \
    {0x0007FF14 + IPE_SEAHAWK_PPG_REPLICATION_ADDR(ppg), SMEM_FULL_MASK_CNS, NULL, 0, smemChtActiveGenericWriteInterruptsMaskReg, 0},              \
                                        \
    IPE_SEAHAWK_PPN_REPLICATIONS_ACTIVE_MEM(ppg,0), \
    IPE_SEAHAWK_PPN_REPLICATIONS_ACTIVE_MEM(ppg,1), \
    IPE_SEAHAWK_PPN_REPLICATIONS_ACTIVE_MEM(ppg,2), \
    IPE_SEAHAWK_PPN_REPLICATIONS_ACTIVE_MEM(ppg,3), \
    IPE_SEAHAWK_PPN_REPLICATIONS_ACTIVE_MEM(ppg,4), \
    IPE_SEAHAWK_PPN_REPLICATIONS_ACTIVE_MEM(ppg,5), \
    IPE_SEAHAWK_PPN_REPLICATIONS_ACTIVE_MEM(ppg,6), \
    IPE_SEAHAWK_PPN_REPLICATIONS_ACTIVE_MEM(ppg,7), \
    IPE_SEAHAWK_PPN_REPLICATIONS_ACTIVE_MEM(ppg,8), \
    IPE_SEAHAWK_PPN_REPLICATIONS_ACTIVE_MEM(ppg,9), \
    IPE_SEAHAWK_PPN_REPLICATIONS_ACTIVE_MEM(ppg,10), \
    IPE_SEAHAWK_PPN_REPLICATIONS_ACTIVE_MEM(ppg,11)


/**
* @internal smemAasUnitIpe function
* @endinternal
*
* @brief   Allocate address type specific memories -- for the
*          AASIpe unit
*/
static void smemAasUnitIpe
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    INOUT SMEM_UNIT_CHUNKS_STC  * unitPtr
)
{

    {
        START_BIND_UNIT_ACTIVE_MEM_MAC(devObjPtr,unitPtr)

        /*IPE Global Interrupt Cause Register*/
        {0x00001100 , SMEM_FULL_MASK_CNS, smemChtActiveReadIntrCauseReg, 0, smemChtActiveWriteIntrCauseReg, 0},
        {0x00001104 , SMEM_FULL_MASK_CNS, NULL, 0, smemChtActiveGenericWriteInterruptsMaskReg, 0},
        /*IPE Interrupt Sum Cause Register*/
        {0x00001108 , SMEM_FULL_MASK_CNS, smemChtActiveReadIntrCauseReg, 0, smemChtActiveWriteIntrCauseReg, 0},
        {0x0000110C , SMEM_FULL_MASK_CNS, NULL, 0, smemChtActiveGenericWriteInterruptsMaskReg, 0},

        END_BIND_UNIT_ACTIVE_MEM_MAC(devObjPtr,unitPtr)
    }

    /* IPE memory*/
    {
         SMEM_CHUNK_BASIC_STC  chunksMem[]=
         {
             {SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000000, 0x00000014)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000020, 0x0000041C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000500, 0x00000944)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000950, 0x00000970)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001000, 0x0000100C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001100, 0x0000110C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001200, 0x00001200)}
            /* IPE State Address Profile Table */
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00100000, 2048),SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(85, 16),SMEM_BIND_TABLE_MAC(ipeStateAddrProfile)}
            /* IPE ICT Table */
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00200000, 524288),SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(64, 8),SMEM_BIND_TABLE_MAC(ipeIctTable)}
             /* IPE State Data Command Profile Table */
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00110000, 8192),SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(408, 64),SMEM_BIND_TABLE_MAC(ipeStateDataCmdProfile)}
             /* IPE DPO profile table */
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC(0x00300000, 8192),SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(1040, 256),SMEM_BIND_TABLE_MAC(ipeDpoTable)}
             /* IPE DPI profile Table  */
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00400000, 65536),SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(1209, 256),SMEM_BIND_TABLE_MAC(ipeDpiTable)}
             /* IPE State T0 Table*/
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC(0x02000000, 16777216 ),SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(128, 16),SMEM_BIND_SHARED_TABLE_MAC(ipeStateT0Table)}
             /* IPE State T1 Table  */
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC(0x03000000, 16777216 ),SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(128, 16),SMEM_BIND_SHARED_TABLE_MAC(ipeStateT1Table)}
         };

         GT_U32  numOfChunks = sizeof(chunksMem)/sizeof(SMEM_CHUNK_BASIC_STC);
         smemInitMemChunk(devObjPtr,chunksMem, numOfChunks, unitPtr);
    }


    {
        START_BIND_UNIT_ACTIVE_MEM_MAC(devObjPtr,unitPtr)

        /*PPA Interrupt Cause Register*/
        {0x047EFF10 , SMEM_FULL_MASK_CNS, smemChtActiveReadIntrCauseReg, 0, smemChtActiveWriteIntrCauseReg, 0},
        {0x047EFF14 , SMEM_FULL_MASK_CNS, NULL, 0, smemChtActiveGenericWriteInterruptsMaskReg, 0},
        /*PPA internal error cause Register*/
        {0x047EFF20 , SMEM_FULL_MASK_CNS, smemChtActiveReadIntrCauseReg, 0, smemChtActiveWriteIntrCauseReg, 0},
        {0x047EFF24 , SMEM_FULL_MASK_CNS, NULL, 0, smemChtActiveGenericWriteInterruptsMaskReg, 0},

        /* 4 PPG (with 12 PPNs each) */
        IPE_SEAHAWK_PPG_REPLICATIONS_ACTIVE_MEM(0),/*include all it's PPN*/
        IPE_SEAHAWK_PPG_REPLICATIONS_ACTIVE_MEM(1),/*include all it's PPN*/
        IPE_SEAHAWK_PPG_REPLICATIONS_ACTIVE_MEM(2),/*include all it's PPN*/
        IPE_SEAHAWK_PPG_REPLICATIONS_ACTIVE_MEM(3),/*include all it's PPN*/

        END_BIND_UNIT_ACTIVE_MEM_MAC(devObjPtr,unitPtr)
    }
    /* IPE PPA memory */
    {
         SMEM_CHUNK_EXTENDED_STC chunksMem[]=
         {
            {{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC(0x02fC0000, 65536)}}
            ,{{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x02fEFF00, 0x02fEFF00)}}
            ,{{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x02fEFF10, 0x02fEFF14)}}
            ,{{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x02fEFF20, 0x02fEFF24)}}
            ,{{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x02fEFF30, 0x02fEFF30)}}
            ,{{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x02fEFF40, 0x02fEFF4C)}}
            ,{{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x02fEFF70, 0x02fEFF70)}}
            /* Per PPG */
            ,{{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x02840000, 16384), SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(128,16)}, IPE_SEAHAWK_PPG_REPLICATIONS_FORMULA_SINGLE_PARAMETER}  /*IMEM*/
            ,{{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x0287FF00, 0x0287FF04)}, IPE_SEAHAWK_PPG_REPLICATIONS_FORMULA_SINGLE_PARAMETER}
            ,{{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x0287FF10, 0x0287FF14)}, IPE_SEAHAWK_PPG_REPLICATIONS_FORMULA_SINGLE_PARAMETER}
            ,{{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x0287FF70, 0x0287FF70)}, IPE_SEAHAWK_PPG_REPLICATIONS_FORMULA_SINGLE_PARAMETER}

            /* per PPN */
            ,{{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x02800000, 4096)}      , IPE_SEAHAWK_PPN_REPLICATIONS_FORMULA_TWO_PARAMETERS}  /*scratchpad*/
            ,{{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x02802000, 8)}         , IPE_SEAHAWK_PPN_REPLICATIONS_FORMULA_TWO_PARAMETERS}  /*packet configuration*/
            ,{{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x02802060, 4)}         , IPE_SEAHAWK_PPN_REPLICATIONS_FORMULA_TWO_PARAMETERS}  /*packet special registers*/
            ,{{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x02802100, 64)}        , IPE_SEAHAWK_PPN_REPLICATIONS_FORMULA_TWO_PARAMETERS}  /*packet descriptor*/
            ,{{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x02802200, 132)}       , IPE_SEAHAWK_PPN_REPLICATIONS_FORMULA_TWO_PARAMETERS}  /*packet header*/
            ,{{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x02803000, 0x02803008)} , IPE_SEAHAWK_PPN_REPLICATIONS_FORMULA_TWO_PARAMETERS}
            ,{{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x02803010, 0x02803010)} , IPE_SEAHAWK_PPN_REPLICATIONS_FORMULA_TWO_PARAMETERS}
            ,{{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x02803020, 0x02803024)} , IPE_SEAHAWK_PPN_REPLICATIONS_FORMULA_TWO_PARAMETERS}
            ,{{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x02803040, 0x02803044)} , IPE_SEAHAWK_PPN_REPLICATIONS_FORMULA_TWO_PARAMETERS}
            ,{{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x02803050, 0x02803058)} , IPE_SEAHAWK_PPN_REPLICATIONS_FORMULA_TWO_PARAMETERS}
            ,{{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x02803060, 0x02803068)} , IPE_SEAHAWK_PPN_REPLICATIONS_FORMULA_TWO_PARAMETERS}
            ,{{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x02803070, 0x02803084)} , IPE_SEAHAWK_PPN_REPLICATIONS_FORMULA_TWO_PARAMETERS}
         };
         SMEM_UNIT_CHUNKS_STC    tmpUnitChunk;
         GT_U32  numOfChunks = sizeof(chunksMem)/sizeof(SMEM_CHUNK_EXTENDED_STC);
         smemInitMemChunkExt(devObjPtr,chunksMem, numOfChunks, &tmpUnitChunk);
         /*add the tmp unit chunks to the main unit */
         smemInitMemCombineUnitChunks(devObjPtr,unitPtr,&tmpUnitChunk);

    }

    {

        static SMEM_REGISTER_DEFAULT_VALUE_STC myUnit_registersDefaultValueArr[] =
        {
            /* IPE */
             {DUMMY_NAME_PTR_CNS,            0x00000000,         0x0000002b,      1,    0x0          }
            ,{DUMMY_NAME_PTR_CNS,            0x00000010,         0x0000003f,      1,    0x0          }
            ,{DUMMY_NAME_PTR_CNS,            0x00000014,         0x0000001f,      1,    0x0          }
            ,{DUMMY_NAME_PTR_CNS,            0x00000950,         0x00000074,      1,    0x0          }
            ,{DUMMY_NAME_PTR_CNS,            0x00001200,         0xffff0000,      1,    0x0          }
            /* PPA */
            ,{DUMMY_NAME_PTR_CNS,            0x02feff00,         0x00000001,      1,    0x0          }
            ,{DUMMY_NAME_PTR_CNS,            0x02feff00,         0xffff0000,      1,    0x0          }
            /* per PPN */
            ,{DUMMY_NAME_PTR_CNS,            0x02803000,         0x00000001,      IPE_SEAHAWK_PPN_REPLICATIONS   }

            ,{NULL,            0,            0x00000000,         0,    0x0      }
        };
        static SMEM_LINK_LIST_REGISTER_DEFAULT_VALUE_STC list = {myUnit_registersDefaultValueArr,NULL};
        unitPtr->unitDefaultRegistersPtr = &list;

    }

    {/*start of unit IPE*/
        GT_U32 n,ppg,ppn,ppgOffset,ppnOffset,totalOffset;
        {/*start of unit IPE_Configurations*/
            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->IPE.IPE_Configurations.ipeGlobalConfigurations = 0x00000000;
            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->IPE.IPE_Configurations.ipeThreadIdExtract = 0x00000004;
            {/*0x00020+0x4*n*/
                for(n=0; n<=255; n=n+1) {
                    SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->IPE.IPE_Configurations.ipePpuProfileN[n] = 0x00020+0x4*n;
                }/* end of loop n */
            }/*0x00020+0x4*n*/
            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->IPE.IPE_Configurations.ipeRandomNumberGeneratorSeedMsbs = 0x0000000C;
            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->IPE.IPE_Configurations.ipeRandomNumberGeneratorSeedLsbs = 0x00000008;
            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->IPE.IPE_Configurations.ipeBypassFifoConfigurations = 0x00000010;
            {/*0x00500+n*0x8*/
                for(n=0; n<=127; n=n+1) {
                    SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->IPE.IPE_Configurations.ictProfileLsbsN[n] = 0x00500+n*0x8;
                }/* end of loop n */
            }/*0x00500+n*0x8*/
            {/*0x00504+n*0x8*/
                for(n=0; n<=127; n=n+1) {
                    SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->IPE.IPE_Configurations.ictProfileMsbsN[n] = 0x00504+n*0x8;
                }/* end of loop n */
            }/*0x00504+n*0x8*/
            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->IPE.IPE_Configurations.ipeHashSeed = 0x00000900;
            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->IPE.IPE_Configurations.ipeHashKeyMaskLsbs = 0x00000904;
            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->IPE.IPE_Configurations.ipeHashKeyMaskMsbs = 0x00000908;
            {/*0x0090C+n*0x4*/
                for(n=0; n<=14; n=n+1) {
                    SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->IPE.IPE_Configurations.ipeHashSaltN[n] = 0x0090C+n*0x4;
                }/* end of loop n */
            }/*0x0090C+n*0x4*/
            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->IPE.IPE_Configurations.tcamLookupLatencyFifoConfigurations = 0x00000014;
            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->IPE.IPE_Configurations.ipeGdmaPdiBufferThresholds = 0x00000950;
            {/*0x00954+4*n*/
                for(n=0; n<=7; n=n+1) {
                    SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->IPE.IPE_Configurations.tcamLookupSuperkeyReductionTableN[n] = 0x00954+4*n;
                }/* end of loop n */
            }/*0x00954+4*n*/
        }/*end of unit IPE_Configurations*/

        {/*start of unit IPE_status*/
            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->IPE.IPE_status.ipeIllegalAddress = 0x00001000;
            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->IPE.IPE_status.ipeBypassBufferStatus = 0x00001004;
            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->IPE.IPE_status.ipeIdleState = 0x0000100C;
            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->IPE.IPE_status.tcamLookupLatencyFifoStatus = 0x00001008;
        }/*end of unit IPE_status*/

        {/*start of unit IPE_Interrupts*/
            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->IPE.IPE_Interrupts.ipeGlobalInterruptMask = 0x00001104;
            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->IPE.IPE_Interrupts.ipeGlobalInterruptCause = 0x00001100;
            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->IPE.IPE_Interrupts.ipeInterruptSumCause = 0x00001108;
            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->IPE.IPE_Interrupts.ipeInterruptSumMask = 0x0000110C;
        }/*end of unit IPE_Interrupts*/

        {/*start of unit IPE_Misc*/
            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->IPE.IPE_Misc.ipeMetalFix = 0x00001200;
        }/*end of unit IPE_Misc*/

        {/*start of unit PPA*/
            {/*start of unit ppa_regs*/
                SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->IPE.PPA.ppa_regs.ppaControl = 0x02fEFF00;
                SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->IPE.PPA.ppa_regs.ppaInterruptSumCause = 0x02fEFF10;
                SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->IPE.PPA.ppa_regs.ppaInterruptSumMask = 0x02fEFF14;
                SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->IPE.PPA.ppa_regs.ppaInternalErrorCause = 0x02fEFF20;
                SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->IPE.PPA.ppa_regs.ppaInternalErrorMask = 0x02fEFF24;
                SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->IPE.PPA.ppa_regs.ppaDebugBus = 0x02fEFF30;
                SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->IPE.PPA.ppa_regs.profilingImemStallCounter = 0x02fEFF44;
                SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->IPE.PPA.ppa_regs.ppaMetalFix = 0x02fEFF30;
                SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->IPE.PPA.ppa_regs.profilingSharedDmemStallCounter = 0x02fEFF48;
                SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->IPE.PPA.ppa_regs.profilingTotalPpnExecutionCyclesCounter = 0x02fEFF4C;
                SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->IPE.PPA.ppa_regs.ppaBadAddressLatch = 0x02fEFF70;
            }/*end of unit ppa_regs*/
        }/*end of unit PPA*/

        /*m * 0x80000: where m (0-3) represents PPG*/
        for(ppg = 0 ; ppg < 4; ppg++) /* per PPG */
        {
            ppgOffset = ppg * 0x80000;

            {/*start of unit ppg_regs */
                SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->IPE.PPG[ppg].ppg_regs.PPGInterruptSumCause = 0x0287FF00 + ppgOffset;
                SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->IPE.PPG[ppg].ppg_regs.PPGInterruptSumMask = 0x0287FF04 + ppgOffset;
                SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->IPE.PPG[ppg].ppg_regs.PPGInternalErrorCause = 0x0287FF10 + ppgOffset;
                SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->IPE.PPG[ppg].ppg_regs.PPGInternalErrorMask = 0x0287FF14 + ppgOffset;
                SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->IPE.PPG[ppg].ppg_regs.PPGBadAddrLatch = 0x0287FF70 + ppgOffset;
            }/*end of unit ppg_regs */

            /* 0x4000 * p: where p (0-11) represents PPN*/
            for(ppn = 0 ; ppn < 12; ppn++) /* per PPN (PER PPG) */
            {/*start of unit ppn_regs */
                ppnOffset = ppn * 0x4000 ;
                totalOffset = ppgOffset + ppnOffset;
                SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->IPE.PPG[ppg].PPN[ppn].ppn_regs.todTWord0 = 0x02803050 + totalOffset;
                SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->IPE.PPG[ppg].PPN[ppn].ppn_regs.todTWord1 = 0x02803054 + totalOffset;
                SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->IPE.PPG[ppg].PPN[ppn].ppn_regs.todTWord2 = 0x02803058 + totalOffset;

                SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->IPE.PPG[ppg].PPN[ppn].ppn_regs.ppnDoorbell  = 0x02803010 + totalOffset;
                SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->IPE.PPG[ppg].PPN[ppn].ppn_regs.packetHeaderAccessOffset = 0x02803024 + totalOffset;
                SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->IPE.PPG[ppg].PPN[ppn].ppn_regs.ppnInternalErrorCause = 0x02803040 + totalOffset;
                SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->IPE.PPG[ppg].PPN[ppn].ppn_regs.ppnInternalErrorMask = 0x02803044 + totalOffset;
                SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->IPE.PPG[ppg].PPN[ppn].ppn_regs.ppnBadAddressLatch = 0x02803070 + totalOffset;

            }/*end of unit ppn_regs */
        }

    }/*end of unit IPE*/

}

/**
* @internal smemAasUnitPpuForIpe function
* @endinternal
*
*@brief   Allocate address type specific memories -- for the AAS PPU for Ipe unit  */
static void smemAasUnitPpuForIpe
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    INOUT SMEM_UNIT_CHUNKS_STC  * unitPtr
)
{
    {
        SMEM_CHUNK_BASIC_STC  chunksMem[]=
        {

            {SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000000, 0x0000005C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000070, 0x0000007C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000090, 0x000000CC)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000000E0, 0x000000FC)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000100, 0x000002BC)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000300, 0x000004BC)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000500, 0x000006BC)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000700, 0x000008BC)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000F60, 0x00000F7C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000F90, 0x00000F9C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001000, 0x000011F4)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001200, 0x000013F4)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001400, 0x000015F4)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001600, 0x000017F4)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001A00, 0x00001AF8)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001B00, 0x00001BF8)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001C00, 0x00001CF8)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001D00, 0x00001DF8)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00002000, 0x000021F4)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00002200, 0x000023F4)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00002400, 0x000025F4)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00002600, 0x000027F4)}

            /* PPU Action Table 0 */
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC(0x00003000, 1024), SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(379, 64),SMEM_BIND_TABLE_MAC(ppuForIpeActionTable0)}
            /* PPU Action Table 1 */
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC(0x00005000, 1024), SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(379, 64),SMEM_BIND_TABLE_MAC(ppuForIpeActionTable1)}
            /* PPU Action Table 2 */
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC(0x00007000, 1024), SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(379, 64),SMEM_BIND_TABLE_MAC(ppuForIpeActionTable2)}
            /* PPU Action Table 3 */
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC(0x00009000, 1024), SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(379, 64),SMEM_BIND_TABLE_MAC(ppuForIpeActionTable3)}

        };

        GT_U32  numOfChunks = sizeof(chunksMem)/sizeof(SMEM_CHUNK_BASIC_STC);

        smemInitMemChunk(devObjPtr,chunksMem,numOfChunks,unitPtr);
    }

    {

        static SMEM_REGISTER_DEFAULT_VALUE_STC myUnit_registersDefaultValueArr[] =
        {
             {DUMMY_NAME_PTR_CNS,            0x00000000,         0x00000007,      1,    0x0          }
            ,{DUMMY_NAME_PTR_CNS,            0x00000F90,         0x0000FFFF,      1,    0x0          }
            ,{DUMMY_NAME_PTR_CNS,            0x00000F9C,         0x0026665A,      1,    0x0          }
            ,{NULL,            0,            0x00000000,         0,    0x0      }
        };
        static SMEM_LINK_LIST_REGISTER_DEFAULT_VALUE_STC list = {myUnit_registersDefaultValueArr,NULL};
        unitPtr->unitDefaultRegistersPtr = &list;

    }

    {/* start of unit ppu_regs */
        {/* start of unit generalRegs */
            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->PPU_FOR_IPE.generalRegs.ppuGlobalConfig = 0x00000000;
            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->PPU_FOR_IPE.generalRegs.ppuInterruptCause = 0x00000004;
            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->PPU_FOR_IPE.generalRegs.ppuInterruptMask = 0x00000008;
            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->PPU_FOR_IPE.generalRegs.ppuLastAddrViolation = 0x0000000C;
        }/* end of unit generalRegs */

        {/* start of unit debugRegs */
            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->PPU_FOR_IPE.debugRegs.ppuDebugCounterIn = 0x00000F60;
            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->PPU_FOR_IPE.debugRegs.ppuDebugCounterOut = 0x00000F64;
            {/* start of PPU_FOR_IPE debug counter k_stage<<%k>> */
                GT_U32 k;
                /*  0x00000F70 + 0x4*k: */
                for(k = 0; k < 4; k++)
                    SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->PPU_FOR_IPE.debugRegs.ppuDebugCounterKstg[k] = 0x00000F70 + 0x4 * k;
            }/*  PPU debug counter k_stage<<%k>> */
            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->PPU_FOR_IPE.debugRegs.ppuDebugCounterLoopback = 0x00000F6C;
            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->PPU_FOR_IPE.debugRegs.ppuMetalFixRegister = 0x00000F90;
            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->PPU_FOR_IPE.debugRegs.ppuIdleState = 0x00000F94;
            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->PPU_FOR_IPE.debugRegs.ppuDebug = 0x00000F98;
            SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->PPU_FOR_IPE.debugRegs.ppuThresholds = 0x00000F9C;
        }/* end of unit debugRegs */

        {/* start of SP BUS default profile %p word %w */
            GT_U32 w, p;

            /* 0x00000010 + 0x4*w + 0x14*p */
            for(p = 0; p < 4; p++)
                for(w = 0; w<5; w++)
                    SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->PPU_FOR_IPE.spBusDefaultProfile[p].word[w] = 0x00000010 + 0x4*w + 0x14*p;
        }/* end of SP BUS default profile %p word %w */

        {/* start of PPU_FOR_IPE error profile sp %p field %b */
            GT_U32 p,b;

            /* 0x000000B0 + 0x4*b + 0x10*p */
            for(p = 0; p < 2; p++)
                for(b = 0; b<4; b++)
                    SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->PPU_FOR_IPE.errProfileSp[p].field[b] = 0x000000B0 + 0x4*b + 0x10*p;
        }/* end of PPU_FOR_IPE error profile sp  %p field %b */

        {/* start of interrupt counters */
            GT_U32 i;

            /* 0x000000E0 + 0x4*i */
            for(i = 0; i < 8; i++)
                SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->PPU_FOR_IPE.interruptCounter[i] = 0x000000E0 + 0x4*i;
        }/* end of interrupt counters */

        {/* start of key gen Profile k_stage %k profile %i byte %b */
            GT_U32 k, i, b;

            /* 0x00000100 + 0x4*b+0x1c*i + 0x200*k */
            for(k = 0; k < 4; k++)
            {
                for(i = 0; i < 16; i++)
                    for(b = 0; b < 7; b++)
                        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->PPU_FOR_IPE.kstg[k].keyGenProfile[i].byte[b] = 0x00000100 + 0x4*b + 0x1c*i + 0x200*k;
            }

        }/* end of key gen Profile k_stage %k profile %i byte %b */

        {/* start of tcam regs */
            GT_U32 k, i;

            for(k = 0; k < 4; k++)
                for(i = 0; i < 15; i++)
                {
                    SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->PPU_FOR_IPE.kstg[k].tcamKey[i].keyLsb = 0x00001000 + 0x8*i + 0x200*k;
                    SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->PPU_FOR_IPE.kstg[k].tcamKey[i].keyMsb = 0x00001004 + 0x8*i + 0x200*k;
                    SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->PPU_FOR_IPE.kstg[k].tcamKey[i].maskLsb = 0x00002000 + 0x8*i + 0x200*k;
                    SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->PPU_FOR_IPE.kstg[k].tcamKey[i].maskMsb = 0x00002004 + 0x8*i + 0x200*k;
                    SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->PPU_FOR_IPE.kstg[k].tcamKey[i].validate = 0x00001A00 + 0x4*i + 0x100*k;
                }
        }/* end of tcam regs */

    }

}

/**
* @internal smemAasActiveWriteLmuStatClear function
* @endinternal
*
* @brief   redirect the write of LPM memory to do the wrtite from another table
*
* @param[in] devObjPtr      - device object PTR.
* @param[in] address        - Address for ASIC memory.
* @param[in] memSize        - size of the requested memory
* @param[in] memPtr         - Pointer to the register's memory in the simulation.
* @param[in] param          - Registers' specific parameter.
* @param[in] inMemPtr       - Pointer to the memory to get register's content
*                             with StatClear bit SET and read-check it is cleared
*                             after Clear operation has been really finished
*/
static void smemAasActiveWriteLmuStatClear
(
    IN         SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN         GT_U32                  address,
    IN         GT_U32                  memSize,
    IN         GT_U32                * memPtr,
    IN         GT_UINTPTR              param,
    INOUT      GT_U32                * inMemPtr
)
{
    DECLARE_FUNC_NAME(smemAasActiveWriteLpm);

    GT_U32  regAddr, profile, statIdx;

    regAddr = address;
    profile = *inMemPtr & ((1 << 9) - 1);

    __LOG(("Write register 0x%08x LMU stat clear for profile %u\n", address, *inMemPtr));
    if (profile != *inMemPtr)
    {
        __LOG(("ERROR: Write register 0x%08x LMU stat clear for WRONG profile %u > 511\n",
               address, *inMemPtr));
    }

    smemRegSet(devObjPtr, regAddr, profile);

    /* LMU-stat 32b + 64b + 30b + 30b + 30b =186b */
    regAddr = (address & ~0xFFFF) + (0x20 * profile);
    smemRegSet(devObjPtr, regAddr, 0);    /* packetsOutOfRange   0..31 */
    regAddr += 4;
    smemRegSet(devObjPtr, regAddr, 0);    /* packetsInRange-LSW 32..   */
    regAddr += 4;
    smemRegSet(devObjPtr, regAddr, 0);    /* packetsInRange-MSW   ..95 */
    regAddr += 4;
    smemRegSet(devObjPtr, regAddr, 0);    /* avrLatency + maxL 96..125;126,127 */
    regAddr += 4;
    smemRegSet(devObjPtr, regAddr, 0xF0000000); /* maxL+minL=28b+4b: 128..155; 156..159=0xF*/
    regAddr += 4;
    smemRegSet(devObjPtr, regAddr, 0x03FFFFFF); /* minL=26b:   160..185; 00000000 */

    /* Clear: "Profile Statistics Read" profileStatisticsReadData[1..6]
     * On real HW - data latched for the given profile
     */
    regAddr = (address & ~0xFFFF) + 0x00008030;
    for (statIdx = 0; statIdx < 6; statIdx++)
    {
        smemRegSet(devObjPtr, regAddr, profile);
        regAddr += 4;
    }
}

/**
* @internal smemAasUnitLmu function
* @endinternal
*
* @brief   Allocate address type specific memories -- for the LMU unit
*
* @param[in] devObjPtr                - pointer to device object.
* @param[in,out] unitPtr              - pointer to the unit chunk
*/
static void smemAasUnitLmu
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    INOUT SMEM_UNIT_CHUNKS_STC  * unitPtr
)
{
    /* Cloned from smemPhoenixUnitLmu for AAS new registers (stat clear) */
    START_BIND_UNIT_ACTIVE_MEM_MAC(devObjPtr,unitPtr)
        /* Read only latency statistics table */
        {0x00000000, 0xFFFFC000, smemHawkActiveReadLatencyProfileStatTable, 0, NULL, 0},
        /* Read Write configuration memory */
        {0x00004000, 0xFFFFE000, NULL, 0, NULL, 0},
        /* read write registers 8000, 8010, 8020, 8024, 8028(sip7 only) */
        {0x00008000, SMEM_FULL_MASK_CNS, NULL, 0, NULL, 0}, /* Channel Enable */
        {0x00008010, SMEM_FULL_MASK_CNS, NULL, 0, NULL, 0}, /* Decimator Select */
        {0x00008020, SMEM_FULL_MASK_CNS, NULL, 0, NULL, 0}, /* Average Coefficient */
        {0x00008024, SMEM_FULL_MASK_CNS, NULL, 0, NULL, 0}, /* metal fix */
        {0x00008028, SMEM_FULL_MASK_CNS, NULL, 0, smemAasActiveWriteLmuStatClear, 0},
        /* LMU Profile Statistics Read data 1-6 */
        {0x00008030, SMEM_FULL_MASK_CNS, NULL, 0, smemChtActiveWriteToReadOnlyReg, 0},
        {0x00008034, SMEM_FULL_MASK_CNS, NULL, 0, smemChtActiveWriteToReadOnlyReg, 0},
        {0x00008038, SMEM_FULL_MASK_CNS, NULL, 0, smemChtActiveWriteToReadOnlyReg, 0},
        {0x0000803C, SMEM_FULL_MASK_CNS, NULL, 0, smemChtActiveWriteToReadOnlyReg, 0},
        {0x00008040, SMEM_FULL_MASK_CNS, NULL, 0, smemChtActiveWriteToReadOnlyReg, 0},
        {0x00008044, SMEM_FULL_MASK_CNS, NULL, 0, smemChtActiveWriteToReadOnlyReg, 0},
        /* LMU lmu_latency_over_threshold_n_cause lmu/latency_over_threshold_n_mask */
        {0x00008100, 0x00FFFF80, smemChtActiveReadIntrCauseReg, 0, smemFalconActiveWriteLatencyOverThreshIntrCauseReg, 0},
        {0x00008180, 0x00FFFF80, NULL, 0, smemChtActiveGenericWriteInterruptsMaskReg,         0},

        /* LMU lmu_latency_fifo_full_n_cause/lmu_latency_fifo_full_n_mask */
        {0x00008200, SMEM_FULL_MASK_CNS, smemChtActiveReadIntrCauseReg, 0, smemFalconActiveWriteLatencyOverThreshIntrCauseReg, 0},
        {0x00008210, SMEM_FULL_MASK_CNS, NULL, 0, smemChtActiveGenericWriteInterruptsMaskReg,         0},

        /* LMU lmu_global_interrupt_cause/lmu_global_interrupt_mask */
        {0x00008220, SMEM_FULL_MASK_CNS, smemChtActiveReadIntrCauseReg, 0, smemFalconActiveWriteLatencyOverThreshIntrCauseReg, 0},
        {0x00008224, SMEM_FULL_MASK_CNS, NULL, 0, smemChtActiveGenericWriteInterruptsMaskReg,         0},

        /* LMU lmu_cause_summary/lmu_mask_summary*/
        {0x00008230, SMEM_FULL_MASK_CNS, NULL, 0, smemChtActiveWriteToReadOnlyReg,                    0},
        {0x00008234, SMEM_FULL_MASK_CNS, NULL, 0, smemChtActiveGenericWriteInterruptsMaskReg,         0},
        {0x00008238, SMEM_FULL_MASK_CNS, NULL, 0, smemChtActiveWriteToReadOnlyReg,         0},
    END_BIND_UNIT_ACTIVE_MEM_MAC(devObjPtr,unitPtr)

    /* chunks without formulas */
    {
        SMEM_CHUNK_BASIC_STC  chunksMem[]=
        {
            /* registers address space */
            {
               SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC(0x00000000, 16384),
               SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(186, 32),
               SMEM_BIND_TABLE_MAC(lmuStatTable)
            }
           ,{
               SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC(0x00004000, 8192),
               SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(90, 16),
               SMEM_BIND_TABLE_MAC(lmuCfgTable)
            }
            /*Configuration*/
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00008000, 0x00008000)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00008010, 0x00008010)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00008020, 0x00008024)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00008028, 0x00008028)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00008030, 0x00008044)}
            /*interrupts*/
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00008100, 0x00008140)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00008180, 0x000081C0)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00008200, 0x00008200)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00008210, 0x00008210)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00008220, 0x00008224)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00008230, 0x00008238)}
        };

        GT_U32  numOfChunks = sizeof(chunksMem)/sizeof(SMEM_CHUNK_BASIC_STC);

        smemInitMemChunk(devObjPtr, chunksMem, numOfChunks, unitPtr);
    }
    {
        static SMEM_REGISTER_DEFAULT_VALUE_STC myUnit_registersDefaultValueArr[] =
        {
             {DUMMY_NAME_PTR_CNS,            0x00008020,         0x00000005,    }
            ,{DUMMY_NAME_PTR_CNS,            0x00000010,         0xF0000000,    512,    0x00020}
            ,{DUMMY_NAME_PTR_CNS,            0x00000014,         0x03FFFFFF,    512,    0x00020}
            ,{DUMMY_NAME_PTR_CNS,            0x00004000,         0xFFFFFFFF,    512,    0x00010}
            ,{DUMMY_NAME_PTR_CNS,            0x00004004,         0x0FFFFFFF,    512,    0x00010}

            ,{NULL,            0,         0x00000000,      0,    0x0      }
        };
        static SMEM_LINK_LIST_REGISTER_DEFAULT_VALUE_STC list = {myUnit_registersDefaultValueArr,NULL};
        unitPtr->unitDefaultRegistersPtr = &list;
    }
}

/* need to cover 8K address space */
#define AAS_ACTIVE_READ_OAM_MASK_CNS   0xFFFFE000

#define ACTIVE_MEM_OAM_COMMON_SIP7_MAC(oamId)                                                        \
    /* OAM Unit Interrupt Cause */                                                                                 \
    {0x000000F0, SMEM_FULL_MASK_CNS, smemChtActiveReadIntrCauseReg, oamId, smemChtActiveWriteIntrCauseReg, oamId}, \
    /* OAM Unit Interrupt Mask */                                                                       \
    {0x000000F4, SMEM_FULL_MASK_CNS, NULL, oamId, smemChtActiveWriteMacInterruptsMaskReg, oamId},       \
    /* OAM Table Access Control */                                                                      \
    {0x000000D0, SMEM_FULL_MASK_CNS, NULL, oamId , smemLion3ActiveWriteOamTbl,oamId},                   \
                                                                                                        \
    /* Aging Table */                                                                                   \
    {0x00004000, AAS_ACTIVE_READ_OAM_MASK_CNS, smemLion3ActiveReadExceptionSummaryBitmap, oamId , NULL,oamId},    \
    /* Meg Exception Table */                                                                           \
    {0x00010000, AAS_ACTIVE_READ_OAM_MASK_CNS, smemLion3ActiveReadExceptionSummaryBitmap, oamId , NULL,oamId},    \
    /* Source Interface Exception Table */                                                              \
    {0x00018000, AAS_ACTIVE_READ_OAM_MASK_CNS, smemLion3ActiveReadExceptionSummaryBitmap, oamId , NULL,oamId},    \
    /* Invalid Keepalive Hash Exception Table */                                                        \
    {0x00020000, AAS_ACTIVE_READ_OAM_MASK_CNS, smemLion3ActiveReadExceptionSummaryBitmap, oamId , NULL,oamId},    \
    /* Excess Keepalive Exception Table */                                                              \
    {0x00028000, AAS_ACTIVE_READ_OAM_MASK_CNS, smemLion3ActiveReadExceptionSummaryBitmap, oamId , NULL,oamId},    \
    /* OAM Exception Summary Table */                                                                   \
    {0x00030000, AAS_ACTIVE_READ_OAM_MASK_CNS, smemLion3ActiveReadExceptionSummaryBitmap, oamId , NULL,oamId},    \
    /* RDI Status Change Exception Table */                                                             \
    {0x00038000, AAS_ACTIVE_READ_OAM_MASK_CNS, smemLion3ActiveReadExceptionSummaryBitmap, oamId , NULL,oamId},    \
    /* Tx Period Exception Table */                                                                     \
    {0x00040000, AAS_ACTIVE_READ_OAM_MASK_CNS, smemLion3ActiveReadExceptionSummaryBitmap, oamId , NULL,oamId},    \
                                                                                                        \
    /* Meg Level Exception Counter */                                                                   \
    {0x00000A00, SMEM_FULL_MASK_CNS, smemLion3ActiveReadExceptionCounter, oamId , NULL,oamId},          \
    /* Source Interface Mismatch Counter */                                                             \
    {0x00000A04, SMEM_FULL_MASK_CNS, smemLion3ActiveReadExceptionCounter, oamId , NULL,oamId},          \
    /* Invalid Keepalive Hash Counter */                                                                \
    {0x00000A08, SMEM_FULL_MASK_CNS, smemLion3ActiveReadExceptionCounter, oamId , NULL,oamId},          \
    /* Excess Keepalive Counter */                                                                      \
    {0x00000A0C, SMEM_FULL_MASK_CNS, smemLion3ActiveReadExceptionCounter, oamId , NULL,oamId},          \
    /* Keepalive Aging Counter */                                                                       \
    {0x00000A10, SMEM_FULL_MASK_CNS, smemLion3ActiveReadExceptionCounter, oamId , NULL,oamId},          \
    /* RDI Status Change Counter */                                                                     \
    {0x00000A14, SMEM_FULL_MASK_CNS, smemLion3ActiveReadExceptionCounter, oamId , NULL,oamId},          \
    /* Tx Period Exception Counter */                                                                   \
    {0x00000A18, SMEM_FULL_MASK_CNS, smemLion3ActiveReadExceptionCounter, oamId , NULL,oamId},          \
    /* Summary Exception Counter */                                                                     \
    {0x00000A1C, SMEM_FULL_MASK_CNS, smemLion3ActiveReadExceptionCounter, oamId , NULL,oamId}

/* bind the IOAM unit to it's active mem */
static void smemAasBindUnitIOamActiveMem(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    INOUT SMEM_UNIT_CHUNKS_STC  * unitPtr
)
{
    START_BIND_UNIT_ACTIVE_MEM_MAC(devObjPtr,unitPtr)

    ACTIVE_MEM_OAM_COMMON_SIP7_MAC(0),

    END_BIND_UNIT_ACTIVE_MEM_MAC(devObjPtr,unitPtr)
}

/* bind the EOAM unit to it's active mem */
static void smemAasBindUnitEOamActiveMem(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    INOUT SMEM_UNIT_CHUNKS_STC  * unitPtr
)
{
    START_BIND_UNIT_ACTIVE_MEM_MAC(devObjPtr,unitPtr)

    ACTIVE_MEM_OAM_COMMON_SIP7_MAC(1),

    END_BIND_UNIT_ACTIVE_MEM_MAC(devObjPtr,unitPtr)
}

/**
* @internal smemAasUnitOam function
* @endinternal
*
* @brief   Allocate address type specific memories -- for the OAM unit
*
* @param[in] devObjPtr                - pointer to device object.
* @param[in,out] unitPtr              - pointer to the unit chunk
* @param[in] bindTable                - bind table with memory chunks
*/
static void smemAasUnitOam
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    INOUT SMEM_UNIT_CHUNKS_STC  * unitPtr,
    IN GT_BOOL bindTable
)
{

    /* chunks with flat memory (no formulas) */
    {
        /* start with tables */
        SMEM_CHUNK_BASIC_STC  chunksMem[]=
        {
             {SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000000, 0x00000004)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000014, 0x0000003C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000050, 0x0000005C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000070, 0x0000007C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000084, 0x00000088)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000090, 0x000000E0)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000000F0, 0x000000FC)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000160, 0x00000160)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000200, 0x00000A1C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000A40, 0x00000A44)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000A50, 0x00000A58)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000B00, 0x00000BFC)}
            /* Aging Table */
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00004000, 8192), SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(32, 4), SMEM_BIND_TABLE_MAC(oamAgingTable)}
            /* Meg Exception Table */
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00010000, 8192), SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(32, 4), SMEM_BIND_TABLE_MAC(oamMegExceptionTable)}
            /* Source Interface Exception Table */
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00018000, 8192), SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(32, 4), SMEM_BIND_TABLE_MAC(oamSrcInterfaceExceptionTable)}
            /* Invalid Keepalive Hash Table */
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00020000, 8192), SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(32, 4), SMEM_BIND_TABLE_MAC(oamInvalidKeepAliveHashTable)}
            /* Excess Keepalive Table */
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00028000, 8192), SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(32, 4), SMEM_BIND_TABLE_MAC(oamExcessKeepAliveTable)}
            /* OAM Exception Summary Table */
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00030000, 8192), SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(32, 4), SMEM_BIND_TABLE_MAC(oamExceptionSummaryTable)}
            /* RDI Status Change Exception Table */
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00038000, 8192), SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(32, 4), SMEM_BIND_TABLE_MAC(oamRdiStatusChangeExceptionTable)}
            /* Tx Period Exception Table */
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00040000, 8192), SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(32, 4), SMEM_BIND_TABLE_MAC(oamTxPeriodExceptionTable)}
            /* OAM Opcode Packet Command Table */
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00060000, 2048), SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(40, 8), SMEM_BIND_TABLE_MAC(oamOpCodePacketCommandTable)}
            /* OAM Table */
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00100000, 1048576), SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(128, 16), SMEM_BIND_TABLE_MAC(oamTable)}
        };
        GT_U32  numOfChunks = sizeof(chunksMem)/sizeof(SMEM_CHUNK_BASIC_STC);


        GT_U32  ii;

        for(ii = 0 ; ii < numOfChunks; ii++)
        {
            if (bindTable == GT_FALSE)
            {
                /* make sure that table are not bound to eoam(only to ioam) */
                chunksMem[ii].tableOffsetValid = 0;
                chunksMem[ii].tableOffsetInBytes = 0;
            }
        }

        smemInitMemChunk(devObjPtr,chunksMem,numOfChunks,unitPtr);
    }

    {
        static SMEM_REGISTER_DEFAULT_VALUE_STC myUnit_registersDefaultValueArr[] =
        {
             {DUMMY_NAME_PTR_CNS,            0x00000004,         0x00000038,    0,    0x0}
            ,{DUMMY_NAME_PTR_CNS,            0x00000020,         0x00000FF0,    0,    0x0}
            ,{DUMMY_NAME_PTR_CNS,            0x00000024,         0x000001E0,    0,    0x0}
            ,{DUMMY_NAME_PTR_CNS,            0x00000028,         0x01010101,    2,    0x4}
            ,{DUMMY_NAME_PTR_CNS,            0x00000030,         0x2B2B2B2B,    4,    0x4}
            ,{DUMMY_NAME_PTR_CNS,            0x00000050,         0x2D2D2D2D,    4,    0x4}
            ,{DUMMY_NAME_PTR_CNS,            0x00000070,         0x01010101,    4,    0x4}
            ,{DUMMY_NAME_PTR_CNS,            0x00000084,         0x00000001,    0,    0x0}

            ,{NULL,            0,         0x00000000,      0,    0x0      }
        };
        static SMEM_LINK_LIST_REGISTER_DEFAULT_VALUE_STC list = {myUnit_registersDefaultValueArr,NULL};
        unitPtr->unitDefaultRegistersPtr = &list;
    }
}

/**
* @internal smemAasUnitIOam function
* @endinternal
*
* @brief   Allocate address type specific memories -- for the IOAM unit
*
* @param[in] devObjPtr                - pointer to device object.
* @param[in,out] unitPtr              - pointer to the unit chunk
* @param[in] bindTable                - bind table with memory chunks
*/
static void smemAasUnitIOam
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    INOUT SMEM_UNIT_CHUNKS_STC  * unitPtr
)
{
    smemAasBindUnitIOamActiveMem(devObjPtr,unitPtr);
    smemAasUnitOam(devObjPtr,unitPtr, GT_TRUE);
}

/**
* @internal smemAasUnitEOam function
* @endinternal
*
* @brief   Allocate address type specific memories -- for the EOAM unit
*
* @param[in] devObjPtr                - pointer to device object.
* @param[in,out] unitPtr              - pointer to the unit chunk
* @param[in] bindTable                - bind table with memory chunks
*/
static void smemAasUnitEOam
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    INOUT SMEM_UNIT_CHUNKS_STC  * unitPtr
)
{
    smemAasBindUnitEOamActiveMem(devObjPtr,unitPtr);
    smemAasUnitOam(devObjPtr,unitPtr, GT_FALSE);
}

/**
* @internal smemAasUnitHbu function
* @endinternal
*
* @brief   Allocate address type specific memories
*
* @param[in] devObjPtr                - pointer to device object.
* @param[in,out] unitPtr                  - pointer to the unit chunk
*/
static void smemAasUnitHbu
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    INOUT SMEM_UNIT_CHUNKS_STC  * unitPtr
)
{
    {
        SMEM_CHUNK_BASIC_STC  chunksMem[]=
        {
              {SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000000, 0x00000060)}
              /*local_action[%N]*/
             ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000070, 0x000000a8)}
            /* mapping_table */
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00000800, 2048 ), SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(32, 4), SMEM_BIND_TABLE_MAC(hbuPortMappingTable)}
        };

        GT_U32  numOfChunks = sizeof(chunksMem)/sizeof(SMEM_CHUNK_BASIC_STC);

        smemInitMemChunk(devObjPtr,chunksMem,numOfChunks,unitPtr);
    }
}

/**
* @internal smemAasUnitPolicerUnify function
* @endinternal
*
* @brief   Allocate address type specific memories -- for the any of the 3 Policers:
*         1. iplr 0
*         2. iplr 1
*         3. eplr
* @param[in] devObjPtr                - pointer to device object.
* @param[in,out] unitPtr                  - pointer to the unit chunk
* @param[in] plrUnit                  - PLR unit
*/
static void smemAasUnitPolicerUnify
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    INOUT SMEM_UNIT_CHUNKS_STC  * unitPtr,
    IN SMEM_SIP5_PP_PLR_UNIT_ENT   plrUnit
)
{
    {
        SMEM_CHUNK_BASIC_STC  chunksMem[]=
        {
             {SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000000, 0x00000034)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000044, 0x00000044)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000060, 0x00000080)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000088, 0x0000008C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x000000B0, 0x000000BC)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000100, 0x00000100)}
            /*registers -- not table/memory !! -- Policer Table Access Data<%n> */
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC(0x00000104 ,9*4),SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(32,4),SMEM_BIND_TABLE_MAC(policerTblAccessData)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000200, 0x00000208)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000228, 0x00000228)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000400, 0x00000408)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00000800, 0x00000BFC)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001004, 0x00001008)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001010, 0x00001014)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001020, 0x00001058)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001200, 0x00001204)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001210, 0x00001214)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001220, 0x00001224)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001250, 0x00001254)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001260, 0x00001264)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001304, 0x00001314)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001404, 0x00001414)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00001420, 0x0000144C)}
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_END_ADDR_MAC (0x00002000, 0x00002014)}
            /*IPFIX aging alert Memory*/
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00010000, 65536), SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(32,4),SMEM_BIND_TABLE_MAC(policerIpfixAgingAlert)}
            /* IPFIX 1st N Packets Table*/
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00020000, 65536) , SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(32,4),SMEM_BIND_TABLE_MAC(policerIpfix1StNPackets) }
            /*IPFIX wrap around alert Memory*/
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00030000, 65536), SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(32,4),SMEM_BIND_TABLE_MAC(policerIpfixWaAlert)}
            /*Ingress Policer Re-Marking Memory*/
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00040000, 8192 ), SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(51,8),SMEM_BIND_TABLE_MAC(policerReMarking)}
            /* port attributes (replace -- Port%p and Packet Type Translation Table)*/
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00048000 , 4096), SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(13,4),SMEM_BIND_TABLE_MAC(policerMeterPointer)}
            /* replace : SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->PLR[plrUnit].policerInitialDP*/
            /*qos Attributes*/
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x0004A000, 1024) , SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(20,4),SMEM_BIND_TABLE_MAC(policerQosAttributes)}
            /*e Attributes Table*/
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00800000, 524288), SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(32,4),SMEM_BIND_TABLE_MAC(policerEPortEVlanTrigger)}
            /*Metering Conformance Level Sign Memory*/
            ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00900000, 524288), SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(2,4),SMEM_BIND_TABLE_MAC(policerConformanceLevelSign)}
        };
        GT_U32  numOfChunks = sizeof(chunksMem)/sizeof(SMEM_CHUNK_BASIC_STC);

        smemSip6PolicerSetTableSize(devObjPtr,numOfChunks,chunksMem);
        smemBobkPolicerTablesSupport(devObjPtr,numOfChunks,chunksMem,plrUnit);

        smemInitMemChunk(devObjPtr,chunksMem,numOfChunks,unitPtr);
    }

    if(plrUnit == SMEM_SIP5_PP_PLR_UNIT_IPLR_0_E)
    {
        {
            SMEM_CHUNK_BASIC_STC  chunksMem[]=
            {
                /*Metering Configuration Memory*/
                 {SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00100000, 1048576 ) , SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(57,8),SMEM_BIND_TABLE_MAC(policerConfig)}
                /*Metering Token Bucket Memory*/
                ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00400000, 4194304 ), SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(211,32),SMEM_BIND_TABLE_MAC(policer)}
                /*Counting Memory*/
                ,{SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x01000000, 16777216), SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(229,32),SMEM_BIND_TABLE_MAC(policerCounters)}
            };
            GT_U32  numOfChunks = sizeof(chunksMem)/sizeof(SMEM_CHUNK_BASIC_STC);
            SMEM_UNIT_CHUNKS_STC    tmpUnitChunk;

            smemSip6PolicerSetTableSize(devObjPtr,numOfChunks,chunksMem);
            smemInitMemChunk(devObjPtr,chunksMem, numOfChunks, &tmpUnitChunk);

            /*add the tmp unit chunks to the main unit */
            smemInitMemCombineUnitChunks(devObjPtr,unitPtr,&tmpUnitChunk);
        }
    }
    else
    if (plrUnit == SMEM_SIP5_PP_PLR_UNIT_IPLR_1_E)
    {
        {
            SMEM_CHUNK_BASIC_STC  chunksMem[]=
            {
                /*Metering Configuration Memory*/
                 {SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00100000, 1048576 ) , SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(57,8),SMEM_BIND_TABLE_MAC(policer1Config)}
            };
            GT_U32  numOfChunks = sizeof(chunksMem)/sizeof(SMEM_CHUNK_BASIC_STC);
            SMEM_UNIT_CHUNKS_STC    tmpUnitChunk;

            smemSip6PolicerSetTableSize(devObjPtr,numOfChunks,chunksMem);
            smemInitMemChunk(devObjPtr,chunksMem, numOfChunks, &tmpUnitChunk);

            /*add the tmp unit chunks to the main unit */
            smemInitMemCombineUnitChunks(devObjPtr,unitPtr,&tmpUnitChunk);
        }
    }
    else
    if (plrUnit == SMEM_SIP5_PP_PLR_UNIT_EPLR_E)
    {
        {
            SMEM_CHUNK_BASIC_STC  chunksMem[]=
            {
                /*Metering Configuration Memory*/
                 {SET_SMEM_CHUNK_BASIC_STC_ENTRY_BY_NUM_BYTES_MAC (0x00100000, 1048576 ) , SET_SMEM_ENTRY_SIZE_AND_ALIGN_MAC(57,8),SMEM_BIND_TABLE_MAC(egressPolicerConfig)}
            };
            GT_U32  numOfChunks = sizeof(chunksMem)/sizeof(SMEM_CHUNK_BASIC_STC);
            SMEM_UNIT_CHUNKS_STC    tmpUnitChunk;

            smemSip6PolicerSetTableSize(devObjPtr,numOfChunks,chunksMem);
            smemInitMemChunk(devObjPtr,chunksMem, numOfChunks, &tmpUnitChunk);

            /*add the tmp unit chunks to the main unit */
            smemInitMemCombineUnitChunks(devObjPtr,unitPtr,&tmpUnitChunk);
        }
    }

    {
        /* registers defaults, relevant for IPLR0, IPLR1, EPLR */
        static SMEM_REGISTER_DEFAULT_VALUE_STC myUnit_registersDefaultValueArr[] =
        {
             {DUMMY_NAME_PTR_CNS,            0x00000000,         0x09e98003,      1,    0x4    }
            ,{DUMMY_NAME_PTR_CNS,            0x00000004,         0x00007000,      1,    0x4    }
            ,{DUMMY_NAME_PTR_CNS,            0x00000010,         0x0007ffff,      1,    0x4    }
            ,{DUMMY_NAME_PTR_CNS,            0x00000014,         0x00019000,      1,    0x4    }
            ,{DUMMY_NAME_PTR_CNS,            0x00000028,         0x0001ffff,      1,    0x4    }
            ,{DUMMY_NAME_PTR_CNS,            0x00000034,         0x000bffff,      1,    0x4    }
            ,{DUMMY_NAME_PTR_CNS,            0x00000060,         0xffffffff,      1,    0x4    }
            ,{DUMMY_NAME_PTR_CNS,            0x00000064,         0x00001000,      1,    0x4    }
            ,{DUMMY_NAME_PTR_CNS,            0x0000006c,         0x00100000,      1,    0x4    }
            ,{DUMMY_NAME_PTR_CNS,            0x00000070,         0x00001fff,      1,    0x4    }
            ,{DUMMY_NAME_PTR_CNS,            0x00000088,         0x07fff800,      1,    0x4    }
            ,{DUMMY_NAME_PTR_CNS,            0x0000008c,         0xffffffff,      1,    0x4    }
            ,{DUMMY_NAME_PTR_CNS,            0x00000228,         0x0000ffff,      1,    0x4    }
            ,{DUMMY_NAME_PTR_CNS,            0x00000408,         0x00000006,      1,    0x4    }
            ,{DUMMY_NAME_PTR_CNS,            0x00000800,         0x0001ffff,    128,    0x4    }
            ,{DUMMY_NAME_PTR_CNS,            0x00000a00,         0x0001ffff,    128,    0x4    }
            ,{DUMMY_NAME_PTR_CNS,            0x00001004,         0x00014052,      1,    0x4    }
            ,{DUMMY_NAME_PTR_CNS,            0x00001008,         0x000010a4,      1,    0x4    }
            ,{DUMMY_NAME_PTR_CNS,            0x00001010,         0x01f8a06c,      1,    0x4    }
            ,{DUMMY_NAME_PTR_CNS,            0x00001014,         0x000010d8,      1,    0x4    }
            ,{DUMMY_NAME_PTR_CNS,            0x00001020,         0x00000041,      8,    0x4    }
            ,{DUMMY_NAME_PTR_CNS,            0x00001304,         0x000000bf,      2,    0x100  }
            ,{DUMMY_NAME_PTR_CNS,            0x00001314,         0x0000003f,      2,    0x100  }
            ,{DUMMY_NAME_PTR_CNS,            0x0000142c,         0x0000007f,      3,    0x10   }

            ,{NULL,               0,          0x00000000, 0,     0x0}
        };

        static SMEM_REGISTER_DEFAULT_VALUE_STC myUnit_registersDefaultValueArr_policerConfig[] =
        {
            /*Metering Configuration Memory*/
             {DUMMY_NAME_PTR_CNS, 0x00100000, 0x00000030, 131072            , 0x8}

            ,{NULL,               0,          0x00000000, 0,     0x0}
        };
        static SMEM_LINK_LIST_REGISTER_DEFAULT_VALUE_STC list_next =
            {myUnit_registersDefaultValueArr_policerConfig,NULL};
        static SMEM_LINK_LIST_REGISTER_DEFAULT_VALUE_STC list =
            {myUnit_registersDefaultValueArr,&list_next};

        GT_U32  numOfMeters = devObjPtr->policerSupport.iplrTableSize;
        myUnit_registersDefaultValueArr_policerConfig[0].numOfRepetitions = numOfMeters;

        unitPtr->unitDefaultRegistersPtr = &list;
    }

#if 0
    /* NOTE :  the next registers replaces with new table : policerQosAttributes */
    SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->PLR[plrUnit].policerInitialDP[n] =
    SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->PLR[plrUnit].qosProfileToPriority_tab =  /* 128 regs each (8 * 4bits) */
    /* NOTE :  the next registers replaces with new table : policerMeterPointer */
    SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->PLR[plrUnit].policerPortMeteringReg[n] =

#endif

    {/*start of unit globalConfig */
        {/*0001040+4*t*/
            GT_U32    t;
            for(t = 0 ; t <= 6 ; t++) {
                SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->PLR[plrUnit].globalConfig.countingConfigTableThreshold[t] =
                    0x0001040+4*t;
            }/* end of loop t */
        }/*0001040+4*t*/
        {/*0001020+4*n*/
            GT_U32    n;
            for(n = 0 ; n <= 7 ; n++) {
                SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->PLR[plrUnit].globalConfig.countingConfigTableSegment[n] =
                    0x0001020+4*n;
            }/* end of loop n */
        }/*0001020+4*n*/
        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->PLR[plrUnit].policerMeteringBaseAddr = 0x0000001c;
        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->PLR[plrUnit].policerCountingBaseAddr = 0x00000018;
        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->PLR[plrUnit].policerCtrl1 = 0x00000004;
        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->PLR[plrUnit].policerCtrl0 = 0x00000000;
        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->PLR[plrUnit].policerMRU = 0x00000014;
        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->PLR[plrUnit].meteringAddressingModeConfiguration0 = 0x00000024;
        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->PLR[plrUnit].hierarchicalPolicerCtrl = 0x00000020;
        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->PLR[plrUnit].globalBillingCntrIndexingModeConfig1 = 0x0000000c;
        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->PLR[plrUnit].globalBillingCntrIndexingModeConfig0 = 0x00000008;
        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->PLR[plrUnit].meteringAddressingModeConfiguration1 = 0x00000028;
        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->PLR[plrUnit].policerOAM = 0x00000030;
        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->PLR[plrUnit].globalConfig.plrAnalyzerIndexes = 0x0000002c;

        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->PLR[plrUnit].statisticalMeteringConfig0 = 0x00001004;
        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->PLR[plrUnit].statisticalMeteringConfig1 = 0x00001008;

        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->PLR[plrUnit].globalConfig.globalBillingCntrIndexingModeConfig2 = 0x00000010;
        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->PLR[plrUnit].globalConfig.policerGlobalConfigurations = 0x00000034;
        {/*0x00002000+4*n*/
            GT_U32 n;
            for(n=0; n<=5; n++) {
                SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->PLR[plrUnit].globalConfig.timeRate_n[n] = 0x00002000+4*n;
            }/* end of loop n */
        }/*0x00002000+4*n*/
    }/*end of unit globalConfig */

    {/*start of unit IPFIX */
        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->PLR[plrUnit].IPFIXCtrl = 0x00000044;
        /*
        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->PLR[plrUnit].IPFIXNanoTimerStampUpload = 0x00000018;
        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->PLR[plrUnit].IPFIXSecondsLSbTimerStampUpload = 0x0000001c;
        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->PLR[plrUnit].IPFIXSecondsMSbTimerStampUpload = 0x00000020;
        */
        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->PLR[plrUnit].policerIPFIXDroppedPktCountWAThreshold = 0x00000060;
        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->PLR[plrUnit].policerIPFIXPktCountWAThresholdLSB = 0x00000064;
        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->PLR[plrUnit].policerIPFIXPktCountWAThresholdMSB = 0x00000068;
        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->PLR[plrUnit].policerIPFIXByteCountWAThresholdLSB = 0x0000006c;
        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->PLR[plrUnit].policerIPFIXByteCountWAThresholdMSB = 0x00000070;

        {/*0x00000074+n*4*/
            GT_U32 n;
            for(n=0; n<=3; n++) {
                SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->PLR[plrUnit].ipfixSampleEntriesLog_n[n] = 0x00000074+n*4;
            }/* end of loop n */
        }/*0x00000074+n*4*/

        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->PLR[plrUnit].IPFIXFirstNPacketsConfig0 = 0x00000088;
        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->PLR[plrUnit].IPFIXFirstNPacketsConfig1 = 0x0000008c;

    }/*end of unit IPFIX */

    {/*start of unit Miscellaneous */
        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->PLR[plrUnit].policerInterruptMask = 0x00000204;
        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->PLR[plrUnit].policerInterruptCause = 0x00000200;
        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->PLR[plrUnit].policerBadAddressLatch = 0x00000208;

    }/*end of unit Miscellaneous */

    {/*start of unit Indirect Table Access */
        {/*74+n*4*/
            GT_U32    n;
            for(n = 0 ; n <= 8 ; n++) {
                SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->PLR[plrUnit].policerTableAccessData[n] =
                    0x104+n*4;
            }/* end of loop n */
        }/*74+n*4*/
        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->PLR[plrUnit].policerTableAccessCtrl = 0x00000100;

    }/*end of unit Indirect Table Access */

    {/*start of unit scan */
        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->PLR[plrUnit].policerMeteringRefreshScanRateLimit = 0x000000b0;
        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->PLR[plrUnit].policerMeteringRefreshScanAddrRange0 = 0x000000b8;
        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->PLR[plrUnit].policerMeteringRefreshScanAddrRange1 = 0x000000b4;
        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->PLR[plrUnit].policerScanCtrl = 0x000000bc;

    }/*end of unit scan */

    {/*start of unit MEF_10_3 */
        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->PLR[plrUnit].
            mef10_3_bucket0_max_rate_tab = 0x00000800; /* 128 regs*/
        SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->PLR[plrUnit].
            mef10_3_bucket1_max_rate_tab = 0x00000a00; /* 128 regs */

    }/*end of unit MEF_10_3 */

}

static void smemAasUnitIplr0
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    INOUT SMEM_UNIT_CHUNKS_STC  * unitPtr
)
{
    START_BIND_UNIT_ACTIVE_MEM_MAC(devObjPtr,unitPtr)

/*policer*/
    /* add common lines of all policers */
    AAS_ACTIVE_MEM_POLICER_COMMON_MAC(SMEM_SIP5_PP_PLR_UNIT_IPLR_0_E),

    END_BIND_UNIT_ACTIVE_MEM_MAC(devObjPtr,unitPtr)

    smemAasUnitPolicerUnify(devObjPtr,unitPtr,SMEM_SIP5_PP_PLR_UNIT_IPLR_0_E);
}

static void smemAasUnitIplr1
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    INOUT SMEM_UNIT_CHUNKS_STC  * unitPtr
)
{
    START_BIND_UNIT_ACTIVE_MEM_MAC(devObjPtr,unitPtr)

/*policer */
    /* add common lines of all policers */
    AAS_ACTIVE_MEM_POLICER_COMMON_MAC(SMEM_SIP5_PP_PLR_UNIT_IPLR_1_E),

    END_BIND_UNIT_ACTIVE_MEM_MAC(devObjPtr,unitPtr)

    smemAasUnitPolicerUnify(devObjPtr,unitPtr,SMEM_SIP5_PP_PLR_UNIT_IPLR_1_E);
}

static void smemAasUnitEplr
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    INOUT SMEM_UNIT_CHUNKS_STC  * unitPtr
)
{
    START_BIND_UNIT_ACTIVE_MEM_MAC(devObjPtr,unitPtr)

/*policer*/
    /* add common lines of all policers */
    AAS_ACTIVE_MEM_POLICER_COMMON_MAC(SMEM_SIP5_PP_PLR_UNIT_EPLR_E),

    END_BIND_UNIT_ACTIVE_MEM_MAC(devObjPtr,unitPtr)

    smemAasUnitPolicerUnify(devObjPtr,unitPtr,SMEM_SIP5_PP_PLR_UNIT_EPLR_E);
}

/**
* @internal smemAasSpecificDeviceUnitAlloc_SIP_units function
* @endinternal
*
* @brief   specific initialization units allocation that called before alloc units
*         of any device.
*         SIP units
* @param[in] devObjPtr                - pointer to device object.
*                                       Pointer to object for specific subunit
*/
static void smemAasSpecificDeviceUnitAlloc_SIP_units
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr
)
{
    SMEM_DEVICE_UNIT_ALLOCATION_STC allocUnitsArr []=
    {
         {STR(UNIT_L2I)         ,smemAasUnitL2i}
        ,{STR(UNIT_EGF_SHT)     ,smemAasUnitEgfSht}
        ,{STR(UNIT_EGF_QAG)     ,smemAasUnitEgfQag}
        ,{STR(UNIT_EGF_EFT)     ,smemAasUnitEgfEft}
        ,{STR(UNIT_TCAM)        ,smemAasUnitTcam}
        ,{STR(UNIT_TTI)         ,smemAasUnitTti}
        ,{STR(UNIT_IPCL)        ,smemAasUnitIpcl}
        ,{STR(UNIT_MPCL)        ,smemAasUnitMpcl}
        ,{STR(UNIT_EPCL)        ,smemAasUnitEpcl}
        ,{STR(UNIT_SMU)         ,smemAasUnitSmu}
        ,{STR(UNIT_HA)          ,smemAasUnitHa}
        ,{STR(UNIT_CNC)         ,smemAasUnitCnc}
        ,{STR(UNIT_PREQ)        ,smemAasUnitPreq}
        ,{STR(UNIT_LPM)         ,smemAasUnitLpm}
        ,{STR(UNIT_IPVX)        ,smemAasUnitIpvx}
        ,{STR(UNIT_PHA)         ,smemHawkUnitPha}
        ,{STR(UNIT_EMX)         ,smemAasUnitEmx}
        ,{STR(UNIT_TTI_LU)      ,smemAasUnitTtiLu}
        ,{STR(UNIT_SHM)         ,smemAasUnitShm}
        ,{STR(UNIT_EM)          ,smemAasUnitEm}
        ,{STR(UNIT_REDUCED_EM)  ,smemAasUnitReducedEm}
        ,{STR(UNIT_MLL)         ,smemAasUnitMll}
        ,{STR(UNIT_EQ)          ,smemAasUnitEq}
        ,{STR(UNIT_FDB)         ,smemAasUnitFdb}
        ,{STR(UNIT_IPE)         ,smemAasUnitIpe}
        ,{STR(UNIT_PPU_FOR_IPE) ,smemAasUnitPpuForIpe}
        ,{STR(UNIT_PCA_LMU_0)   ,smemAasUnitLmu}
        ,{STR(UNIT_IOAM)        ,smemAasUnitIOam}
        ,{STR(UNIT_EOAM)        ,smemAasUnitEOam}
        ,{STR(UNIT_HBU)         ,smemAasUnitHbu}
        ,{STR(UNIT_IPLR)        ,smemAasUnitIplr0}
        ,{STR(UNIT_IPLR1)       ,smemAasUnitIplr1}
        ,{STR(UNIT_EPLR)        ,smemAasUnitEplr}

        /* must be last */
        ,{NULL,NULL}
    };

    smemGenericUnitAlloc(devObjPtr,allocUnitsArr);
}

/**
* @internal smemAasActiveReadLpm function
* @endinternal
*
* @brief   redirect the read of LPM memory to do the read of another table
*
* @param[in] devObjPtr                - device object PTR.
* @param[in] address                  - Address for ASIC memory.
* @param[in] memPtr                   - Pointer to the register's memory in the simulation.
* @param[in] param                    - Registers' specific parameter
*
* @param[out] outMemPtr                - Pointer to the memory to copy register's content.
*/
 void smemAasActiveReadLpm (
    IN         SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN         GT_U32   address,
    IN         GT_U32   memSize,
    IN         GT_U32 * memPtr,
    IN         GT_UINTPTR   param,
    OUT        GT_U32 * outMemPtr
)
{
    DECLARE_FUNC_NAME(smemAasActiveReadLpm);

    GT_U32  regAddr,regValue;
    GT_U32  bankIndex;
    GT_U32  hiddenLineIndex;
    GT_U32  pipeId,tileId;
    GT_U32  tableStep;
    GT_U32  *currentLineInMemoryPtr;
    GT_U32  wordOffsetInLine=0;

    /* read the value of the bankId from the register */
    regAddr = SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->LPM.lpmMemBankId;
    smemRegGet(devObjPtr,regAddr,&regValue);
    __LOG(("Read the value of the bankId from the LPM register. lpmMemBankId=[%d] \n",regValue));

    /* calculate the real LPM line index */
    bankIndex = regValue&0x3F;
    tableStep=32; /* lpm entry memory address alignment */
    hiddenLineIndex = (address&0x007FFFFF)/tableStep;
    wordOffsetInLine = (address%tableStep)/4;

    /* read the data from the correct memory */
    pipeId = smemGetCurrentPipeId(devObjPtr);
    smemConvertGlobalPipeIdToTileAndLocalPipeIdInTile(devObjPtr,pipeId,&tileId);

    if (tileId==0)
    {
        currentLineInMemoryPtr = smemGenericHiddenFindMem(devObjPtr,
                                                          SMEM_GENERIC_HIDDEN_MEM_LPM_TILE_0_BANK_0_E+bankIndex ,
                                                          hiddenLineIndex, NULL);

        *outMemPtr=currentLineInMemoryPtr[wordOffsetInLine];
    }
    else
    {
        currentLineInMemoryPtr = smemGenericHiddenFindMem(devObjPtr,
                                                          SMEM_GENERIC_HIDDEN_MEM_LPM_TILE_1_BANK_0_E+bankIndex ,
                                                          hiddenLineIndex, NULL);

        *outMemPtr=currentLineInMemoryPtr[wordOffsetInLine];
    }

    return;
}

/**
* @internal smemAasActiveWriteLpm function
* @endinternal
*
* @brief   redirect the write of LPM memory to do the wrtite from another table
*
* @param[in] devObjPtr                - device object PTR.
* @param[in] address                  - Address for ASIC memory.
* @param[in] memSize                  - size of the requested memory
* @param[in] memPtr                   - Pointer to the register's memory in the simulation.
* @param[in] param                    - Registers' specific parameter.
* @param[in] inMemPtr                 - Pointer to the memory to get register's content.
*/
void smemAasActiveWriteLpm (
    IN         SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN         GT_U32   address,
    IN         GT_U32   memSize,
    IN         GT_U32 * memPtr,
    IN         GT_UINTPTR   param,
    IN         GT_U32 * inMemPtr
)
{
    DECLARE_FUNC_NAME(smemAasActiveWriteLpm);

    GT_U32  regAddr,regValue;
    GT_U32  bankIndex;
    GT_U32  hiddenLineIndex;
    GT_U32  pipeId,tileId;
    GT_U32  tableStep;
    GT_U32  *currentLineInMemoryPtr;
    GT_U32  wordOffsetInLine=0;

    /* get the value of the bankId from to register */
    regAddr = SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->LPM.lpmMemBankId;
    smemRegGet(devObjPtr,regAddr,&regValue);
    /* calculate the real LPM line index */
    bankIndex = regValue&0x3F;
    tableStep=32; /* lpm entry memory address alignment */
    hiddenLineIndex = (address&0x007FFFFF)/tableStep;
    wordOffsetInLine = (address%tableStep)/4;
    __LOG((" Read the value of the bankId from the LPM register. lpmMemBankId=[%d] \n",regValue));

    /* Write LPM line into LPM memory */
    pipeId = smemGetCurrentPipeId(devObjPtr);
    smemConvertGlobalPipeIdToTileAndLocalPipeIdInTile(devObjPtr,pipeId,&tileId);

    if (tileId==0)
    {
        currentLineInMemoryPtr = smemGenericHiddenFindMem(devObjPtr,
                                                          SMEM_GENERIC_HIDDEN_MEM_LPM_TILE_0_BANK_0_E+bankIndex ,
                                                          hiddenLineIndex, NULL);

        currentLineInMemoryPtr[wordOffsetInLine]=*inMemPtr;
    }
    else
    {
        currentLineInMemoryPtr = smemGenericHiddenFindMem(devObjPtr,
                                                          SMEM_GENERIC_HIDDEN_MEM_LPM_TILE_1_BANK_0_E+bankIndex ,
                                                          hiddenLineIndex, NULL);

        currentLineInMemoryPtr[wordOffsetInLine]=*inMemPtr;
    }

    return;
}
