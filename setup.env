#!/bin/bash
# Copyright 2021 HFR
#
#
# Author: Hwang In Sung <balkrow@hfrnet.com>
#

TOPDIR=`pwd`
OUTPUT=$TOPDIR/build
UBOOT_OUTPUT=$OUTPUT/uboot
KERNEL_OUTPUT=$OUTPUT/kernel
MAKEOPT="-j 19"
COMPRESS=gzip
INITRAMFS_DIR=rootfs
TFTPROOT=/tftpboot
USERID=`id -u`
GROUPID=`id -g`
AGENCYANDCLIENT=nsvz
PRODUCT=eag6l
SYSTEM=$PRODUCT-os
UBOOT_SYSTEM=$PRODUCT-boot

### [#70] Adding RDL feature, dustin, 2024-07-02 ###
PRODUCT_CODE=000000000101
PRODUCT_VENDOR=HN
PRODUCT_NAME=EAG6L
BUILD_ID=1
BUILD_NAME="R1.0"
EVAL_VERSION=`cat version_string`
MAJOR=1
MINOR=0
REV=3
OS_IMG=eag6l-os-v${EVAL_VERSION}.bin
FPGA_OS_IMG=nothing
### [#103] BANK header 정보 오류, balkrow, 2024-08-27 
#PKG_VERSION="1.0.0"
IMG_TYPE="lfm09"

### [#112] package build script renewal, balkrow, 2024-09-05
PKG_VERSION="1.0.0"

### [#99] EAG6L 개발 검증 이슈 F/U, balkrow, 2024-08-30
FPGA_POF_FILE=eag6l_fpga_top_20240909.pof
FPGA_VER="1.1"
FPGA_IMG_SIZE=745472
EMBEDED_FPGA_IMG=n
FPGA_FW_IMG=eag6l_fpga_v${FPGA_VER}.bin
INCLUDE_FPGA_IMG=n

export MAJOR MINOR REV OS_IMG FPGA_FW_IMG FPGA_OS_IMG EVAL_VERSION PRODUCT_VENDOR PRODUCT_CODE PRODUCT_NAME BUILD_ID \
BUILD_NAME PKG_VERSION IMG_TYPE FPGA_POF_FILE FPGA_VER FPGA_IMG_SIZE EMBEDED_FPGA_IMG
### [#70] ##########################################

HFR_VENDOR_NAME=hfr
BUILD_BOARD_NAME=eag6l
CROSS_COMPILE=arm-linux-gnueabihf-
CROSS_COMPILE_PFX=arm-linux-gnueabihf
#CROSS_COMPILE=arm-buildroot-linux-uclibcgnueabihf-
#CROSS_COMPILE_PFX=arm-buildroot-linux-uclibcgnueabihf
ARCH=arm
PATH=$PATH:/opt/gcc-arm-8.2-2018.08-x86_64-arm-linux-gnueabihf/bin
#PATH=$PATH:/opt/buildroot/aarch/bin
HFRCFLAGS="-march=armv7-a -mtune=cortex-a7"
#TARGET_APPS_MANUAL="busybox-1.34.1 i2c-tools dropbear-2022.83 quagga-1.2.4"
TARGET_APPS_MANUAL="busybox-1.34.1 i2c-tools cpss quagga-1.2.4 dbgsh"


export TOPDIR HFR_VENDOR_NAME BUILD_BOARD_NAME CROSS_COMPILE CROSS_COMPILE_PFX ARCH PATH MAKEOPT PRODUCT UBOOT_EVAL_VERSION UBOOT_OUTPUT HFRCFLAGS

alias td="cd ${TOPDIR}"
alias bp=build-project
alias bd="./build.sh"
alias cpss="cd ${TOPDIR}/package/cpss"
alias sysmon="cd ${TOPDIR}/package/quagga-1.2.4/sysmon"
alias eag="cd ${TOPDIR}/package/cpss/cpssEnabler/mainCmd/src/eag6LInt"

usage () {
cat <<EOF
Usage:
 build-project init                     # initialize configuration of kernel and boot
 build-project build                    # building component  and generation image
 build-project all                      # initialize and building component and generation image
 build-project image                    # generate uImage
 build-project clean                    # clean all component
 build-project release                  # release zip package
EOF
}

sp="/-\|"
sc=0
spin() 
{
   printf "\b${sp:sc++:1}"
   ((sc==${#sp})) && sc=0
}
endspin() 
{
   printf "\r%s\n" "$@"
}

chk_status()
{
	until [ -f work_done ];
	do
		spin
		sleep 0.1
	done
	endspin
	rm work_done
}

function clean_kernel 
{
	fbprint_n "Clean kernel...."
	[ pwd == ${TOPDIR} ] || cd ${TOPDIR}
	make -C kernel O=${KERNEL_OUTPUT} ${MAKEOPT} distclean > /dev/null
	make -C kernel O=${KERNEL_OUTPUT} ${MAKEOPT} mrproper > /dev/null
	if [ $? -ne 0 ] ; then
		fbprint_e "Clean kernel.... fail"
		return 1
	fi
	fbprint_d "Clean kernel...."
}

function clean_boot 
{
	fbprint_n "Clean u-boot..."
	[ pwd == ${TOPDIR} ] || cd ${TOPDIR}
	make -C u-boot O=${UBOOT_OUTPUT} ${MAKEOPT} distclean > /dev/null
	make -C u-boot O=${UBOOT_OUTPUT} ${MAKEOPT} mrproper > /dev/null
	if [ $? -ne 0 ] ; then
		fbprint_e "Clean u-boot... fail"
		return 1
	fi
	fbprint_d "Clean u-boot.."
}

function init_boot 
{
	fbprint_n "init u-boot...."
	UBOOT_EVAL_VERSION=`cat u-boot/version_string`
	[ pwd == ${TOPDIR} ] || cd ${TOPDIR}
	make -C u-boot O=${UBOOT_OUTPUT} ${MAKEOPT} distclean
	make -C u-boot O=${UBOOT_OUTPUT} ${MAKEOPT} ${BUILD_BOARD_NAME}_defconfig
	make -C u-boot O=${UBOOT_OUTPUT} HFR_BOOTVER=${UBOOT_EVAL_VERSION} hfrversion

	if [ $? -ne 0 ] ; then
		fbprint_e "init u-boot.... fail"
		return 1
	fi

	fbprint_d "init u-boot...."
}

function build_boot 
{
	[ pwd == ${TOPDIR} ] || cd ${TOPDIR}
	UBOOT_EVAL_VERSION=`cat u-boot/version_string`
	fbprint_n "Building u-boot ver ${UBOOT_EVAL_VERSION} ...."
	make -C u-boot O=${UBOOT_OUTPUT} ${MAKEOPT}
	make -C u-boot O=${UBOOT_OUTPUT} envtools ${MAKEOPT}
	if [ $? -ne 0 ] ; then
		fbprint_e "Building u-boot.... fail"
		return 1
	fi

	fbprint_d "Building u-boot...."
	cp -avf $UBOOT_OUTPUT/u-boot-with-spl-pbl.bin $TFTPROOT/$USER/${UBOOT_SYSTEM}-v${UBOOT_EVAL_VERSION}.bin
	cp -avf $UBOOT_OUTPUT/u-boot-with-spl-pbl.bin ~/${UBOOT_SYSTEM}-v${UBOOT_EVAL_VERSION}.bin
}

function init_kernel 
{

	fbprint_n "init kernel...."
	[ pwd == ${TOPDIR} ] || cd ${TOPDIR}
	make -C kernel O=$KERNEL_OUTPUT $MAKEOPT ${BUILD_BOARD_NAME}_defconfig > /dev/null
	if [ $? -ne 0 ] ; then
		fbprint_e "init kernel.... fail"
		return 1
	fi
	fbprint_d "init kernel...."
}

build_linux()
{
	make -C kernel O=$KERNEL_OUTPUT $MAKEOPT
	if [ $? -ne 0 ] ; then
		touch work_done
		fbprint_e "Building kernel.... fail"
		return 1
	fi
	touch work_done
}

function build_kernel
{

	fbprint_n "Building kernel...."
	[ pwd == ${TOPDIR} ] || cd ${TOPDIR}
	make -C kernel O=$KERNEL_OUTPUT $MAKEOPT V=1
	if [ $? -ne 0 ] ; then
		fbprint_e "Building kernel.... fail"
		return 1
	fi
	fbprint_d "Building kernel...."
}
function config_package
{
	if [ -n $1 ]
	then
		if [ "$1" == "debug" ]
		then
			export CONFIG_DEBUG="CONFIG_DEBUG=y"
		fi
	fi

	fbprint_n "configure package...."
	[ pwd == ${TOPDIR}/package ] || cd ${TOPDIR}/package
	for func in ${TARGET_APPS_MANUAL}
        do
			if [ $func == "netconf" ] ; then
				fbprint_n "entering directory $func/yuma123...."
				cd $func/yuma123
				./build.sh config
				if [ $? -ne 0 ] ; then
					fbprint_e "configure package.... fail"
					unset CONFIG_DEBUG
					return 1
				fi
				fbprint_n "learving directory $func/yuma123...."
				cd ../..
			else
				cd $func
				fbprint_n "entering directory $func ...."
				./build.sh config
				if [ $? -ne 0 ] ; then
					fbprint_e "configure package.... fail"
					unset CONFIG_DEBUG
					return 1
				fi
				fbprint_n "learving directory $func ...."
				cd ..
			fi
    done
	unset CONFIG_DEBUG
	cd ..
	fbprint_d "configure package...."
}

function build_package
{
	if [ -n $1 ]
	then
		if [ "$1" == "debug" ]
		then
			export CONFIG_DEBUG="CONFIG_DEBUG=y"
		fi
	fi

	fbprint_n "Building package...."
	[ pwd == ${TOPDIR}/package ] || cd ${TOPDIR}/package
	for func in ${TARGET_APPS_MANUAL}
        do
			if [ $func == "netconf" ] ; then
				cd $func/yuma123
				./build.sh build
				if [ $? -ne 0 ] ; then
					fbprint_e "build package.... fail"
					unset CONFIG_DEBUG
					return 1
				fi
				cd ../..
			else
				cd $func
				./build.sh build
				if [ $? -ne 0 ] ; then
					fbprint_e "build package.... fail"
					unset CONFIG_DEBUG
					return 1
				fi
				cd ..
			fi
    done
	cd ..
	unset CONFIG_DEBUG
	fbprint_d "Building package...."
}

function clean_package
{

	fbprint_n "Clean-up package...."
	[ pwd == ${TOPDIR}/package ] || cd ${TOPDIR}/package
	for func in ${TARGET_APPS_MANUAL}
        do
			if [ $func == "netconf" ] ; then
				cd $func/yuma123
				./build.sh clean
				cd ../..
			else
				cd $func
				./build.sh clean
				cd ..
			fi
    done
	cd ..
	fbprint_d "Cleanup package...."
}

function install_package
{
	if [ -n $1 ]
	then
		if [ "$1" == "debug" ]
		then
			export CONFIG_DEBUG="CONFIG_DEBUG=y"
		fi
	fi

	fbprint_n "Clean-up rootfs...."
	rm -fr ${TOPDIR}/rootfs	
	cp -avR ${TOPDIR}/rootfs.user ${TOPDIR}/rootfs
	mkdir -p ${TOPDIR}/rootfs/usr/sbin	
		
	fbprint_n "Installing package...."
	[ pwd == ${TOPDIR}/package ] || cd ${TOPDIR}/package
	for func in ${TARGET_APPS_MANUAL}
        do
			if [ $func == "netconf" ] ; then
				cd $func/yuma123
				./build.sh install
				cd ../..
			else
				cd $func
				./build.sh install
				cd ..
			fi
    done
	unset CONFIG_DEBUG
	cd ..
	fbprint_d "Installing package...."
}
### [#99] EAG6L 개발 검증 이슈 F/U, balkrow, 2024-08-30
function gen_fpga_image
{
	fbprint_n "generating fpga $FPGA_VER img..." 
  $TOPDIR/fpga/fpga_img_gen.sh 
  if [ $EMBEDED_FPGA_IMG == "y" ]; then 
    cp -avf ./fpga/eag6l_fpga_v${FPGA_VER}.bin $INITRAMFS_DIR/root
  else
    cp -avf ./fpga/eag6l_fpga_v${FPGA_VER}.bin scripts
  fi
	fbprint_d "generating fpga $FPGA_VER img..." 
}

function gen_initramfs_cpio
{
	fbprint_n "generating initramfs..." 
	[ pwd == ${TOPDIR} ] || cd ${TOPDIR}
	if [ $COMPRESS = "gzip" ]; then
		cd $INITRAMFS_DIR && mkdir -p dev boot home mnt proc run/lock sys tmp && sudo chown -R root:root . && \
		find . -print0 | cpio --quiet -o0 -H newc | gzip -f > $OUTPUT/hfr-initramfs.cpio && \
		sudo chown -R $USERID:$GROUPID . && cd $TOPDIR
	elif [ $COMPRESS = "lzma" ]; then 
		cd $INITRAMFS_DIR && mkdir -p dev boot home mnt proc run/lock sys tmp && sudo chown -R root:root . && \
		find . -print0 | cpio --quiet -o0 -H newc | xz -f --format=lzma > $OUTPUT/hfr-initramfs.cpio && \
		sudo chown -R $USERID:$GROUPID . && cd $TOPDIR
	fi
	fbprint_d "generating initramfs..." 
}

function gdb_install
{
	cp -avf $TOPDIR/dbg/gdb $INITRAMFS_DIR/usr/bin
	cp -avf $TOPDIR/dbg/*.so* $INITRAMFS_DIR/lib
}

function misc_install
{
	[ pwd == ${TOPDIR} ] || cd ${TOPDIR}
	[ -d $INITRAMFS_DIR/etc/sysconfig ] || mkdir -p $INITRAMFS_DIR/etc/sysconfig
	cp -avf $TOPDIR/version_string $INITRAMFS_DIR/etc/sysconfig/version
	echo -n $PRODUCT >> $INITRAMFS_DIR/etc/sysconfig/product
	find ${INITRAMFS_DIR} -name *.so* | xargs file | grep "ELF 32-bit" | awk -F: '{print $1}' | xargs ${CROSS_COMPILE}strip
	find ${INITRAMFS_DIR} -name *.gitkeep* | xargs rm 

### [#99] EAG6L 개발 검증 이슈 F/U, balkrow, 2024-08-30
	[ $EMBEDED_FPGA_IMG  == "y" ] && gen_fpga_image
}

function gdb_misc_install
{
	[ pwd == ${TOPDIR} ] || cd ${TOPDIR}
	[ -d $INITRAMFS_DIR/etc/sysconfig ] || mkdir -p $INITRAMFS_DIR/etc/sysconfig
	cp -avf $TOPDIR/version_string $INITRAMFS_DIR/etc/sysconfig/version
	echo -n $PRODUCT >> $INITRAMFS_DIR/etc/sysconfig/product
}

function gen_uImage
{
	EVAL_VERSION=`cat version_string`
	SYSTEM2=`echo ${PRODUCT}|tr '[a-z]' '[A-Z]'`
	#[#146] not changed compile-time when build package, balkrow, 2022-08-10
	#COMPILE_TIME=`grep -r "define COMPILE_TIME" package/zebra-0.95a/lib/compile_time.h | awk '{print $3}'`
	COMPILE_TIME=`date +\"%s\"`

	if [ ! -f ${TOPDIR}/build/uboot/tools/mkimage ]; then
		#[137] update product code, balkrow, 2022-08-08	
		echo "${TOPDIR}/build/uboot/tools/mkimage not found, please execute init_boot, build_boot";
		return 1;
	fi

	if [ $COMPRESS = "lzma" ]; then
		xz -f -k --format=lzma $KERNEL_OUTPUT/arch/arm64/boot/Image

		$TOPDIR/build/uboot/tools/mkimage -A arm -O linux -T multi -C $COMPRESS -a 0x80008000  -e 0x80008000 -t $COMPILE_TIME -n "${SYSTEM2} v$EVAL_VERSION" \
			-d $KERNEL_OUTPUT/arch/arm/boot/Image.lzma:$OUTPUT/hfr-initramfs.cpio:$KERNEL_OUTPUT/arch/arm/boot/dts/custom/$HFR_VENDOR_NAME/$BUILD_BOARD_NAME.dtb ${SYSTEM}-v${EVAL_VERSION}.bin
	elif [ $COMPRESS = "gzip" ]; then
		rm -f $KERNEL_OUTPUT/arch/arm/boot/Image.gz
		gzip -9 $KERNEL_OUTPUT/arch/arm/boot/Image
		$TOPDIR/build/uboot/tools/mkimage -A arm -O linux -T multi -C $COMPRESS  -a 0x80008000 -e 0x80008000 -t $COMPILE_TIME -n "${SYSTEM2} v$EVAL_VERSION" \
			-d $KERNEL_OUTPUT/arch/arm/boot/Image.gz:$OUTPUT/hfr-initramfs.cpio:$KERNEL_OUTPUT/arch/arm/boot/dts/custom/$HFR_VENDOR_NAME/$BUILD_BOARD_NAME.dtb ${SYSTEM}-v${EVAL_VERSION}.bin
	fi	

	cp -avf ${SYSTEM}-v${EVAL_VERSION}.bin $HOME
	cp -avf ${SYSTEM}-v${EVAL_VERSION}.bin $TFTPROOT/$USER
	cp -avf ${SYSTEM}-v${EVAL_VERSION}.bin scripts

	ls -al $TFTPROOT/$USER/${SYSTEM}-v${EVAL_VERSION}.bin
}

function gen_pack
{
	fbprint_n "generating package...."
# [#110] RDL function Debugging 및 수정, balkrow, 2024-09-04
  if [ ${EMBEDED_FPGA_IMG} == "n" ]; then 
    if [ ${INCLUDE_FPGA_IMG} == "y" ]; then 
      ${TOPDIR}/fpga/fpga_img_gen.sh || return
	    [ pwd == ${TOPDIR} ] || cd ${TOPDIR}/scripts
	    /bin/sh -c "./img_gen.sh $OS_IMG $FPGA_FW_IMG"
    else
	    [ pwd == ${TOPDIR} ] || cd ${TOPDIR}/scripts
	    /bin/sh -c "./img_gen.sh $OS_IMG"
    fi
  else
	  [ pwd == ${TOPDIR} ] || cd ${TOPDIR}/scripts
	  /bin/sh -c "./img_gen.sh $OS_IMG"
  fi

	if [ $? -ne 0 ] ; then
		fbprint_e "packaging.... fail"
		cd ${TOPDIR}
		return 1
	fi
	fbprint_d "generating package...."
	cd ${TOPDIR}
}

function build-project 
{
	[ $# -eq 0 ] && usage && return

	cmd=$1

	case "$cmd" in
    clean)
		clean_boot
		clean_kernel
		clean_package
        ;;
    init)
        init_kernel
		config_package
        ;;
    all)
        init_kernel
		if [ $? -ne 0 ] ; then
			return 1
		fi
        build_kernel
		if [ $? -ne 0 ] ; then
			return 1
		fi
		config_package
		if [ $? -ne 0 ] ; then
			return 1
		fi
        build_package
		if [ $? -ne 0 ] ; then
			return 1
		fi
        install_package
		if [ $? -ne 0 ] ; then
			return 1
		fi
		misc_install
        gen_initramfs_cpio
		gen_uImage
        ;;
    build)
        build_kernel
		if [ $? -ne 0 ] ; then
			return 1
		fi
        build_package
		if [ $? -ne 0 ] ; then
			return 1
		fi
        install_package
		if [ $? -ne 0 ] ; then
			return 1
		fi
		misc_install
        gen_initramfs_cpio
		gen_uImage
        ;;
    gdb)
        init_kernel
		if [ $? -ne 0 ] ; then
			return 1
		fi
        build_kernel
		if [ $? -ne 0 ] ; then
			return 1
		fi
		config_package
		if [ $? -ne 0 ] ; then
			return 1
		fi
        build_package debug
		if [ $? -ne 0 ] ; then
			return 1
		fi
        install_package debug
		if [ $? -ne 0 ] ; then
			return 1
		fi
		gdb_install
		gdb_misc_install
        gen_initramfs_cpio
		gen_uImage
        ;;
    gdb_build)
        build_package debug
		if [ $? -ne 0 ] ; then
			return 1
		fi
        install_package debug
		if [ $? -ne 0 ] ; then
			return 1
		fi
		gdb_install
		gdb_misc_install
        gen_initramfs_cpio
		gen_uImage
        ;;

    image)
        gen_initramfs_cpio
		gen_uImage
        ;;
	pkg)
### [#112] package build script renewal, balkrow, 2024-09-05
    echo -n "Package version[$PKG_VERSION]:"
    read pkg_ver 
    if ! [ -z $pkg_ver ]; then 
      PKG_VERSION=$pkg_ver
    fi
     
    echo -n "EMBEDED FPGA[$EMBEDED_FPGA_IMG](y or n):"
    read embeded 
    if ! [ -z $embeded ]; then 
      EMBEDED_FPGA_IMG=$embeded
    fi

    if [ $EMBEDED_FPGA_IMG == "n" ]; then 
### [#112] package build script renewal, balkrow, 2024-09-09
        echo -n "Include FPGA Image[$INCLUDE_FPGA_IMG](y or n):"
        read include_fpga_img 

        if ! [ -z $include_fpga_img ]; then 
          INCLUDE_FPGA_IMG=$include_fpga_img
        fi

        if [ $INCLUDE_FPGA_IMG == "y" ]; then 
            echo -n "FPGA POF Image[$FPGA_POF_FILE]:"
            read pof 
            if ! [ -z $pof ]; then 
              FPGA_POF_FILE=$pof
            fi

            echo -n "FPGA Image[$FPGA_FW_IMG]:"
            read fw_img 
            if ! [ -z $fw_img ]; then 
                  FPGA_FW_IMG=$fw_img
            fi
        fi
    else
            echo -n "FPGA POF Image[$FPGA_POF_FILE]:"
            read pof 
            if ! [ -z $pof ]; then 
              FPGA_POF_FILE=$pof
            fi

            echo -n "FPGA Image[$FPGA_FW_IMG]:"
            read fw_img 
            if ! [ -z $fw_img ]; then 
                  FPGA_FW_IMG=$fw_img
            fi
    fi

    echo "--------------------------------------"
    echo "PKG_VERION : $PKG_VERSION"
    echo "EMBEDED_FPGA_IMG : $EMBEDED_FPGA_IMG"
    echo "INCLUDE_FPGA_IMG : $INCLUDE_FPGA_IMG"
    echo "FPGA POF image : $FPGA_POF_FILE"
    echo "FPGA image : $FPGA_FW_IMG"
    echo "--------------------------------------"

    export PKG_VERSION EMBEDED_FPGA_IMG FPGA_POF_FILE FPGA_FW_IMG INCLUDE_FPGA_IMG
### [#112] package build script renewal, balkrow, 2024-09-09
    if [ $EMBEDED_FPGA_IMG == "n" ]; then 
		  gen_pack
    else
      echo "Automatic Include FPGA When OS build" 
    fi
		;;
    *)
		usage
		;;
esac
}

fbprint_e() {
    echo -e "${RED} $1 ${NC}"
}

fbprint_n() {
    echo -e "${green} $1 ${NC}"
}

fbprint() {
    echo -ne "${green} $1 ${NC}"
}

fbprint_w() {
    echo -e "${YELLOW} $1 ${NC}"
}

fbprint_d() {
    echo -e "${GREEN} $1     [Done] ${NC}"
}

red='\e[0;41m'
RED='\e[1;31m'
GREEN='\e[1;32m'
green='\e[0;32m'
yellow='\e[5;43m'
YELLOW='\e[1;33m'
NC='\e[0m'
